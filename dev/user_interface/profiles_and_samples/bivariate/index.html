<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Bivariate Profiles · LikelihoodBasedProfileWiseAnalysis.jl</title><meta name="title" content="Bivariate Profiles · LikelihoodBasedProfileWiseAnalysis.jl"/><meta property="og:title" content="Bivariate Profiles · LikelihoodBasedProfileWiseAnalysis.jl"/><meta property="twitter:title" content="Bivariate Profiles · LikelihoodBasedProfileWiseAnalysis.jl"/><meta name="description" content="Documentation for LikelihoodBasedProfileWiseAnalysis.jl."/><meta property="og:description" content="Documentation for LikelihoodBasedProfileWiseAnalysis.jl."/><meta property="twitter:description" content="Documentation for LikelihoodBasedProfileWiseAnalysis.jl."/><meta property="og:url" content="https://JoelTrent.github.io/LikelihoodBasedProfileWiseAnalysis.jl/user_interface/profiles_and_samples/bivariate/"/><meta property="twitter:url" content="https://JoelTrent.github.io/LikelihoodBasedProfileWiseAnalysis.jl/user_interface/profiles_and_samples/bivariate/"/><link rel="canonical" href="https://JoelTrent.github.io/LikelihoodBasedProfileWiseAnalysis.jl/user_interface/profiles_and_samples/bivariate/"/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">LikelihoodBasedProfileWiseAnalysis.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><a class="tocitem" href="../../../quick_start/">Quick Start</a></li><li><span class="tocitem">User Interface</span><ul><li><a class="tocitem" href="../../initialisation/">Initialisation</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox" checked/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Parameter Profiles and Samples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../profile_structs/">Structs and Profile Types</a></li><li><a class="tocitem" href="../univariate/">Univariate Profiles</a></li><li class="is-active"><a class="tocitem" href>Bivariate Profiles</a><ul class="internal"><li><a class="tocitem" href="#Methods-For-Finding-Boundaries"><span>Methods For Finding Boundaries</span></a></li><li><a class="tocitem" href="#Sampling-Internal-Points-From-Boundaries"><span>Sampling Internal Points From Boundaries</span></a></li><li><a class="tocitem" href="#Merging-Boundaries-From-Multiple-Methods"><span>Merging Boundaries From Multiple Methods</span></a></li></ul></li><li><a class="tocitem" href="../dimensional/">Dimensional Samples</a></li></ul></li><li><a class="tocitem" href="../../predictions/">Predictions</a></li><li><a class="tocitem" href="../../plots/">Plots</a></li><li><a class="tocitem" href="../../saving_and_loading/">Saving and Loading LikelihoodModels</a></li><li><a class="tocitem" href="../../timing_and_profiling/">Timing and Profiling</a></li><li><input class="collapse-toggle" id="menuitem-3-7" type="checkbox"/><label class="tocitem" for="menuitem-3-7"><span class="docs-label">Simulated Coverage Checks</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../coverage/univariate_intervals/">Parameter Confidence Intervals</a></li><li><a class="tocitem" href="../../coverage/bivariate_boundaries/">Bivariate Parameter Confidence Boundaries</a></li><li><a class="tocitem" href="../../coverage/predictions_and_realisations/">Predictions and Realisations</a></li></ul></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../../examples/">Initial Setup</a></li><li><a class="tocitem" href="../../../examples/logistic/">Logistic Model</a></li><li><a class="tocitem" href="../../../examples/lotka-volterra/">Lotka-Volterra Model</a></li><li><a class="tocitem" href="../../../examples/two-species_logistic/">Two-Species Logistic Model</a></li><li><a class="tocitem" href="../../../examples/binomial_normal_approximation/">Gaussian Approximation of a Binomial Distribution</a></li><li><a class="tocitem" href="../../../examples/logistic_timing_estimates/">Function Evaluation Timing - Logistic Model</a></li></ul></li><li><span class="tocitem">Internal Library</span><ul><li><a class="tocitem" href="../../../internal_library/common/">Common Functions</a></li><li><a class="tocitem" href="../../../internal_library/initialisation/">Initialisation</a></li><li><a class="tocitem" href="../../../internal_library/ellipse_likelihood/">Ellipse Functions</a></li><li><a class="tocitem" href="../../../internal_library/univariate/">Univariate Functions</a></li><li><a class="tocitem" href="../../../internal_library/bivariate/">Bivariate Functions</a></li><li><a class="tocitem" href="../../../internal_library/dimensional/">Dimensional Functions</a></li><li><a class="tocitem" href="../../../internal_library/predictions/">Prediction Functions</a></li><li><a class="tocitem" href="../../../internal_library/plots/">Plotting Functions</a></li><li><a class="tocitem" href="../../../internal_library/coverage/">Coverage Functions</a></li></ul></li><li><a class="tocitem" href="../../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Interface</a></li><li><a class="is-disabled">Parameter Profiles and Samples</a></li><li class="is-active"><a href>Bivariate Profiles</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Bivariate Profiles</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JoelTrent/LikelihoodBasedProfileWiseAnalysis.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JoelTrent/LikelihoodBasedProfileWiseAnalysis.jl/blob/main/docs/src/user_interface/profiles_and_samples/bivariate.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Bivariate-Profiles"><a class="docs-heading-anchor" href="#Bivariate-Profiles">Bivariate Profiles</a><a id="Bivariate-Profiles-1"></a><a class="docs-heading-anchor-permalink" href="#Bivariate-Profiles" title="Permalink"></a></h1><ul><li><a href="#LikelihoodBasedProfileWiseAnalysis.AbstractBivariateHullMethod"><code>LikelihoodBasedProfileWiseAnalysis.AbstractBivariateHullMethod</code></a></li><li><a href="#LikelihoodBasedProfileWiseAnalysis.AbstractBivariateMethod"><code>LikelihoodBasedProfileWiseAnalysis.AbstractBivariateMethod</code></a></li><li><a href="#LikelihoodBasedProfileWiseAnalysis.AbstractBivariateVectorMethod"><code>LikelihoodBasedProfileWiseAnalysis.AbstractBivariateVectorMethod</code></a></li><li><a href="#LikelihoodBasedProfileWiseAnalysis.AnalyticalEllipseMethod"><code>LikelihoodBasedProfileWiseAnalysis.AnalyticalEllipseMethod</code></a></li><li><a href="#LikelihoodBasedProfileWiseAnalysis.CombinedBivariateMethod"><code>LikelihoodBasedProfileWiseAnalysis.CombinedBivariateMethod</code></a></li><li><a href="#LikelihoodBasedProfileWiseAnalysis.ConcaveHullMethod"><code>LikelihoodBasedProfileWiseAnalysis.ConcaveHullMethod</code></a></li><li><a href="#LikelihoodBasedProfileWiseAnalysis.ContinuationMethod"><code>LikelihoodBasedProfileWiseAnalysis.ContinuationMethod</code></a></li><li><a href="#LikelihoodBasedProfileWiseAnalysis.ConvexHullMethod"><code>LikelihoodBasedProfileWiseAnalysis.ConvexHullMethod</code></a></li><li><a href="#LikelihoodBasedProfileWiseAnalysis.Fix1AxisMethod"><code>LikelihoodBasedProfileWiseAnalysis.Fix1AxisMethod</code></a></li><li><a href="#LikelihoodBasedProfileWiseAnalysis.IterativeBoundaryMethod"><code>LikelihoodBasedProfileWiseAnalysis.IterativeBoundaryMethod</code></a></li><li><a href="#LikelihoodBasedProfileWiseAnalysis.MPPHullMethod"><code>LikelihoodBasedProfileWiseAnalysis.MPPHullMethod</code></a></li><li><a href="#LikelihoodBasedProfileWiseAnalysis.RadialMLEMethod"><code>LikelihoodBasedProfileWiseAnalysis.RadialMLEMethod</code></a></li><li><a href="#LikelihoodBasedProfileWiseAnalysis.RadialRandomMethod"><code>LikelihoodBasedProfileWiseAnalysis.RadialRandomMethod</code></a></li><li><a href="#LikelihoodBasedProfileWiseAnalysis.SimultaneousMethod"><code>LikelihoodBasedProfileWiseAnalysis.SimultaneousMethod</code></a></li><li><a href="#LikelihoodBasedProfileWiseAnalysis.bivariate_confidenceprofiles!"><code>LikelihoodBasedProfileWiseAnalysis.bivariate_confidenceprofiles!</code></a></li><li><a href="#LikelihoodBasedProfileWiseAnalysis.bivariate_hull_methods"><code>LikelihoodBasedProfileWiseAnalysis.bivariate_hull_methods</code></a></li><li><a href="#LikelihoodBasedProfileWiseAnalysis.bivariate_methods"><code>LikelihoodBasedProfileWiseAnalysis.bivariate_methods</code></a></li><li><a href="#LikelihoodBasedProfileWiseAnalysis.combine_bivariate_boundaries!"><code>LikelihoodBasedProfileWiseAnalysis.combine_bivariate_boundaries!</code></a></li><li><a href="#LikelihoodBasedProfileWiseAnalysis.sample_bivariate_internal_points!"><code>LikelihoodBasedProfileWiseAnalysis.sample_bivariate_internal_points!</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LikelihoodBasedProfileWiseAnalysis.bivariate_confidenceprofiles!" href="#LikelihoodBasedProfileWiseAnalysis.bivariate_confidenceprofiles!"><code>LikelihoodBasedProfileWiseAnalysis.bivariate_confidenceprofiles!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bivariate_confidenceprofiles!(model::LikelihoodModel, 
    θcombinations::Vector{Vector{Int}}, 
    num_points::Int; 
    &lt;keyword arguments&gt;)</code></pre><p>Finds <code>num_points</code> <code>profile_type</code> boundary points at a specified <code>confidence_level</code> for each combination of two interest parameters using a specified <code>method</code>, optionally saving any found internal points. Saves these profiles by modifying <code>model</code> in place.</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: a <a href="../../initialisation/#LikelihoodBasedProfileWiseAnalysis.LikelihoodModel"><code>LikelihoodModel</code></a> containing model information, saved profiles and predictions.</li><li><code>θcombinations</code>: vector of pairs of parameters to profile, as a vector of vectors of model parameter indexes.</li><li><code>num_points</code>: positive number of points to find on the boundary at the specified confidence level. Depending on the method, if a region of the user-provided bounds is inside the boundary some of these points will be on the bounds and inside the boundary. Set to at least 3 within the function as some methods need at least three points to work.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>confidence_level</code>: a number ∈ (0.0, 1.0) for the confidence level on which to find the <code>profile_type</code> boundary. Default is <code>0.95</code> (95%).</li><li><code>dof</code>: an integer ∈ [2, <code>model.core.num_pars</code>] for the degrees of freedom used to define the asymptotic threshold (<a href="../../../internal_library/common/#LikelihoodBasedProfileWiseAnalysis.get_target_loglikelihood"><code>LikelihoodBasedProfileWiseAnalysis.get_target_loglikelihood</code></a>) which defines the boundary of the bivariate profile. For bivariate profiles that are considered individually, it should be set to <code>2</code>. For profiles that are considered simultaneously, it should be set to <code>model.core.num_pars</code>. Default is <code>2</code>. Setting it to <code>model.core.num_pars</code> should be reasonable when making predictions for well-identified models with <code>&lt;10</code> parameters. Note: values other than <code>2</code> and <code>model.core.num_pars</code> may not have a clear statistical interpretation.</li><li><code>profile_type</code>: whether to use the true log-likelihood function or an ellipse approximation of the log-likelihood function centred at the MLE (with optional use of parameter bounds). Available profile types are <a href="../profile_structs/#LikelihoodBasedProfileWiseAnalysis.LogLikelihood"><code>LogLikelihood</code></a>, <a href="../profile_structs/#LikelihoodBasedProfileWiseAnalysis.EllipseApprox"><code>EllipseApprox</code></a> and <a href="../profile_structs/#LikelihoodBasedProfileWiseAnalysis.EllipseApproxAnalytical"><code>EllipseApproxAnalytical</code></a>. Default is <code>LogLikelihood()</code> (<a href="../profile_structs/#LikelihoodBasedProfileWiseAnalysis.LogLikelihood"><code>LogLikelihood</code></a>).</li><li><code>method</code>: a method of type <a href="#LikelihoodBasedProfileWiseAnalysis.AbstractBivariateMethod"><code>AbstractBivariateMethod</code></a>. For a list of available methods use <code>bivariate_methods()</code> (<a href="#LikelihoodBasedProfileWiseAnalysis.bivariate_methods"><code>bivariate_methods</code></a>). Default is <code>RadialRandomMethod(5)</code> (<a href="#LikelihoodBasedProfileWiseAnalysis.RadialRandomMethod"><code>RadialRandomMethod</code></a>).</li><li><code>θlb_nuisance</code>: a vector of lower bounds on nuisance parameters, require <code>θlb_nuisance .≤ model.core.θmle</code>. Default is <code>model.core.θlb</code>. </li><li><code>θub_nuisance</code>: a vector of upper bounds on nuisance parameters, require <code>θub_nuisance .≥ model.core.θmle</code>. Default is <code>model.core.θub</code>.</li><li><code>save_internal_points</code>: boolean variable specifying whether to save points found inside the boundary during boundary computation. Internal points can be plotted in bivariate profile plots and will be used to generate predictions from a given bivariate profile. Default is <code>true</code>.</li><li><code>existing_profiles</code>: <code>Symbol ∈ [:ignore, :merge, :overwrite]</code> specifying what to do if profiles already exist for a given <code>θcombination</code>, <code>confidence_level</code>, <code>profile_type</code> and <code>method</code>. See below for each symbol&#39;s meanings. Default is <code>:merge</code>.</li><li><code>find_zero_atol</code>: a <code>Real</code> number greater than zero for the absolute tolerance of the log-likelihood function value from the target value to be used when searching for confidence intervals. Default is <code>model.find_zero_atol</code>.</li><li><code>optimizationsettings</code>: a <a href="../../initialisation/#LikelihoodBasedProfileWiseAnalysis.OptimizationSettings"><code>OptimizationSettings</code></a> struct containing the optimisation settings used to find optimal values of nuisance parameters for a given pair of interest parameter values. Default is <code>missing</code> (will use <code>model.core.optimizationsettings</code>).</li><li><code>show_progress</code>: boolean variable specifying whether to display progress bars on the percentage of <code>θcombinations</code> completed and estimated time of completion. Default is <code>model.show_progress</code>.</li><li><code>use_distributed</code>: boolean variable specifying whether to use a normal for loop or a <code>@distributed</code> for loop across combinations of interest parameters. Set this variable to <code>false</code> if <a href="https://docs.julialang.org/en/v1/stdlib/Distributed/">Distributed.jl</a> is not being used. Default is <code>true</code>.</li><li><code>use_threads</code>: boolean variable specifying, if <code>use_distributed</code> is false, whether to use parallelised for loops across <code>Threads.nthreads()</code> threads or a non-parallel for loops to find boundary points from <code>methods</code> where boundary points are found independently. Default is <code>true</code>.<ul><li><a href="#LikelihoodBasedProfileWiseAnalysis.Fix1AxisMethod"><code>Fix1AxisMethod</code></a> and <a href="#LikelihoodBasedProfileWiseAnalysis.RadialMLEMethod"><code>RadialMLEMethod</code></a> parallelise the finding point pair step and the finding the boundary from point pairs step.</li><li><a href="#LikelihoodBasedProfileWiseAnalysis.SimultaneousMethod"><code>SimultaneousMethod</code></a> and <a href="#LikelihoodBasedProfileWiseAnalysis.RadialRandomMethod"><code>RadialRandomMethod</code></a> do not parallelise the finding point pair step but parallelise finding the boundary from point pairs.</li><li><a href="#LikelihoodBasedProfileWiseAnalysis.ContinuationMethod"><code>ContinuationMethod</code></a> is not parallelised at all. </li><li><a href="#LikelihoodBasedProfileWiseAnalysis.IterativeBoundaryMethod"><code>IterativeBoundaryMethod</code></a> parallelises finding the initial boundary but not the following boundary improvement steps.</li><li><a href="#LikelihoodBasedProfileWiseAnalysis.AnalyticalEllipseMethod"><code>AnalyticalEllipseMethod</code></a> does not require parallelisation.</li></ul></li></ul><div class="admonition is-info"><header class="admonition-header">existing_profiles meanings</header><div class="admonition-body"><ul><li>:ignore means profiles that already exist will not be recomputed even if they contain fewer <code>num_points</code> boundary points. </li><li>:merge means profiles that already exist will be merged with profiles from the current algorithm run to reach <code>num_points</code>. If the existing profile already has at least <code>num_points</code> boundary points then that profile will not be recomputed. Otherwise, the specified method will be run starting from the difference between <code>num_points</code> and the number of points in the existing profile. The result of that method run will be merged with the existing profile. Predictions evaluated from the existing profile will be forgotten. To keep these predictions see extended help below.</li><li>:overwrite means profiles that already exist will be overwritten, regardless of how many points they contain. Predictions evaluated from the existing profile will be forgotten. To keep these predictions see extended help below.</li></ul></div></div><p><strong>Details</strong></p><p>Using <a href="../../../internal_library/bivariate/#LikelihoodBasedProfileWiseAnalysis.bivariate_confidenceprofile"><code>LikelihoodBasedProfileWiseAnalysis.bivariate_confidenceprofile</code></a> this function calls the algorithm/method specified by <code>method</code> for each interest parameter combination in <code>θcombinations</code> (depending on the setting for <code>existing_profiles</code> and <code>num_points</code> if these profiles already exist). Nuisance parameters of each point in bivariate interest parameter space are found by maximising the log-likelihood function given by <code>profile_type</code>. Updates <code>model.biv_profiles_df</code> for each successful profile and saves their results as a <a href="../profile_structs/#LikelihoodBasedProfileWiseAnalysis.BivariateConfidenceStruct"><code>BivariateConfidenceStruct</code></a> in <code>model.biv_profiles_dict</code>, where the keys for the dictionary is the row number in <code>model.biv_profiles_df</code> of the corresponding profile. <code>model.biv_profiles_df.num_points</code> is the number of points found on the bivariate boundary (it does not include the number of saved internal points).</p><p><strong>Extended help</strong></p><p><strong>Valid bounds</strong></p><p>For methods that use points placed on parameter bounds to bracket for the confidence boundary, the bracketing method utilised via Roots.jl&#39;s <a href="https://juliamath.github.io/Roots.jl/stable/reference/#Roots.find_zero"><code>find_zero</code></a> will be unlikely to converge to the true confidence boundary for a given pair of interest parameters if the bounds on either parameter are +/- Inf or the log-likelihood function evaluates to +/- Inf. Bounds should be set to prevent this from occurring.</p><p><strong>Preventing predictions from being forgotten when merging or overwriting profiles</strong></p><p>To prevent predictions from being lost from existing profiles that would be overwritten when calling <a href="#LikelihoodBasedProfileWiseAnalysis.bivariate_confidenceprofiles!"><code>bivariate_confidenceprofiles!</code></a>, existing profiles should be converted into a [<code>CombinedBivariateMethod</code>], prior to running new bivariate profiles. To do this use <a href="#LikelihoodBasedProfileWiseAnalysis.combine_bivariate_boundaries!"><code>combine_bivariate_boundaries!</code></a> on <code>model</code> with keyword argument <code>not_evaluated_predictions</code> set to <code>false</code>.</p><p><strong>Distributed Computing Implementation</strong></p><p>If <a href="https://docs.julialang.org/en/v1/stdlib/Distributed/">Distributed.jl</a> is being used and <code>use_distributed</code> is <code>true</code>, then the bivariate profiles of distinct interest parameter combinations will be computed in parallel across <code>Distributed.nworkers()</code> workers. If <code>use_distributed</code> is <code>false</code> and <code>use_threads</code> is <code>true</code> then for methods where finding boundary points is independent they will be computed in parallel across <code>Threads.nthreads()</code> threads for each pair of interest parameters.</p><p><strong>Iteration Speed Of the Progress Meter</strong></p><p>The time/it value is the time it takes for each new boundary point to be found (for all methods except for <a href="#LikelihoodBasedProfileWiseAnalysis.AnalyticalEllipseMethod"><code>AnalyticalEllipseMethod</code></a> and <a href="#LikelihoodBasedProfileWiseAnalysis.ContinuationMethod"><code>ContinuationMethod</code></a>). For <a href="#LikelihoodBasedProfileWiseAnalysis.AnalyticalEllipseMethod"><code>AnalyticalEllipseMethod</code></a> this is the time it takes to find all points on the boundary of the ellipse of two interest parameters. For <a href="#LikelihoodBasedProfileWiseAnalysis.ContinuationMethod"><code>ContinuationMethod</code></a> this is the time it takes to find each new point, internal or on the boundary.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoelTrent/LikelihoodBasedProfileWiseAnalysis.jl/blob/55f4fe2d75537cb7c288254e10a9145f26adc74a/src/bivariate_methods/bivariate_profile_likelihood.jl#L292-L351">source</a></section><section><div><pre><code class="language-julia hljs">bivariate_confidenceprofiles!(model::LikelihoodModel, 
    θcombinations_symbols::Union{Vector{Vector{Symbol}}, Vector{Tuple{Symbol, Symbol}}}, 
    num_points::Int; 
    &lt;keyword arguments&gt;)</code></pre><p>Profiles just the provided <code>θcombinations_symbols</code> parameter pairs, provided as either a vector of vectors or a vector of tuples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoelTrent/LikelihoodBasedProfileWiseAnalysis.jl/blob/55f4fe2d75537cb7c288254e10a9145f26adc74a/src/bivariate_methods/bivariate_profile_likelihood.jl#L557-L564">source</a></section><section><div><pre><code class="language-julia hljs">bivariate_confidenceprofiles!(model::LikelihoodModel, 
    profile_m_random_combinations::Int, 
    num_points::Int; 
    &lt;keyword arguments&gt;)</code></pre><p>Profiles m random two-way combinations of model parameters (sampling without replacement), where <code>0 &lt; m ≤ binomial(model.core.num_pars,2)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoelTrent/LikelihoodBasedProfileWiseAnalysis.jl/blob/55f4fe2d75537cb7c288254e10a9145f26adc74a/src/bivariate_methods/bivariate_profile_likelihood.jl#L599-L606">source</a></section><section><div><pre><code class="language-julia hljs">bivariate_confidenceprofiles!(model::LikelihoodModel, 
    num_points::Int; 
    &lt;keyword arguments&gt;)</code></pre><p>Profiles all two-way combinations of model parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoelTrent/LikelihoodBasedProfileWiseAnalysis.jl/blob/55f4fe2d75537cb7c288254e10a9145f26adc74a/src/bivariate_methods/bivariate_profile_likelihood.jl#L645-L651">source</a></section></article><h2 id="Methods-For-Finding-Boundaries"><a class="docs-heading-anchor" href="#Methods-For-Finding-Boundaries">Methods For Finding Boundaries</a><a id="Methods-For-Finding-Boundaries-1"></a><a class="docs-heading-anchor-permalink" href="#Methods-For-Finding-Boundaries" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LikelihoodBasedProfileWiseAnalysis.AbstractBivariateMethod" href="#LikelihoodBasedProfileWiseAnalysis.AbstractBivariateMethod"><code>LikelihoodBasedProfileWiseAnalysis.AbstractBivariateMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractBivariateMethod</code></pre><p>Supertype for bivariate boundary finding methods. Use <code>bivariate_methods()</code> for a list of available methods (see <a href="#LikelihoodBasedProfileWiseAnalysis.bivariate_methods"><code>bivariate_methods</code></a>).</p><p><strong>Subtypes</strong></p><p><a href="#LikelihoodBasedProfileWiseAnalysis.AbstractBivariateVectorMethod"><code>AbstractBivariateVectorMethod</code></a></p><p><a href="#LikelihoodBasedProfileWiseAnalysis.CombinedBivariateMethod"><code>CombinedBivariateMethod</code></a></p><p><a href="#LikelihoodBasedProfileWiseAnalysis.Fix1AxisMethod"><code>Fix1AxisMethod</code></a></p><p><a href="#LikelihoodBasedProfileWiseAnalysis.ContinuationMethod"><code>ContinuationMethod</code></a></p><p><a href="#LikelihoodBasedProfileWiseAnalysis.AnalyticalEllipseMethod"><code>AnalyticalEllipseMethod</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoelTrent/LikelihoodBasedProfileWiseAnalysis.jl/blob/55f4fe2d75537cb7c288254e10a9145f26adc74a/src/types/bivariate_methods.jl#L3-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LikelihoodBasedProfileWiseAnalysis.AbstractBivariateVectorMethod" href="#LikelihoodBasedProfileWiseAnalysis.AbstractBivariateVectorMethod"><code>LikelihoodBasedProfileWiseAnalysis.AbstractBivariateVectorMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractBivariateVectorMethod &lt;: AbstractBivariateMethod</code></pre><p>Supertype for bivariate boundary finding methods that search between two distinct points. </p><p><strong>Subtypes</strong></p><p><a href="#LikelihoodBasedProfileWiseAnalysis.IterativeBoundaryMethod"><code>IterativeBoundaryMethod</code></a></p><p><a href="#LikelihoodBasedProfileWiseAnalysis.RadialMLEMethod"><code>RadialMLEMethod</code></a></p><p><a href="#LikelihoodBasedProfileWiseAnalysis.RadialRandomMethod"><code>RadialRandomMethod</code></a></p><p><a href="#LikelihoodBasedProfileWiseAnalysis.SimultaneousMethod"><code>SimultaneousMethod</code></a></p><p><strong>Supertype Hiearachy</strong></p><p><code>AbstractBivariateVectorMethod &lt;: AbstractBivariateMethod &lt;: Any</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoelTrent/LikelihoodBasedProfileWiseAnalysis.jl/blob/55f4fe2d75537cb7c288254e10a9145f26adc74a/src/types/bivariate_methods.jl#L22-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LikelihoodBasedProfileWiseAnalysis.bivariate_methods" href="#LikelihoodBasedProfileWiseAnalysis.bivariate_methods"><code>LikelihoodBasedProfileWiseAnalysis.bivariate_methods</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bivariate_methods()</code></pre><p>Prints a list of available bivariate methods. Available bivariate methods include <a href="#LikelihoodBasedProfileWiseAnalysis.IterativeBoundaryMethod"><code>IterativeBoundaryMethod</code></a>, <a href="#LikelihoodBasedProfileWiseAnalysis.RadialRandomMethod"><code>RadialRandomMethod</code></a>, <a href="#LikelihoodBasedProfileWiseAnalysis.RadialMLEMethod"><code>RadialMLEMethod</code></a>, <a href="#LikelihoodBasedProfileWiseAnalysis.SimultaneousMethod"><code>SimultaneousMethod</code></a>, <a href="#LikelihoodBasedProfileWiseAnalysis.Fix1AxisMethod"><code>Fix1AxisMethod</code></a>, <a href="#LikelihoodBasedProfileWiseAnalysis.ContinuationMethod"><code>ContinuationMethod</code></a> and <a href="#LikelihoodBasedProfileWiseAnalysis.AnalyticalEllipseMethod"><code>AnalyticalEllipseMethod</code></a>. Note: <a href="#LikelihoodBasedProfileWiseAnalysis.CombinedBivariateMethod"><code>CombinedBivariateMethod</code></a> represents a destructive merge of the boundary structs of one or more methods and is not a valid method for <a href="#LikelihoodBasedProfileWiseAnalysis.bivariate_confidenceprofiles!"><code>bivariate_confidenceprofiles!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoelTrent/LikelihoodBasedProfileWiseAnalysis.jl/blob/55f4fe2d75537cb7c288254e10a9145f26adc74a/src/types/bivariate_methods.jl#L479-L483">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LikelihoodBasedProfileWiseAnalysis.IterativeBoundaryMethod" href="#LikelihoodBasedProfileWiseAnalysis.IterativeBoundaryMethod"><code>LikelihoodBasedProfileWiseAnalysis.IterativeBoundaryMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IterativeBoundaryMethod(initial_num_points::Int, 
    angle_points_per_iter::Int, 
    edge_points_per_iter::Int, 
    radial_start_point_shift::Float64=rand(), 
    ellipse_sqrt_distortion::Float64=1.0;
    use_ellipse::Bool=false)</code></pre><p>Method for iteratively improving an initial boundary of <code>initial_num_points</code>, found by pushing out from the MLE point in directions defined by either <a href="#LikelihoodBasedProfileWiseAnalysis.RadialMLEMethod"><code>RadialMLEMethod</code></a>, when <code>use_ellipse=true</code>, or <a href="#LikelihoodBasedProfileWiseAnalysis.RadialRandomMethod"><code>RadialRandomMethod</code></a>, when <code>use_ellipse=false</code> (see <a href="../../../internal_library/bivariate/#LikelihoodBasedProfileWiseAnalysis.findNpointpairs_radialMLE!"><code>LikelihoodBasedProfileWiseAnalysis.findNpointpairs_radialMLE!</code></a>, <a href="../../../internal_library/bivariate/#LikelihoodBasedProfileWiseAnalysis.iterativeboundary_init"><code>LikelihoodBasedProfileWiseAnalysis.iterativeboundary_init</code></a> and <a href="../../../internal_library/bivariate/#LikelihoodBasedProfileWiseAnalysis.bivariate_confidenceprofile_iterativeboundary"><code>LikelihoodBasedProfileWiseAnalysis.bivariate_confidenceprofile_iterativeboundary</code></a>).</p><p><strong>Arguments</strong></p><ul><li><code>initial_num_points</code>: a positive integer number of initial boundary points to find. </li><li><code>angle_points_per_iter</code>: a integer ≥ 0 for the number of edges to explore and improve based on the angle objective before switching to the edge objective. If <code>angle_points_per_iter &gt; 0</code> and <code>edge_points_per_iter &gt; 0</code> the angle objective is considered first.</li><li><code>edge_points_per_iter</code>:  a integer ≥ 0 for the number of edges to explore and improve based on the edge objective before switching back to the angle objective. If <code>angle_points_per_iter &gt; 0</code> and <code>edge_points_per_iter &gt; 0</code> the angle objective is considered first.</li><li><code>radial_start_point_shift</code>: a number ∈ [0.0,1.0]. Default is <code>rand()</code> (defined on [0.0,1.0]), meaning that by default a different set of initial points will be found each time.</li><li><code>ellipse_sqrt_distortion</code>: a number ∈ [0.0,1.0]. Default is <code>0.01</code>. </li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>use_ellipse</code>: Whether to find <code>initial_num_points</code> by searching in directions defined by an ellipse approximation, as in <a href="#LikelihoodBasedProfileWiseAnalysis.RadialMLEMethod"><code>RadialMLEMethod</code></a>, or as in <a href="#LikelihoodBasedProfileWiseAnalysis.RadialRandomMethod"><code>RadialRandomMethod</code></a>. Default is <code>false</code>.</li></ul><p><strong>Details</strong></p><p>For additional information on the <code>radial_start_point_shift</code> and <code>ellipse_sqrt_distortion</code> arguments see the keyword arguments for <a href="https://joeltrent.github.io/EllipseSampling.jl/stable/user_interface/#EllipseSampling.generate_N_clustered_points"><code>generate_N_clustered_points</code></a> in <a href="https://joeltrent.github.io/EllipseSampling.jl/stable">EllipseSampling.jl</a>.</p><p>Recommended for use with the <a href="../profile_structs/#LikelihoodBasedProfileWiseAnalysis.LogLikelihood"><code>LogLikelihood</code></a> profile type. Radial directions, edge length and internal angle calculations are rescaled by the relative magnitude/scale of the two interest parameters. This is so directions and regions explored and consequently the boundary found are not dominated by the parameter with the larger magnitude.</p><p>Once an initial boundary is found by pushing out from the MLE point in directions defined by either <a href="#LikelihoodBasedProfileWiseAnalysis.RadialMLEMethod"><code>RadialMLEMethod</code></a> or <a href="#LikelihoodBasedProfileWiseAnalysis.RadialRandomMethod"><code>RadialRandomMethod</code></a>, the method seeks to improve this boundary by minimising an internal angle and an edge length objective, each considered sequentially, until the desired number of boundary points are found. As such, the method can be thought of as a mesh smoothing or improvement algorithm; we can consider the boundary found at a given moment in time to be a N-sided polygon with edges between adjacent boundary points (vertices). </p><p><strong>Extended help</strong></p><p>Regions we define as needing improvement are those with:</p><ol><li>Internal angles between adjacent edges that are far from being straight (180 degrees or π radians). The region defined by these edges is not well explored as the real boundary edge in this region likely has some degree of smooth curvature. It may also indicate that one of these edges cuts our boundary into a enclosed region and an unexplored region on the other side of the edge. In the event that a vertex is on a user-provided bound for a parameter, this objective is set to zero, as this angle region is a byproduct of user input and not the actual log-likelihood region. This objective is defined in <a href="../../../internal_library/bivariate/#LikelihoodBasedProfileWiseAnalysis.internal_angle_from_pi!"><code>LikelihoodBasedProfileWiseAnalysis.internal_angle_from_pi!</code></a>.</li><li>Edges between adjacent vertices that have a large euclidean distance. The regions between these vertices is not well explored as it is unknown whether the boundary actually is straight between these vertices. On average the closer two vertices are, the more likely the edge between the two points is well approximated by a straight line, and thus our mesh is a good representation of the true log-likelihood boundary. This objective is defined in <a href="../../../internal_library/bivariate/#LikelihoodBasedProfileWiseAnalysis.edge_length"><code>LikelihoodBasedProfileWiseAnalysis.edge_length</code></a>.</li></ol><p>The method is implemented as follows:</p><ol><li>Create edges between adjacent vertices on the intial boundary. Calculate angle and edge length objectives for these edges and vertices and place them into tracked heaps.</li><li>Until found the desired number of boundary points repeat steps 3 and 4.</li><li>For <code>angle_points_per_iter</code> points:<ol><li>Peek at the top vertex of the angle heap.</li><li>Place a candidate point in the middle of the edge connected to this vertex that has the larger angle at the vertex the edge connects to. This is so we explore the worse defined region of the boundary.</li><li>Use this candidate to find a new boundary point (see below).</li><li>If found a new boundary point, break edge we placed candidate on and replace with edges to the new boundary point, updating angle and edge length objectives in the tracked heap (see <a href="../../../internal_library/bivariate/#LikelihoodBasedProfileWiseAnalysis.heapupdates_success!"><code>LikelihoodBasedProfileWiseAnalysis.heapupdates_success!</code></a>). Else break our polygon into multiple polygons (see <a href="../../../internal_library/bivariate/#LikelihoodBasedProfileWiseAnalysis.heapupdates_failure!"><code>LikelihoodBasedProfileWiseAnalysis.heapupdates_failure!</code></a>).</li></ol></li><li>For <code>edge_points_per_iter</code> points:<ol><li>Peek at the top edge of the edge heap.</li><li>Place a candidate point in the middle of this edge.</li><li>Same as for step 3.3.</li><li>Same as for step 3.4.</li></ol></li></ol><div class="admonition is-info"><header class="admonition-header">angle_points_per_iter and edge_points_per_iter</header><div class="admonition-body"><p>At least one of <code>angle_points_per_iter</code> and <code>edge_points_per_iter</code> must be non-zero.</p></div></div><div class="admonition is-info"><header class="admonition-header">Using a candidate point to find a new boundary point</header><div class="admonition-body"><p>Uses <a href="../../../internal_library/bivariate/#LikelihoodBasedProfileWiseAnalysis.newboundarypoint!"><code>LikelihoodBasedProfileWiseAnalysis.newboundarypoint!</code></a>.</p><p>If a candidate point is on the log-likelihood threshold boundary, we accept the point.</p><p>If a candidate point is inside the boundary, then we search in the normal direction to the edge until we find a boundary point or hit the parameter bound, accepting either.</p><p>If a candidate point is outside the boundary we find the edge, <code>e_intersect</code> of our boundary polygon that is intersected by the line in the normal direction of the candidate edge, which passes through the candidate point. Once this edge is found, we find the vertex on <code>e_intersect</code> that is closest to our candidate point, subject to that vertex not also being on the candidate point edge. We setup a 1D line search/bracketing method between these two points. In the event that no boundary points are found between these two points it is likely that multiple boundaries exist. If so, we break the candidate point&#39;s edge and <code>e_intersect</code> and reconnect the vertexes such that we now have multiple boundary polygons.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Largest boundary polygon at any iteration must have at least three points</header><div class="admonition-body"><p>If the largest polygon has less than two points the method will display a warning message and terminate, returning the boundary found up until then. </p></div></div><p><strong>Boundary finding method</strong></p><p>For the initial boundary, it uses a 1D bracketing algorithm between the MLE point and the point on the user-provided bounds in the search directions to find the boundary at the desired confidence level. For boundary improvement, if the candidate point is inside the boundary, it uses a 1D bracketing algorithm between an internal point and the point on the user-provided bounds in the search direction. If the candidate point is outside the boundary, it uses a derivative-free 1D line search algorithm in the search direction. If the derivative-free approach fails, it switches to a bracketing heuristic between the candidate point and closest vertex on <code>e_intersect</code>.</p><p>This method is unlikely to find boundaries that do not contain the MLE point (if they exist), but it can find them. If a boundary that does not contain the MLE point is found, it is not guaranteed to be explored. In this case the the method will inform the user that multiple boundaries likely exist for this combination of model parameters.</p><p><strong>Impact of parameter bounds</strong></p><p>If a parameter bound is in the way of reaching the boundary in a given search direction, the point on that bound will be returned as the boundary point. For the bracketing method to work, parameter values on the bounds need to be legal and return a non <code>Inf</code> value from the log-likelihood function. Interest parameter bounds that have ranges magnitudes larger than the range of the boundary may prevent the true boundary from being found. Additionally, the bracketing method will be less efficient if the interest parameter bounds are far from the true boundary. </p><p><strong>Threaded implementation</strong></p><p>This method is partially implemented with Threads parallelisation if <code>use_threads</code> is set to true when calling <a href="#LikelihoodBasedProfileWiseAnalysis.bivariate_confidenceprofiles!"><code>bivariate_confidenceprofiles!</code></a>. The initial boundary step is partially parallelised (the finding point pairs step is not parallelised and the finding boundary from point pairs step is parallelised) while the boundary improvement steps are not.</p><p><strong>Internal Points</strong></p><p>Finds between 0 and <code>num_points - initial_num_points</code> internal points - internal points are found when the edge being considered&#39;s midpoint is inside the boundary. </p><p><strong>Supertype Hiearachy</strong></p><p><code>IterativeBoundaryMethod &lt;: AbstractBivariateVectorMethod &lt;: AbstractBivariateMethod &lt;: Any</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoelTrent/LikelihoodBasedProfileWiseAnalysis.jl/blob/55f4fe2d75537cb7c288254e10a9145f26adc74a/src/types/bivariate_methods.jl#L50-L138">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LikelihoodBasedProfileWiseAnalysis.RadialMLEMethod" href="#LikelihoodBasedProfileWiseAnalysis.RadialMLEMethod"><code>LikelihoodBasedProfileWiseAnalysis.RadialMLEMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RadialMLEMethod(ellipse_start_point_shift::Float64=rand(), 
    ellipse_sqrt_distortion::Float64=0.01)</code></pre><p>Method for finding the bivariate boundary of a confidence profile by bracketing between the MLE point and points on the provided bounds in directions given by points found on the boundary of a ellipse approximation of the log-likelihood function around the MLE, <code>e</code>, using <a href="https://joeltrent.github.io/EllipseSampling.jl/stable">EllipseSampling.jl</a> (see <a href="../../../internal_library/bivariate/#LikelihoodBasedProfileWiseAnalysis.findNpointpairs_radialMLE!"><code>LikelihoodBasedProfileWiseAnalysis.findNpointpairs_radialMLE!</code></a> and <a href="../../../internal_library/bivariate/#LikelihoodBasedProfileWiseAnalysis.bivariate_confidenceprofile_vectorsearch"><code>LikelihoodBasedProfileWiseAnalysis.bivariate_confidenceprofile_vectorsearch</code></a>). </p><p><strong>Arguments</strong></p><ul><li><code>ellipse_start_point_shift</code>: a number ∈ [0.0,1.0]. Default is <code>rand()</code> (defined on [0.0,1.0]), meaning that by default a different set of points will be found each time.</li><li><code>ellipse_sqrt_distortion</code>: a number ∈ [0.0,1.0]. Default is <code>0.01</code>. </li></ul><p><strong>Details</strong></p><p>As for <a href="../univariate/#LikelihoodBasedProfileWiseAnalysis.univariate_confidenceintervals!"><code>univariate_confidenceintervals!</code></a> with keyword argument <code>use_ellipse_approx_analytical_start=true</code>, the profile log-likelihood function will be evaluated at each ellipse point prior to creating the point pair bracket. If:</p><ol><li>the ellipse point is outside of the provided bounds, the MLE point and the point on the provided bounds in the direction of the ellipse point from the MLE is the point pair for bracketing.</li><li>the ellipse point is between the desired boundary and the provided bounds, the MLE point and the ellipse point is the point pair for bracketing.</li><li>the ellipse point is between the MLE point and the desired boundary, the ellipse point and the point on the provided bounds is the point pair for bracketing.</li><li>the ellipse point is exactly on the desired boundary (profile log-likelihood function evaluates to exactly the confidence level threshold), the ellipse point is the boundary point and the method will (wrongfully) state there&#39;s a point on the bounds. From a numerical perspective this is incredibly unlikely so this is regarded as not a big deal. </li></ol><p>For additional information on arguments see the keyword arguments for <a href="https://joeltrent.github.io/EllipseSampling.jl/stable/user_interface/#EllipseSampling.generate_N_clustered_points"><code>generate_N_clustered_points</code></a> in <a href="https://joeltrent.github.io/EllipseSampling.jl/stable">EllipseSampling.jl</a>.</p><p>Recommended for use with the <a href="../profile_structs/#LikelihoodBasedProfileWiseAnalysis.EllipseApprox"><code>EllipseApprox</code></a> profile type. Will produce reasonable results for the <a href="../profile_structs/#LikelihoodBasedProfileWiseAnalysis.LogLikelihood"><code>LogLikelihood</code></a> profile type when bivariate profile boundaries are convex. Otherwise, <a href="#LikelihoodBasedProfileWiseAnalysis.IterativeBoundaryMethod"><code>IterativeBoundaryMethod</code></a>, which has an option to use a starting solution from <a href="#LikelihoodBasedProfileWiseAnalysis.RadialMLEMethod"><code>RadialMLEMethod</code></a>, is preferred as it iteratively improves the quality of the boundary and can discover regions not explored by this method. </p><p><strong>Extended help</strong></p><p><strong>Boundary finding method</strong></p><p>Uses a 1D bracketing algorithm between the MLE point and the point on the user-provided bounds in the search directions to find the boundary at the desired confidence level. Will replace one of these sides with the ellipse point depending on which side of the boundary the ellipse point is on, subject to it being between the two points. </p><p>This method is unlikely to find boundaries that do not contain the MLE point (if they exist).</p><p><strong>Impact of parameter bounds</strong></p><p>If a parameter bound is in the way of reaching the boundary in a given search direction, the point on that bound will be returned as the boundary point. For the bracketing method to work, parameter values on the bounds need to be legal and return a non <code>Inf</code> value from the log-likelihood function. Interest parameter bounds that have ranges magnitudes larger than the range of the boundary may prevent the true boundary from being found. Additionally, the bracketing method will be less efficient if the interest parameter bounds are far from the true boundary. </p><p><strong>Threaded implementation</strong></p><p>This method is partially implemented with Threads parallelisation if <code>use_threads</code> is set to true when calling <a href="#LikelihoodBasedProfileWiseAnalysis.bivariate_confidenceprofiles!"><code>bivariate_confidenceprofiles!</code></a>. The finding point pairs step is not parallelised and the finding boundary from point pairs step is parallelised.</p><p><strong>Internal Points</strong></p><p>Finds no internal points.</p><p><strong>Supertype Hiearachy</strong></p><p><code>RadialMLEMethod &lt;: AbstractBivariateVectorMethod &lt;: AbstractBivariateMethod &lt;: Any</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoelTrent/LikelihoodBasedProfileWiseAnalysis.jl/blob/55f4fe2d75537cb7c288254e10a9145f26adc74a/src/types/bivariate_methods.jl#L161-L207">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LikelihoodBasedProfileWiseAnalysis.RadialRandomMethod" href="#LikelihoodBasedProfileWiseAnalysis.RadialRandomMethod"><code>LikelihoodBasedProfileWiseAnalysis.RadialRandomMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RadialRandomMethod(num_radial_directions::Int, use_MLE_point::Bool=true)</code></pre><p>Method for finding the bivariate boundary of a confidence profile by finding internal boundary points using a uniform random distribution on provided bounds and choosing <code>num_radial_directions</code> to explore from these points (see <a href="../../../internal_library/bivariate/#LikelihoodBasedProfileWiseAnalysis.findNpointpairs_radialrandom!"><code>LikelihoodBasedProfileWiseAnalysis.findNpointpairs_radialrandom!</code></a> and <a href="../../../internal_library/bivariate/#LikelihoodBasedProfileWiseAnalysis.bivariate_confidenceprofile_vectorsearch"><code>LikelihoodBasedProfileWiseAnalysis.bivariate_confidenceprofile_vectorsearch</code></a>).</p><p><strong>Arguments</strong></p><ul><li><code>num_radial_directions</code>: an integer greater than zero. </li><li><code>use_MLE_point</code>: whether to use the MLE point as the first internal point found or not. Default is true (use).</li></ul><p><strong>Details</strong></p><p>Recommended for use with the <a href="../profile_structs/#LikelihoodBasedProfileWiseAnalysis.LogLikelihood"><code>LogLikelihood</code></a> profile type. Radial directions are rescaled by the relative magnitude/scale of the two interest parameters. This is so directions explored and consequently the boundary found are not dominated by the parameter with the larger magnitude.</p><p>The method first uniformly samples the region specified by the bounds for the two interest parameters until a point within the boundary is found. Then it chooses <code>num_radial_directions</code>, spaced uniformly around a circle, and rotates these directions by a random phase shift ∈ <code>[0.0, 2π/num_directions]</code> radians. These directions are then distorted by the relative magnitude/scale of the two interest parameters. Then for each of these directions, until it runs out of directions or finds the desired number of points, it finds the closest point on the bounds from the internal point in this direction. If the point on the bounds is inside the boundary it will be used in place of the boundary point. If the point on the bounds is outside the boundary then it will be used as the external point in the point pair. A bracketing method is then used to find a boundary point between the point pair (the bound point and the internal point). The method continues searching for internal points and generating directions until the desired number of boundary points is found.</p><p>Given a fixed number of desired boundary points, we can decrease the cost of finding internal points by increasing the number of radial directions to explore, <code>num_radial_directions</code>, at each internal point. However, it is important to balance <code>num_radial_directions</code> with the desired number of boundary points. If <code>num_radial_directions</code> is large relative to the number of boundary points, then the boundary the method finds may constitute a local search around the found internal points. Resultantly, there may be regions were the boundary is not well explored. This will be less of an issue for more &#39;circular&#39; boundary regions.   </p><p><a href="#LikelihoodBasedProfileWiseAnalysis.IterativeBoundaryMethod"><code>IterativeBoundaryMethod</code></a> may be preferred over this method if evaluating the log-likelihood function is expensive or the bounds provided for the interest parameters are much larger than the boundary, as the uniform random sampling for internal points will become very expensive. </p><p><strong>Extended help</strong></p><p><strong>Boundary finding method</strong></p><p>Uses a 1D bracketing algorithm between an internal point and the point on the user-provided bounds in the search direction to find the boundary at the desired confidence level.  </p><p>This method can find multiple boundaries (if they exist).</p><p><strong>Impact of parameter bounds</strong></p><p>If a parameter bound is in the way of reaching the boundary in a given search direction, in the same way as <a href="#LikelihoodBasedProfileWiseAnalysis.RadialMLEMethod"><code>RadialMLEMethod</code></a>, the point on that bound will be returned as the boundary point. For the bracketing method to work, parameter values on the bounds need to be legal and return a non <code>Inf</code> value from the log-likelihood function. Interest parameter bounds that have ranges magnitudes larger than the range of the boundary may prevent the true boundary from being found. Additionally, the bracketing method will be less efficient if the interest parameter bounds are far from the true boundary.</p><p><strong>Threaded implementation</strong></p><p>This method is partially implemented with Threads parallelisation if <code>use_threads</code> is set to true when calling <a href="#LikelihoodBasedProfileWiseAnalysis.bivariate_confidenceprofiles!"><code>bivariate_confidenceprofiles!</code></a>. The finding point pairs step is not parallelised and the finding boundary from point pairs step is parallelised.</p><p><strong>Internal Points</strong></p><p>Finds a minimum of <code>div(num_points, num_radial_directions, RoundUp) - 1*use_MLE_point</code> internal points.</p><p><strong>Supertype Hiearachy</strong></p><p><code>RadialRandomMethod &lt;: AbstractBivariateVectorMethod &lt;: AbstractBivariateMethod &lt;: Any</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoelTrent/LikelihoodBasedProfileWiseAnalysis.jl/blob/55f4fe2d75537cb7c288254e10a9145f26adc74a/src/types/bivariate_methods.jl#L219-L261">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LikelihoodBasedProfileWiseAnalysis.SimultaneousMethod" href="#LikelihoodBasedProfileWiseAnalysis.SimultaneousMethod"><code>LikelihoodBasedProfileWiseAnalysis.SimultaneousMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SimultaneousMethod(min_proportion_unique::Real=0.5, include_MLE_point::Bool=true)</code></pre><p>Method for finding the bivariate boundary of a confidence profile by finding internal and external boundary points using a uniform random distribution on provided bounds, pairing these points in the order they&#39;re found and bracketing between each pair (see <a href="../../../internal_library/bivariate/#LikelihoodBasedProfileWiseAnalysis.findNpointpairs_simultaneous!"><code>LikelihoodBasedProfileWiseAnalysis.findNpointpairs_simultaneous!</code></a> and <a href="../../../internal_library/bivariate/#LikelihoodBasedProfileWiseAnalysis.bivariate_confidenceprofile_vectorsearch"><code>LikelihoodBasedProfileWiseAnalysis.bivariate_confidenceprofile_vectorsearch</code></a>). Values of <code>min_proportion_unique</code> lower than zero may improve performance if finding either internal points or external points is difficult given the specified bounds on interest parameters.</p><p><strong>Arguments</strong></p><ul><li><code>min_proportion_unique</code>: a proportion ∈ (0.0, 1.0] for the minimum allowed proportion of unique points in one of the internal or external point vectors. One of these vectors will be fully unique. Whichever vector is not unique, will have at least <code>min_proportion_unique</code> unique points. Default is 0.5.</li><li><code>use_MLE_point</code>: whether to use the MLE point as the first internal point found or not. Default is true (use).</li></ul><p><strong>Details</strong></p><p>Recommended for use with the <a href="../profile_structs/#LikelihoodBasedProfileWiseAnalysis.LogLikelihood"><code>LogLikelihood</code></a> profile type. </p><p>When <code>min_proportion_unique = 1.0</code> the method uniformly samples the region specified by the bounds for the two interest parameters until as many internal and external boundary points as the desired number of boundary points are found. These points are paired in the order they are found. </p><p>If <code>min_proportion_unique &lt; 1.0</code> the method uniformly samples the region specified by the bounds for the two interest parameters until either the internal or external number of boundary points found is as many as the number of desired boundary points. For whichever vector is less than the number of desired boundary points, we keep searching for that kind of point until at least <code>ceil(min_proportion_unique * num_points)</code> points have been found. Once <code>ceil(min_proportion_unique * num_points)</code> points have been found these points are used to fill the remainder of the vector, in order found. Internal and external points in each vector are then paired in the order they are found.</p><p>A bracketing method is then used to find a boundary point between each point pair (the external point and the internal point).</p><p><a href="#LikelihoodBasedProfileWiseAnalysis.RadialRandomMethod"><code>RadialRandomMethod</code></a> and <a href="#LikelihoodBasedProfileWiseAnalysis.IterativeBoundaryMethod"><code>IterativeBoundaryMethod</code></a> are preferred over this method from a computational performance standpoint as they require fewer log-likelihood evalutions (when <a href="#LikelihoodBasedProfileWiseAnalysis.RadialRandomMethod"><code>RadialRandomMethod</code></a> has parameter <code>num_radial_directions</code> &gt; 1). </p><p><strong>Extended help</strong></p><p><strong>Boundary finding method</strong></p><p>Uses a 1D bracketing algorithm between a valid point pair to find the boundary at the desired confidence level.  </p><p>This method can find multiple boundaries (if they exist).</p><p><strong>Impact of parameter bounds</strong></p><p>If a parameter bound is in the way of reaching the boundary, points will not be put on that bound. Additionally, if the true boundary is very close to a parameter bound, the method will struggle to find this region of the boundary. This is because finding the boundary in this location requires generating a random point between the boundary and the parameter bound, which becomes more difficult the closer they are. </p><p>Interest parameter bounds that have ranges magnitudes larger than the range of the boundary will make finding internal points difficult, requiring a lot of computational effort. Similarly, the inverse will be true if external points are hard to find. Smaller values of <code>min_proportion_unique</code> will improve performance in these cases. </p><p>The method will fail if the interest parameter bounds are fully contained by the boundary.</p><p><strong>Threaded implementation</strong></p><p>This method is partially implemented with Threads parallelisation if <code>use_threads</code> is set to true when calling <a href="#LikelihoodBasedProfileWiseAnalysis.bivariate_confidenceprofiles!"><code>bivariate_confidenceprofiles!</code></a>. The finding point pairs step is not parallelised and the finding boundary from point pairs step is parallelised.</p><p><strong>Internal Points</strong></p><p>Finds at least <code>ceil(min_proportion_unique*num_points) - 1*use_MLE_point</code> internal points.</p><p><strong>Supertype Hiearachy</strong></p><p><code>SimultaneousMethod &lt;: AbstractBivariateVectorMethod &lt;: AbstractBivariateMethod &lt;: Any</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoelTrent/LikelihoodBasedProfileWiseAnalysis.jl/blob/55f4fe2d75537cb7c288254e10a9145f26adc74a/src/types/bivariate_methods.jl#L271-L320">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LikelihoodBasedProfileWiseAnalysis.Fix1AxisMethod" href="#LikelihoodBasedProfileWiseAnalysis.Fix1AxisMethod"><code>LikelihoodBasedProfileWiseAnalysis.Fix1AxisMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Fix1AxisMethod()</code></pre><p>Method for finding the bivariate boundary of a confidence profile by using uniform random distributions on provided bounds to draw a value for one interest parameter, fix it, and draw two values for the other interest parameter, using the pair to find a boundary point using a bracketing method if the pair are a valid bracket (see <a href="../../../internal_library/bivariate/#LikelihoodBasedProfileWiseAnalysis.findNpointpairs_fix1axis!"><code>LikelihoodBasedProfileWiseAnalysis.findNpointpairs_fix1axis!</code></a> and <a href="../../../internal_library/bivariate/#LikelihoodBasedProfileWiseAnalysis.bivariate_confidenceprofile_fix1axis"><code>LikelihoodBasedProfileWiseAnalysis.bivariate_confidenceprofile_fix1axis</code></a>).</p><p><strong>Details</strong></p><p>Recommended for use with the <a href="../profile_structs/#LikelihoodBasedProfileWiseAnalysis.LogLikelihood"><code>LogLikelihood</code></a> profile type. </p><p>The method finds the desired number of boundary points by fixing the first and second interest parameters for half of these points each. It first draws a value for the fixed parameter using a uniform random distribution on provided bounds (e.g. <code>ψ_x</code>). Then it draws two values for the unfixed parameter in the same fashion (e.g. <code>ψ_y1</code> and <code>ψ_y2</code>]). If one of these points (<code>[ψ_x, ψ_y1]</code> and <code>[ψ_x, ψ_y2]</code>) is an internal point and the other an external point, the point pair is accepted as they are a valid bracket. A bracketing method is then used to find a boundary point between the point pair (the internal and external point). The method continues searching for valid point pairs until the desired number of boundary points is found.</p><p><a href="#LikelihoodBasedProfileWiseAnalysis.RadialRandomMethod"><code>RadialRandomMethod</code></a> and <a href="#LikelihoodBasedProfileWiseAnalysis.IterativeBoundaryMethod"><code>IterativeBoundaryMethod</code></a> are preferred over this method from a computational performance standpoint as they require fewer log-likelihood evalutions (when <a href="#LikelihoodBasedProfileWiseAnalysis.RadialRandomMethod"><code>RadialRandomMethod</code></a> has parameter <code>num_radial_directions</code> &gt; 1). <a href="#LikelihoodBasedProfileWiseAnalysis.SimultaneousMethod"><code>SimultaneousMethod</code></a> will also likely be more efficient, even though it uses four random numbers vs three, as it doesn&#39;t unneccesarily throw away points.  </p><p><strong>Extended help</strong></p><p><strong>Boundary finding method</strong></p><p>Uses a 1D bracketing algorithm between a valid point pair, which are parallel to the x or y axis, to find the boundary at the desired confidence level.  </p><p>This method can find multiple boundaries (if they exist).</p><p><strong>Impact of parameter bounds</strong></p><p>If a parameter bound is in the way of reaching the boundary, points will not be put on that bound. Additionally, if the true boundary is very close to a parameter bound, the method will struggle to find this region of the boundary. This is because finding the boundary in this location requires generating a random point between the boundary and the parameter bound, which becomes more difficult the closer they are. Interest parameter bounds that have ranges magnitudes larger than the range of the boundary will make finding internal points very difficult, requiring a lot of computational effort. Similarly, the inverse will be true if external points are hard to find. The method will fail if the interest parameter bounds are fully contained by the boundary.</p><p><strong>Threaded implementation</strong></p><p>This method is implemented with Threads parallelisation if <code>use_threads</code> is set to true when calling <a href="#LikelihoodBasedProfileWiseAnalysis.bivariate_confidenceprofiles!"><code>bivariate_confidenceprofiles!</code></a>.</p><p><strong>Internal Points</strong></p><p>Finds <code>num_points</code> internal points.</p><p><strong>Supertype Hiearachy</strong></p><p><code>Fix1AxisMethod &lt;: AbstractBivariateMethod &lt;: Any</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoelTrent/LikelihoodBasedProfileWiseAnalysis.jl/blob/55f4fe2d75537cb7c288254e10a9145f26adc74a/src/types/bivariate_methods.jl#L330-L366">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LikelihoodBasedProfileWiseAnalysis.AnalyticalEllipseMethod" href="#LikelihoodBasedProfileWiseAnalysis.AnalyticalEllipseMethod"><code>LikelihoodBasedProfileWiseAnalysis.AnalyticalEllipseMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AnalyticalEllipseMethod(ellipse_start_point_shift::Float64, 
    ellipse_sqrt_distortion::Float64)</code></pre><p>Method for sampling the desired number of boundary points on a ellipse approximation of the log-likelihood function centred at the maximum likelihood estimate point using <a href="https://joeltrent.github.io/EllipseSampling.jl/stable">EllipseSampling.jl</a>.</p><p><strong>Arguments</strong></p><ul><li><code>ellipse_start_point_shift</code>: a number ∈ [0.0,1.0]. Default is <code>rand()</code> (defined on [0.0,1.0]), meaning that by default a different set of points will be found each time.</li><li><code>ellipse_sqrt_distortion</code>: a number ∈ [0.0,1.0]. Default is <code>1.0</code>, meaning that by default points on the ellipse approximation are equally spaced with respect to arc length. </li></ul><p><strong>Details</strong></p><p>Used for the <a href="../profile_structs/#LikelihoodBasedProfileWiseAnalysis.EllipseApproxAnalytical"><code>EllipseApproxAnalytical</code></a> profile type only: if this method is specified, then any user provided profile type will be overriden and replaced with <a href="../profile_structs/#LikelihoodBasedProfileWiseAnalysis.EllipseApproxAnalytical"><code>EllipseApproxAnalytical</code></a>. This ellipse approximation ignores user provided bounds.</p><p>For additional information on arguments see the keyword arguments for <a href="https://joeltrent.github.io/EllipseSampling.jl/stable/user_interface/#EllipseSampling.generate_N_clustered_points"><code>generate_N_clustered_points</code></a> in <a href="https://joeltrent.github.io/EllipseSampling.jl/stable">EllipseSampling.jl</a>.</p><p><strong>Extended help</strong></p><p><strong>Boundary finding method</strong></p><p>Explicitly finds the boundary using <a href="https://joeltrent.github.io/EllipseSampling.jl/stable">EllipseSampling.jl</a>.</p><p><strong>Internal Points</strong></p><p>Finds no internal points.</p><p><strong>Supertype Hiearachy</strong></p><p><code>AnalyticalEllipseMethod &lt;: AbstractBivariateMethod &lt;: Any</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoelTrent/LikelihoodBasedProfileWiseAnalysis.jl/blob/55f4fe2d75537cb7c288254e10a9145f26adc74a/src/types/bivariate_methods.jl#L369-L398">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LikelihoodBasedProfileWiseAnalysis.ContinuationMethod" href="#LikelihoodBasedProfileWiseAnalysis.ContinuationMethod"><code>LikelihoodBasedProfileWiseAnalysis.ContinuationMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ContinuationMethod(num_level_sets::Int, 
    ellipse_confidence_level::Float64, 
    ellipse_start_point_shift::Float64=rand(), 
    level_set_spacing::Symbol=:loglikelihood)</code></pre><p>Kept available for completeness but not recommended for use. A previous implementation of search directions from the MLE point was moved to [<code>RadialMLEMethod</code>].</p><p><strong>Arguments</strong></p><ul><li><code>num_level_sets</code>: the number of level sets used to get to the desired confidence level set.</li><li><code>ellipse_confidence_level</code>: a number ∈ (0.0, 1.0). the confidence level at which to construct the initial ellipse and find the initial level set boundary. Recommended to be around 0.1.</li><li><code>ellipse_start_point_shift</code>: a number ∈ [0.0,1.0]. Default is <code>rand()</code> (defined on [0.0,1.0]), meaning that by default a different set of points will be found each time.</li><li><code>ellipse_sqrt_distortion</code>: a number ∈ [0.0,1.0]. Default is <code>1.0</code>, meaning that by default points on the ellipse approximation are equally spaced with respect to arc length. </li><li><code>level_set_spacing</code>: a Symbol ∈ [:loglikelihood, :confidence]. Whether to space level sets uniformly in confidence level space or log-likelihood space, between the first level set found and the level set of desired confidence level. Default is :loglikelihood.</li></ul><p><strong>Details</strong></p><p>The method finds an initial boundary at a low confidence level close to the <code>ellipse_confidence_level</code> (see <a href="../../../internal_library/bivariate/#LikelihoodBasedProfileWiseAnalysis.initial_continuation_solution!"><code>initial_continuation_solution!</code></a>). Then it &#39;continues&#39; this initial boundary sequentially to <code>num_level_sets</code> higher confidence level boundaries until the desired confidence level is reached. If a user defined bound is in the way of a level set point reaching the next level set, that point is frozen on the bounds for all subsequent level sets. </p><p><strong>Extended help</strong></p><p>Presently this continuation is done by finding a point inside the boundary that is as close as possible to being a point that makes the boundary a <a href="https://en.wikipedia.org/wiki/Star_domain">star domain</a> and is close to the centre of the area of the boundary in the x and y axes. We refer to this point as a &#39;star point&#39;, or a point that can see all the points on the boundary, without being blocked by an edge. We use a heuristic to estimate this, sampling points within the boundary and using these to produce kmeans points, of which one is hopefully a star point and at the centre of the boundary. </p><p>If we find a star point we then, for every point on the current boundary, push out in the direction defined by the line segment connecting the star point and the boundary to find the next confidence level boundary. If we do not find a star point, we assign each of the boundary points to the Kmeans point they are closest to (using a Euclidean distance metric), and use the direction defined by the line segments between a boundary point and it&#39;s associated Kmeans point to find the next confidence level boundary. This direction heuristic is carried out by <a href="../../../internal_library/bivariate/#LikelihoodBasedProfileWiseAnalysis.refine_search_directions!"><code>refine_search_directions!</code></a>. </p><p>A traveling salesman heuristic is used to reorder the boundary points into a new minimum perimeter polygon, <a href="../../../internal_library/bivariate/#LikelihoodBasedProfileWiseAnalysis.minimum_perimeter_polygon!"><code>LikelihoodBasedProfileWiseAnalysis.minimum_perimeter_polygon!</code></a>, if the continuation of one boundary to the next causes the mapping of adjacent vertices to change (expected if a star point is not found). </p><p>For additional information on the <code>ellipse_start_point_shift</code> and <code>ellipse_sqrt_distortion</code> arguments see the keyword arguments for <a href="https://joeltrent.github.io/EllipseSampling.jl/stable/user_interface/#EllipseSampling.generate_N_clustered_points"><code>generate_N_clustered_points</code></a> in <a href="https://joeltrent.github.io/EllipseSampling.jl/stable">EllipseSampling.jl</a>.</p><p><strong>Boundary finding method</strong></p><p>Uses a derivative-free 1D line search algorithm to find the boundary at subsequent confidence levels. If the derivative-free approach fails, it switches to a bracketing algorithm between a given boundary point and the point on the user-provided bounds in the search direction.</p><p>This method is unlikely to find boundaries that do not contain the MLE point (if they exist).</p><p><strong>Threaded implementation</strong></p><p>This method is not implemented with Threads parallelisation.</p><p><strong>Internal Points</strong></p><p>Finds <code>num_points * num_level_sets</code> internal points at distinct level sets.</p><p><strong>Supertype Hiearachy</strong></p><p><code>ContinuationMethod &lt;: AbstractBivariateMethod &lt;: Any</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoelTrent/LikelihoodBasedProfileWiseAnalysis.jl/blob/55f4fe2d75537cb7c288254e10a9145f26adc74a/src/types/bivariate_methods.jl#L409-L455">source</a></section></article><h2 id="Sampling-Internal-Points-From-Boundaries"><a class="docs-heading-anchor" href="#Sampling-Internal-Points-From-Boundaries">Sampling Internal Points From Boundaries</a><a id="Sampling-Internal-Points-From-Boundaries-1"></a><a class="docs-heading-anchor-permalink" href="#Sampling-Internal-Points-From-Boundaries" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LikelihoodBasedProfileWiseAnalysis.sample_bivariate_internal_points!" href="#LikelihoodBasedProfileWiseAnalysis.sample_bivariate_internal_points!"><code>LikelihoodBasedProfileWiseAnalysis.sample_bivariate_internal_points!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sample_bivariate_internal_points!(model::LikelihoodModel,
    num_points::Int;
    &lt;keyword arguments&gt;)</code></pre><p>Samples <code>num_points</code> internal points in interest parameter space of existing bivariate profiles that meet the requirements of the bivariate method of <a href="../../../internal_library/common/#LikelihoodBasedProfileWiseAnalysis.desired_df_subset"><code>LikelihoodBasedProfileWiseAnalysis.desired_df_subset</code></a> (see Keyword Arguments). Modifies <code>model</code> in place, with sampled internal points appended to the internal points field of each <a href="../profile_structs/#LikelihoodBasedProfileWiseAnalysis.BivariateConfidenceStruct"><code>BivariateConfidenceStruct</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: a <a href="../../initialisation/#LikelihoodBasedProfileWiseAnalysis.LikelihoodModel"><code>LikelihoodModel</code></a> containing model information, saved profiles and predictions.</li><li><code>num_points</code>: number of internal points to sample from within a polygon hull approximation of a bivariate boundary and append to it&#39;s array of internal points.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>confidence_levels</code>: a vector of confidence levels. If empty, all confidence levels of bivariate profiles will be considered for finding interval points. Otherwise, only confidence levels in <code>confidence_levels</code> will be considered. Default is <code>Float64[]</code> (any confidence level).</li><li><code>dofs</code>: a vector of integer degrees of freedom. If empty, all degrees of freedom of bivariate profiles will be considered. Otherwise, only degrees of freedom in <code>dofs</code> are allowed. Default is <code>Int[]</code> (any degree of freedom).</li><li><code>profile_types</code>: a vector of <a href="../profile_structs/#LikelihoodBasedProfileWiseAnalysis.AbstractProfileType"><code>AbstractProfileType</code></a> structs. If empty, all profile types of bivariate profiles are considered. Otherwise, only profiles with matching profile types will be considered. Default is <code>AbstractProfileType[]</code> (any profile type).</li><li><code>methods</code>: a vector of <a href="#LikelihoodBasedProfileWiseAnalysis.AbstractBivariateMethod"><code>AbstractBivariateMethod</code></a> structs. If empty all methods used to find bivariate profiles are considered. Otherwise, only profiles with matching method types will be considered (struct arguments do not need to be the same). Default is <code>AbstractBivariateMethod[]</code> (any bivariate method).</li><li><code>sample_type</code>: either a <a href="../dimensional/#LikelihoodBasedProfileWiseAnalysis.UniformRandomSamples"><code>UniformRandomSamples</code></a> or <a href="../dimensional/#LikelihoodBasedProfileWiseAnalysis.LatinHypercubeSamples"><code>LatinHypercubeSamples</code></a> struct for how to sample internal points from the polygon hull. <a href="../dimensional/#LikelihoodBasedProfileWiseAnalysis.UniformRandomSamples"><code>UniformRandomSamples</code></a> are homogeneously sampled from the polygon and <a href="../dimensional/#LikelihoodBasedProfileWiseAnalysis.LatinHypercubeSamples"><code>LatinHypercubeSamples</code></a> use the intersection of a heuristically optimised Latin Hypercube sampling plan with the polygon. Default is <code>LatinHypercubeSamples()</code> (<a href="../dimensional/#LikelihoodBasedProfileWiseAnalysis.LatinHypercubeSamples"><code>LatinHypercubeSamples</code></a>).</li><li><code>hullmethod</code>: method of type <a href="#LikelihoodBasedProfileWiseAnalysis.AbstractBivariateHullMethod"><code>AbstractBivariateHullMethod</code></a> used to create a 2D polygon hull that approximates the bivariate boundary from a set of boundary points and internal points (method dependent). For available methods see <a href="#LikelihoodBasedProfileWiseAnalysis.bivariate_hull_methods"><code>bivariate_hull_methods()</code></a>. Default is <code>MPPHullMethod()</code> (<a href="#LikelihoodBasedProfileWiseAnalysis.MPPHullMethod"><code>MPPHullMethod</code></a>).</li><li><code>θlb_nuisance</code>: a vector of lower bounds on nuisance parameters, require <code>θlb_nuisance .≤ model.core.θmle</code>. Default is <code>model.core.θlb</code>. </li><li><code>θub_nuisance</code>: a vector of upper bounds on nuisance parameters, require <code>θub_nuisance .≥ model.core.θmle</code>. Default is <code>model.core.θub</code>.</li><li><code>t</code>: vector of timepoints to evaluate predictions at for each new sampled internal point from a bivariate boundary that has already had predictions evaluated. The vector must be the same vector used to produce these previous predictions, otherwise points will not be sampled from this boundary. Default is <code>missing</code>.</li><li><code>evaluate_predictions_for_samples</code>: boolean variable specifying whether to evaluate predictions for sampled points given predictions have been evaluated for the boundary they were sampled from. If <code>false</code>, then existing predictions will be forgotten by the <code>model</code> and overwritten the next time predictions are evaluated for each profile internal points were sampled from. Default is <code>true</code>.</li><li><code>proportion_of_predictions_to_keep</code>: The proportion of predictions from <code>num_points</code> internal points to save. Does not impact the extrema calculated from predictions. Default is <code>1.0</code>.</li><li><code>optimizationsettings</code>: a <a href="../../initialisation/#LikelihoodBasedProfileWiseAnalysis.OptimizationSettings"><code>OptimizationSettings</code></a> struct containing the optimisation settings used to find optimal values of nuisance parameters for a given pair of interest parameter values. Default is <code>missing</code> (will use <code>model.core.optimizationsettings</code>).</li><li><code>show_progress</code>: boolean variable specifying whether to display progress bars on the percentage of <code>θs_to_profile</code> completed and estimated time of completion. Default is <code>model.show_progress</code>.</li><li><code>use_distributed</code>: boolean variable specifying whether to use a normal for loop or a <code>@distributed</code> for loop across combinations of interest parameters. Set this variable to <code>false</code> if <a href="https://docs.julialang.org/en/v1/stdlib/Distributed/">Distributed.jl</a> is not being used. Default is <code>true</code>.</li><li><code>use_threads</code>: boolean variable specifying, if <code>use_distributed</code> is <code>false</code>, to use a parallelised for loop across <code>Threads.nthreads()</code> threads to evaluate the log-likelihood at each sampled point. Default is <code>true</code>.</li></ul><p><strong>Details</strong></p><p>For each bivariate profile that meets the requirements of <a href="../../../internal_library/common/#LikelihoodBasedProfileWiseAnalysis.desired_df_subset"><code>LikelihoodBasedProfileWiseAnalysis.desired_df_subset</code></a> it creates a 2D polygon hull from it&#39;s set of boundary and internal points (method dependent) using <code>hullmethod</code> and samples points from the hull using <code>sample_type</code> until <code>num_points</code> are found, rejecting any that are not inside the log-likelihood threshold at that <code>confidence_level</code>, <code>dof</code> and <code>profile_type</code>. For <a href="../dimensional/#LikelihoodBasedProfileWiseAnalysis.LatinHypercubeSamples"><code>LatinHypercubeSamples</code></a> this will be approximately <code>num_points</code>, whereas for <a href="../dimensional/#LikelihoodBasedProfileWiseAnalysis.UniformRandomSamples"><code>UniformRandomSamples</code></a> this will be exactly <code>num_points</code>. Nuisance parameters of each point in bivariate interest parameter space are found by maximising the log-likelihood function given by the <code>profile_type</code> of the profile.</p><p>It is highly recommended to view the docstrings of each <code>hullmethod</code> as the rejection rate of sampled points and the representation accuracy / coverage of the true confidence boundary varies between them, which can impact both computational performance and sampling coverage. For example, given the same set of boundary and internal points, <a href="#LikelihoodBasedProfileWiseAnalysis.ConvexHullMethod"><code>ConvexHullMethod</code></a> will produce a polygon hull that contains at least as much of the true confidence boundary as the other methods, but may have a higher rejection rate than other methods leading to higher computational cost.</p><p><strong>Parallel Computing Implementation</strong></p><p>If <a href="https://docs.julialang.org/en/v1/stdlib/Distributed/">Distributed.jl</a> is being used and <code>use_distributed</code> is <code>true</code> then the internal samples of distinct interest parameter combinations will be computed in parallel across <code>Distributed.nworkers()</code> workers. If <code>use_distributed</code> is <code>false</code> and <code>use_threads</code> is <code>true</code> then the internal samples of each distinct interest parameter combination will be computed in parallel across <code>Threads.nthreads()</code> threads. It is highly recommended to set <code>use_threads</code> to <code>true</code> in that situation.</p><p><strong>Iteration Speed Of the Progress Meter</strong></p><p>An iteration within the progress meter is specified as the time it takes for all internal points within a bivariate boundary to be found.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoelTrent/LikelihoodBasedProfileWiseAnalysis.jl/blob/55f4fe2d75537cb7c288254e10a9145f26adc74a/src/bivariate_methods/sample_internal_points.jl#L328-L369">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LikelihoodBasedProfileWiseAnalysis.bivariate_hull_methods" href="#LikelihoodBasedProfileWiseAnalysis.bivariate_hull_methods"><code>LikelihoodBasedProfileWiseAnalysis.bivariate_hull_methods</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bivariate_hull_methods()</code></pre><p>Prints a list of available bivariate hull methods. Available bivariate hull methods include <a href="#LikelihoodBasedProfileWiseAnalysis.ConvexHullMethod"><code>ConvexHullMethod</code></a>, <a href="#LikelihoodBasedProfileWiseAnalysis.ConcaveHullMethod"><code>ConcaveHullMethod</code></a> and <a href="#LikelihoodBasedProfileWiseAnalysis.MPPHullMethod"><code>MPPHullMethod</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoelTrent/LikelihoodBasedProfileWiseAnalysis.jl/blob/55f4fe2d75537cb7c288254e10a9145f26adc74a/src/types/bivariate_hull_methods.jl#L83-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LikelihoodBasedProfileWiseAnalysis.AbstractBivariateHullMethod" href="#LikelihoodBasedProfileWiseAnalysis.AbstractBivariateHullMethod"><code>LikelihoodBasedProfileWiseAnalysis.AbstractBivariateHullMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractBivariateMethod</code></pre><p>Supertype for bivariate boundary hull methods. Use <code>bivariate_hull_methods()</code> for a list of available methods (see <a href="#LikelihoodBasedProfileWiseAnalysis.bivariate_hull_methods"><code>bivariate_hull_methods</code></a>).</p><p><strong>Subtypes</strong></p><p><a href="#LikelihoodBasedProfileWiseAnalysis.ConvexHullMethod"><code>ConvexHullMethod</code></a></p><p><a href="#LikelihoodBasedProfileWiseAnalysis.ConcaveHullMethod"><code>ConcaveHullMethod</code></a></p><p><a href="#LikelihoodBasedProfileWiseAnalysis.MPPHullMethod"><code>MPPHullMethod</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoelTrent/LikelihoodBasedProfileWiseAnalysis.jl/blob/55f4fe2d75537cb7c288254e10a9145f26adc74a/src/types/bivariate_hull_methods.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LikelihoodBasedProfileWiseAnalysis.ConvexHullMethod" href="#LikelihoodBasedProfileWiseAnalysis.ConvexHullMethod"><code>LikelihoodBasedProfileWiseAnalysis.ConvexHullMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConvexHullMethod()</code></pre><p>Constructs a 2D polygon hull to sample internal points from by applying a convex hull algorithm from <a href="https://docs.juliahub.com/Meshes/FuRcu/0.18.2/algorithms/hulls.html#Meshes.GrahamScan">Meshes.jl</a> on the collection of points given by both the boundary and saved internal points. </p><p><strong>Details</strong></p><p><strong>Representation Accuracy</strong></p><p>For convex boundaries, this method has the ability to create a more accurate representation of the true confidence boundary than <a href="#LikelihoodBasedProfileWiseAnalysis.MPPHullMethod"><code>MPPHullMethod</code></a>, if saved internal points contain information about the boundary that is not covered by a convex hull of boundary points alone. For concave boundaries, this method will not be an accurate representation of the true confidence boundary. However, this may be desirable if the rejection rate when sampling is not too high, because the convex nature of the hull will likely contain more of the true confidence boundary than each of the other methods, particularly for lower numbers of boundary points. </p><p><strong>Rejection Rate when Sampling Internal Points</strong></p><p>The rejection rate when sampling internal points will be low for convex boundaries. The rejection rate may become very high for concave boundaries, if the area of the convex hull of the true confidence boundary is much larger than the area of the true confidence boundary. </p><p><strong>Supertype Hiearachy</strong></p><p><code>ConvexHullMethod &lt;: AbstractBivariateHullMethod &lt;: Any</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoelTrent/LikelihoodBasedProfileWiseAnalysis.jl/blob/55f4fe2d75537cb7c288254e10a9145f26adc74a/src/types/bivariate_hull_methods.jl#L16-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LikelihoodBasedProfileWiseAnalysis.ConcaveHullMethod" href="#LikelihoodBasedProfileWiseAnalysis.ConcaveHullMethod"><code>LikelihoodBasedProfileWiseAnalysis.ConcaveHullMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConcaveHullMethod()</code></pre><p>Constructs a 2D polygon hull to sample internal points from by applying a heuristic implementation of a heuristic concave hull algorithm from <a href="https://github.com/lstagner/ConcaveHull.jl">ConcaveHull.jl</a> on the collection of points given by both the boundary and saved internal points (see <a href="../../../internal_library/bivariate/#LikelihoodBasedProfileWiseAnalysis.bivariate_concave_hull"><code>LikelihoodBasedProfileWiseAnalysis.bivariate_concave_hull</code></a>). </p><p><strong>Details</strong></p><p>It applies the <code>ConcaveHull.concave_hull</code> algorithm twice to the union of boundary and saved internal points, with the number of neighbours for the first pass chosen using a heuristic based on the number of points in the point union. Resultantly, it may result in more accurate coverage of the true confidence boundary than <a href="#LikelihoodBasedProfileWiseAnalysis.MPPHullMethod"><code>MPPHullMethod</code></a>, for smaller numbers of boundary points, if saved internal points are in locations not enclosed by a polygon found using only boundary points. For example, if the true confidence boundary is a square and there is an internal point in the bottom left corner, but no boundary points around that corner, the boundary polygon created by this method will likely have a vertex at that internal point. However, this is not guaranteed because it is a heuristic. Bivariate methods that struggle to find boundaries close to or on the other side of a parameter bound are an example where using information on saved internal points will prove useful.</p><p><strong>Representation Accuracy</strong></p><p>This method has the ability to create a more accurate representation of the boundary than <a href="#LikelihoodBasedProfileWiseAnalysis.MPPHullMethod"><code>MPPHullMethod</code></a>, but because of it&#39;s heuristic nature this is not guaranteed. However, it should be a more accurate representation of the boundary than <a href="#LikelihoodBasedProfileWiseAnalysis.ConvexHullMethod"><code>ConvexHullMethod</code></a> for non-convex boundaries (concave boundaries). The representation in the worst case where the heuristic does not return a good representation of the boundary despite a good initial point cloud, will be signficantly worse than the <a href="#LikelihoodBasedProfileWiseAnalysis.ConvexHullMethod"><code>ConvexHullMethod</code></a> and likely worse than the <a href="#LikelihoodBasedProfileWiseAnalysis.MPPHullMethod"><code>MPPHullMethod</code></a>.</p><p><strong>Rejection Rate when Sampling Internal Points</strong></p><p>The rejection rate when sampling internal points will be low for convex boundaries. The rejection rate should be low for concave boundaries as well, but the nature of the heuristic used may cause concave sections to be treated as convex.   </p><p><strong>Supertype Hiearachy</strong></p><p><code>ConcaveHullMethod &lt;: AbstractBivariateHullMethod &lt;: Any</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoelTrent/LikelihoodBasedProfileWiseAnalysis.jl/blob/55f4fe2d75537cb7c288254e10a9145f26adc74a/src/types/bivariate_hull_methods.jl#L37-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LikelihoodBasedProfileWiseAnalysis.MPPHullMethod" href="#LikelihoodBasedProfileWiseAnalysis.MPPHullMethod"><code>LikelihoodBasedProfileWiseAnalysis.MPPHullMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MPPHullMethod()</code></pre><p>Constructs a 2D polygon hull to sample internal points from by applying a minimum perimeter polygon (MPP) traveling salesman problem algorithm to the boundary points (see <a href="../../../internal_library/bivariate/#LikelihoodBasedProfileWiseAnalysis.minimum_perimeter_polygon!"><code>LikelihoodBasedProfileWiseAnalysis.minimum_perimeter_polygon!</code></a>). </p><p><strong>Details</strong></p><p>It does not use information on the position of internal points saved while finding a boundary. This may result in less accurate coverage of the true confidence boundary for smaller numbers of boundary points. For example, if the true confidence boundary is a square and there is an internal point in the bottom left corner, but no boundary points around that corner, the boundary polygon created by this method will not enclose the area around that corner. Bivariate methods that struggle to find boundaries close to or on the other side of a parameter bound are an example where using information on saved internal points would prove useful - <a href="#LikelihoodBasedProfileWiseAnalysis.ConvexHullMethod"><code>ConvexHullMethod</code></a> or <a href="#LikelihoodBasedProfileWiseAnalysis.ConcaveHullMethod"><code>ConcaveHullMethod</code></a> may be more appropriate in these cases.</p><p><strong>Representation Accuracy</strong></p><p>This method will create the most accurate representation of the boundary that has been found from any of the <a href="#LikelihoodBasedProfileWiseAnalysis.AbstractBivariateHullMethod"><code>AbstractBivariateHullMethod</code></a> methods, particularly for non-convex boundaries, given a sufficient number of boundary points.</p><p><strong>Rejection Rate when Sampling Internal Points</strong></p><p>The rejection rate when sampling internal points will be low for convex and concave boundaries. </p><p><strong>Supertype Hiearachy</strong></p><p><code>MPPHullMethod &lt;: AbstractBivariateHullMethod &lt;: Any</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoelTrent/LikelihoodBasedProfileWiseAnalysis.jl/blob/55f4fe2d75537cb7c288254e10a9145f26adc74a/src/types/bivariate_hull_methods.jl#L60-L80">source</a></section></article><h2 id="Merging-Boundaries-From-Multiple-Methods"><a class="docs-heading-anchor" href="#Merging-Boundaries-From-Multiple-Methods">Merging Boundaries From Multiple Methods</a><a id="Merging-Boundaries-From-Multiple-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Merging-Boundaries-From-Multiple-Methods" title="Permalink"></a></h2><p>To improve the performance of internal point sampling, it may be worth finding bivariate boundaries using a combination of methods, where one method has more guaranteed boundary coverage and the other gives a more random search of interest parameter space, such as combining <a href="#LikelihoodBasedProfileWiseAnalysis.IterativeBoundaryMethod"><code>IterativeBoundaryMethod</code></a> with <a href="#LikelihoodBasedProfileWiseAnalysis.SimultaneousMethod"><code>SimultaneousMethod</code></a> into a <a href="#LikelihoodBasedProfileWiseAnalysis.CombinedBivariateMethod"><code>CombinedBivariateMethod</code></a>. </p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LikelihoodBasedProfileWiseAnalysis.CombinedBivariateMethod" href="#LikelihoodBasedProfileWiseAnalysis.CombinedBivariateMethod"><code>LikelihoodBasedProfileWiseAnalysis.CombinedBivariateMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CombinedBivariateMethod()</code></pre><p>A method representing a <a href="../profile_structs/#LikelihoodBasedProfileWiseAnalysis.BivariateConfidenceStruct"><code>BivariateConfidenceStruct</code></a> that has been destructively merged from one or more boundaries found with a <a href="#LikelihoodBasedProfileWiseAnalysis.AbstractBivariateMethod"><code>AbstractBivariateMethod</code></a>. Does not represent a method usable by <a href="#LikelihoodBasedProfileWiseAnalysis.bivariate_confidenceprofiles!"><code>bivariate_confidenceprofiles!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoelTrent/LikelihoodBasedProfileWiseAnalysis.jl/blob/55f4fe2d75537cb7c288254e10a9145f26adc74a/src/types/bivariate_methods.jl#L43-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LikelihoodBasedProfileWiseAnalysis.combine_bivariate_boundaries!" href="#LikelihoodBasedProfileWiseAnalysis.combine_bivariate_boundaries!"><code>LikelihoodBasedProfileWiseAnalysis.combine_bivariate_boundaries!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">combine_bivariate_boundaries!(model::LikelihoodModel;
    &lt;keyword arguments&gt;)</code></pre><p>Combines the <code>confidence_level</code> bivariate boundaries at <code>dof</code> of <code>profile_type</code> found using <code>methods</code> into a single <a href="#LikelihoodBasedProfileWiseAnalysis.CombinedBivariateMethod"><code>CombinedBivariateMethod</code></a> boundary for each set of interest parameters, modifying <code>model</code> destructively in place. Rows of <code>model.biv_profiles_df</code> to combine are found using the bivariate method of <a href="../../../internal_library/common/#LikelihoodBasedProfileWiseAnalysis.desired_df_subset"><code>LikelihoodBasedProfileWiseAnalysis.desired_df_subset</code></a>. Dictionary entries and dataframe rows of boundaries that have beeen combined will be deleted and the datastructures will be rebuilt according to the new row indices of <code>model.biv_profiles_df</code>. </p><p><strong>Arguments</strong></p><ul><li><code>model</code>: a <a href="../../initialisation/#LikelihoodBasedProfileWiseAnalysis.LikelihoodModel"><code>LikelihoodModel</code></a> containing model information, saved profiles and predictions.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>confidence_level</code>: a number ∈ (0.0, 1.0) for the confidence level of <code>profile_type</code> boundaries to combine. Default is 0.95 (95%).</li><li><code>dof</code>: a integer ∈ [2, model.core.num<em>pars] for the degrees of freedom of `profile</em>type` boundaries to combine. Default is 2.</li><li><code>profile_type</code>: the profile type of boundaries to combine. Default is <code>LogLikelihood()</code> (<a href="../profile_structs/#LikelihoodBasedProfileWiseAnalysis.LogLikelihood"><code>LogLikelihood</code></a>).</li><li><code>methods</code>: a vector of methods of type <a href="#LikelihoodBasedProfileWiseAnalysis.AbstractBivariateMethod"><code>AbstractBivariateMethod</code></a> for combining boundaries found using those method types. <code>methods</code> should not contain <a href="#LikelihoodBasedProfileWiseAnalysis.CombinedBivariateMethod"><code>CombinedBivariateMethod</code></a>, but the case where it is included in <code>methods</code> is handled: it will be removed from the vector. Default is <code>AbstractBivariateMethod[]</code> (boundaries found using all methods are combined).</li><li><code>not_evaluated_predictions</code>: a boolean specifiying whether to combine only boundaries that have not had or have had predictions evaluated. If predictions are evaluated for the combined struct (if it exists) but not for the rows to combine with it, they will not be combined, and vice versa. Default is <code>true</code> (combine boundaries that have not had predictions evaluated).</li></ul><div class="admonition is-info"><header class="admonition-header">Combining predictions</header><div class="admonition-body"><p>If predictions have been evaluated: the time points at which predictions have been evaluated at must be the same for all of the boundaires that are being combined.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoelTrent/LikelihoodBasedProfileWiseAnalysis.jl/blob/55f4fe2d75537cb7c288254e10a9145f26adc74a/src/bivariate_methods/combine_bivariate_boundaries.jl#L51-L69">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../univariate/">« Univariate Profiles</a><a class="docs-footer-nextpage" href="../dimensional/">Dimensional Samples »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Wednesday 7 February 2024 04:22">Wednesday 7 February 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
