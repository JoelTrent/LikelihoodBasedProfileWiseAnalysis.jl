<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Bivariate Profiles · PlaceholderLikelihood.jl</title><script data-outdated-warner src="../../../assets/warner.js"></script><link rel="canonical" href="https://JoelTrent.github.io/PlaceholderLikelihood.jl/user_interface/profiles_and_samples/bivariate/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">PlaceholderLikelihood.jl</a></span></div><form class="docs-search" action="../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><a class="tocitem" href="../../../quick_start/">Quick Start</a></li><li><span class="tocitem">User Interface</span><ul><li><a class="tocitem" href="../../initialisation/">Initialisation</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox" checked/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Parameter Profiles and Samples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../profile_structs/">Structs and Profile Types</a></li><li><a class="tocitem" href="../univariate/">Univariate Profiles</a></li><li class="is-active"><a class="tocitem" href>Bivariate Profiles</a><ul class="internal"><li><a class="tocitem" href="#Sampling-Internal-Points"><span>Sampling Internal Points</span></a></li><li><a class="tocitem" href="#Methods"><span>Methods</span></a></li></ul></li><li><a class="tocitem" href="../dimensional/">Dimensional Samples</a></li></ul></li><li><a class="tocitem" href="../../predictions/">Predictions</a></li><li><a class="tocitem" href="../../plots/">Plots</a></li><li><input class="collapse-toggle" id="menuitem-3-5" type="checkbox"/><label class="tocitem" for="menuitem-3-5"><span class="docs-label">Simulated Coverage Checks</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../coverage/univariate_intervals/">Parameter Confidence Intervals</a></li></ul></li></ul></li><li><span class="tocitem">Internal Library</span><ul><li><a class="tocitem" href="../../../internal_library/common/">Common Functions</a></li><li><a class="tocitem" href="../../../internal_library/initialisation/">Initialisation</a></li><li><a class="tocitem" href="../../../internal_library/ellipse_likelihood/">Ellipse Functions</a></li><li><a class="tocitem" href="../../../internal_library/univariate/">Univariate Functions</a></li><li><a class="tocitem" href="../../../internal_library/bivariate/">Bivariate Functions</a></li><li><a class="tocitem" href="../../../internal_library/dimensional/">Dimensional Functions</a></li><li><a class="tocitem" href="../../../internal_library/predictions/">Prediction Functions</a></li><li><a class="tocitem" href="../../../internal_library/plots/">Plotting Functions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Interface</a></li><li><a class="is-disabled">Parameter Profiles and Samples</a></li><li class="is-active"><a href>Bivariate Profiles</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Bivariate Profiles</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JoelTrent/PlaceholderLikelihood.jl/blob/main/docs/src/user_interface/profiles_and_samples/bivariate.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Bivariate-Profiles"><a class="docs-heading-anchor" href="#Bivariate-Profiles">Bivariate Profiles</a><a id="Bivariate-Profiles-1"></a><a class="docs-heading-anchor-permalink" href="#Bivariate-Profiles" title="Permalink"></a></h1><ul><li><a href="#PlaceholderLikelihood.AbstractBivariateMethod"><code>PlaceholderLikelihood.AbstractBivariateMethod</code></a></li><li><a href="#PlaceholderLikelihood.AbstractBivariateVectorMethod"><code>PlaceholderLikelihood.AbstractBivariateVectorMethod</code></a></li><li><a href="#PlaceholderLikelihood.AnalyticalEllipseMethod"><code>PlaceholderLikelihood.AnalyticalEllipseMethod</code></a></li><li><a href="#PlaceholderLikelihood.ContinuationMethod"><code>PlaceholderLikelihood.ContinuationMethod</code></a></li><li><a href="#PlaceholderLikelihood.Fix1AxisMethod"><code>PlaceholderLikelihood.Fix1AxisMethod</code></a></li><li><a href="#PlaceholderLikelihood.IterativeBoundaryMethod"><code>PlaceholderLikelihood.IterativeBoundaryMethod</code></a></li><li><a href="#PlaceholderLikelihood.RadialMLEMethod"><code>PlaceholderLikelihood.RadialMLEMethod</code></a></li><li><a href="#PlaceholderLikelihood.RadialRandomMethod"><code>PlaceholderLikelihood.RadialRandomMethod</code></a></li><li><a href="#PlaceholderLikelihood.SimultaneousMethod"><code>PlaceholderLikelihood.SimultaneousMethod</code></a></li><li><a href="#PlaceholderLikelihood.bivariate_confidenceprofiles!"><code>PlaceholderLikelihood.bivariate_confidenceprofiles!</code></a></li><li><a href="#PlaceholderLikelihood.bivariate_methods"><code>PlaceholderLikelihood.bivariate_methods</code></a></li><li><a href="#PlaceholderLikelihood.sample_bivariate_internal_points!"><code>PlaceholderLikelihood.sample_bivariate_internal_points!</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="PlaceholderLikelihood.bivariate_confidenceprofiles!" href="#PlaceholderLikelihood.bivariate_confidenceprofiles!"><code>PlaceholderLikelihood.bivariate_confidenceprofiles!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bivariate_confidenceprofiles!(model::LikelihoodModel, 
    θcombinations::Vector{Vector{Int}}, 
    num_points::Int; 
    &lt;keyword arguments&gt;)</code></pre><p>Finds <code>num_points</code> <code>profile_type</code> boundary points at a specified <code>confidence_level</code> for each combination of two interest parameters using a specified <code>method</code>, optionally saving any found internal points. Saves these profiles by modifying <code>model</code> in place.</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: a <a href="../../initialisation/#PlaceholderLikelihood.LikelihoodModel"><code>LikelihoodModel</code></a> containing model information, saved profiles and predictions.</li><li><code>θcombinations</code>: vector of pairs of parameters to profile, as a vector of vectors of model parameter indexes.</li><li><code>num_points</code>: number of points to find on the boundary at the specified confidence level. Depending on the method, if a region of the user-provided bounds is inside the boundary some of these points will be on the bounds and inside the boundary. </li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>confidence_level</code>: a number ∈ (0.0, 1.0) for the confidence level on which to find the <code>profile_type</code> boundary. Default is 0.95 (95%).</li><li><code>profile_type</code>: whether to use the true log-likelihood function or an ellipse approximation of the log-likelihood function centred at the MLE (with optional use of parameter bounds). Available profile types are <a href="../profile_structs/#PlaceholderLikelihood.LogLikelihood"><code>LogLikelihood</code></a>, <a href="../profile_structs/#PlaceholderLikelihood.EllipseApprox"><code>EllipseApprox</code></a> and <a href="../profile_structs/#PlaceholderLikelihood.EllipseApproxAnalytical"><code>EllipseApproxAnalytical</code></a>. Default is <code>LogLikelihood()</code> (<a href="../profile_structs/#PlaceholderLikelihood.LogLikelihood"><code>LogLikelihood</code></a>).</li><li><code>method</code>: a method of type <a href="#PlaceholderLikelihood.AbstractBivariateMethod"><code>AbstractBivariateMethod</code></a>. For a list of available methods use <code>bivariate_methods()</code> (<a href="#PlaceholderLikelihood.bivariate_methods"><code>bivariate_methods</code></a>). Default is <code>RadialRandomMethod(3)</code> (<a href="#PlaceholderLikelihood.RadialRandomMethod"><code>RadialRandomMethod</code></a>).</li><li><code>θcombinations_is_unique</code>: boolean variable specifying whether all parameter combinations in <code>θcombinations</code> are ordered by parameter index (ascending) and are unique. Default is <code>false</code>.</li><li><code>save_internal_points</code>: boolean variable specifying whether to save points found inside the boundary during boundary computation. Internal points can be plotted in bivariate profile plots and will be used to generate predictions from a given bivariate profile. Default is <code>true</code>.</li><li><code>existing_profiles</code>: <code>Symbol ∈ [:ignore, :merge, :overwrite]</code> specifying what to do if profiles already exist for a given <code>θcombination</code>, <code>confidence_level</code>, <code>profile_type</code> and <code>method</code>. See below for each symbol&#39;s meanings. Default is <code>:merge</code>.</li><li><code>show_progress</code>: boolean variable specifying whether to display progress bars on the percentage of <code>θcombinations</code> completed and estimated time of completion. Default is <code>model.show_progress</code>.</li><li><code>use_distributed</code>: boolean variable specifying whether to use a normal for loop or a <code>@distributed</code> for loop across combinations of interest parameters. The variable makes no difference if Distributed.jl is not being used - it&#39;s intended for use when simulating parameter confidence boundary coverage (see <a href="user_interface/profiles_and_samples/@ref"><code>check_bivariate_parameter_coverage</code></a>). </li></ul><div class="admonition is-info"><header class="admonition-header">existing_profiles meanings</header><div class="admonition-body"><ul><li>:ignore means profiles that already exist will not be recomputed even if they contain fewer <code>num_points</code> boundary points. </li><li>:merge means profiles that already exist will be merged with profiles from the current algorithm run to reach <code>num_points</code>. If the existing profile already has at least <code>num_points</code> boundary points then that profile will not be recomputed. Otherwise, the specified method will be run starting from the difference between <code>num_points</code> and the number of points in the existing profile. The result of that method run will be merged with the existing profile.  </li><li>:overwrite means profiles that already exist will be overwritten, regardless of how many points they contain.</li></ul></div></div><p><strong>Details</strong></p><p>Using <a href="../../../internal_library/bivariate/#PlaceholderLikelihood.bivariate_confidenceprofile"><code>bivariate_confidenceprofile</code></a> this function calls the algorithm/method specified by <code>method</code> for each parameter combination in <code>θcombinations</code> (depending on the setting for <code>existing_profiles</code> and <code>num_points</code> if these profiles already exist). Updates <code>model.biv_profiles_df</code> for each successful profile and saves their results as a <a href="../profile_structs/#PlaceholderLikelihood.BivariateConfidenceStruct"><code>BivariateConfidenceStruct</code></a> in <code>model.biv_profiles_dict</code>, where the keys for the dictionary is the row number in <code>model.biv_profiles_df</code> of the corresponding profile.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoelTrent/PlaceholderLikelihood.jl/blob/89e8c4a0590d5b349ec7c545ea4e050d8cfebb8d/src/bivariate_methods/bivariate_profile_likelihood.jl#L233-L265">source</a></section><section><div><pre><code class="nohighlight hljs">bivariate_confidenceprofiles!(model::LikelihoodModel, 
    θcombinations_symbols::Union{Vector{Vector{Symbol}}, Vector{Tuple{Symbol, Symbol}}}, 
    num_points::Int; 
    &lt;keyword arguments&gt;)</code></pre><p>Profiles just the provided <code>θcombinations_symbols</code> parameter pairs, provided as either a vector of vectors or a vector of tuples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoelTrent/PlaceholderLikelihood.jl/blob/89e8c4a0590d5b349ec7c545ea4e050d8cfebb8d/src/bivariate_methods/bivariate_profile_likelihood.jl#L437-L444">source</a></section><section><div><pre><code class="nohighlight hljs">bivariate_confidenceprofiles!(model::LikelihoodModel, 
    profile_m_random_combinations::Int, 
    num_points::Int; 
    &lt;keyword arguments&gt;)</code></pre><p>Profiles m random two-way combinations of model parameters (sampling without replacement), where <code>0 &lt; m ≤ binomial(model.core.num_pars,2)</code>.</p><div class="admonition is-warning"><header class="admonition-header">θcombinations_is_unique keyword argument</header><div class="admonition-body"><p><code>θcombinations_is_unique</code> is not a valid keyword argument for this function method as it internally produces the parameter combinations which are guaranteed to be unique.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoelTrent/PlaceholderLikelihood.jl/blob/89e8c4a0590d5b349ec7c545ea4e050d8cfebb8d/src/bivariate_methods/bivariate_profile_likelihood.jl#L469-L480">source</a></section><section><div><pre><code class="nohighlight hljs">bivariate_confidenceprofiles!(model::LikelihoodModel, 
    num_points::Int; 
    &lt;keyword arguments&gt;)</code></pre><p>Profiles all two-way combinations of model parameters.</p><div class="admonition is-warning"><header class="admonition-header">θcombinations_is_unique keyword argument</header><div class="admonition-body"><p><code>θcombinations_is_unique</code> is not a valid keyword argument for this function method as it internally produces the parameter combinations which are guaranteed to be unique.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoelTrent/PlaceholderLikelihood.jl/blob/89e8c4a0590d5b349ec7c545ea4e050d8cfebb8d/src/bivariate_methods/bivariate_profile_likelihood.jl#L508-L518">source</a></section></article><h2 id="Sampling-Internal-Points"><a class="docs-heading-anchor" href="#Sampling-Internal-Points">Sampling Internal Points</a><a id="Sampling-Internal-Points-1"></a><a class="docs-heading-anchor-permalink" href="#Sampling-Internal-Points" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PlaceholderLikelihood.sample_bivariate_internal_points!" href="#PlaceholderLikelihood.sample_bivariate_internal_points!"><code>PlaceholderLikelihood.sample_bivariate_internal_points!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sample_bivariate_internal_points!(model::LikelihoodModel,
    num_points::Int;
    confidence_levels::Vector{&lt;:Float64}=Float64[],
    profile_types::Vector{&lt;:AbstractProfileType}=AbstractProfileType[],
    methods::Vector{&lt;:AbstractBivariateMethod}=AbstractBivariateMethod[],
    t::Union{Vector, Missing}=missing,
    evaluate_predictions_for_samples::Bool=true,
    proportion_of_predictions_to_keep::Real=1.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoelTrent/PlaceholderLikelihood.jl/blob/89e8c4a0590d5b349ec7c545ea4e050d8cfebb8d/src/bivariate_methods/sample_internal_points.jl#L100-L111">source</a></section></article><h2 id="Methods"><a class="docs-heading-anchor" href="#Methods">Methods</a><a id="Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Methods" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PlaceholderLikelihood.AbstractBivariateMethod" href="#PlaceholderLikelihood.AbstractBivariateMethod"><code>PlaceholderLikelihood.AbstractBivariateMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractBivariateMethod</code></pre><p>Supertype for bivariate boundary finding methods. Use <code>bivariate_methods()</code> for a list of available methods (see <a href="#PlaceholderLikelihood.bivariate_methods"><code>bivariate_methods</code></a>).</p><p><strong>Subtypes</strong></p><p><a href="#PlaceholderLikelihood.AbstractBivariateVectorMethod"><code>AbstractBivariateVectorMethod</code></a></p><p><a href="#PlaceholderLikelihood.Fix1AxisMethod"><code>Fix1AxisMethod</code></a></p><p><a href="#PlaceholderLikelihood.ContinuationMethod"><code>ContinuationMethod</code></a></p><p><a href="#PlaceholderLikelihood.AnalyticalEllipseMethod"><code>AnalyticalEllipseMethod</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoelTrent/PlaceholderLikelihood.jl/blob/89e8c4a0590d5b349ec7c545ea4e050d8cfebb8d/src/types/bivariate_methods.jl#L3-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlaceholderLikelihood.AbstractBivariateVectorMethod" href="#PlaceholderLikelihood.AbstractBivariateVectorMethod"><code>PlaceholderLikelihood.AbstractBivariateVectorMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractBivariateVectorMethod &lt;: AbstractBivariateMethod</code></pre><p>Supertype for bivariate boundary finding methods that search between two distinct points. </p><p><strong>Subtypes</strong></p><p><a href="#PlaceholderLikelihood.IterativeBoundaryMethod"><code>IterativeBoundaryMethod</code></a></p><p><a href="#PlaceholderLikelihood.RadialMLEMethod"><code>RadialMLEMethod</code></a></p><p><a href="#PlaceholderLikelihood.RadialRandomMethod"><code>RadialRandomMethod</code></a></p><p><a href="#PlaceholderLikelihood.SimultaneousMethod"><code>SimultaneousMethod</code></a></p><p><strong>Supertype Hiearachy</strong></p><p><code>AbstractBivariateVectorMethod &lt;: AbstractBivariateMethod &lt;: Any</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoelTrent/PlaceholderLikelihood.jl/blob/89e8c4a0590d5b349ec7c545ea4e050d8cfebb8d/src/types/bivariate_methods.jl#L20-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlaceholderLikelihood.bivariate_methods" href="#PlaceholderLikelihood.bivariate_methods"><code>PlaceholderLikelihood.bivariate_methods</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bivariate_methods()</code></pre><p>Prints a list of available bivariate methods. Available bivariate methods include <a href="#PlaceholderLikelihood.IterativeBoundaryMethod"><code>IterativeBoundaryMethod</code></a>, <a href="#PlaceholderLikelihood.RadialRandomMethod"><code>RadialRandomMethod</code></a>, <a href="#PlaceholderLikelihood.RadialMLEMethod"><code>RadialMLEMethod</code></a>, <a href="#PlaceholderLikelihood.SimultaneousMethod"><code>SimultaneousMethod</code></a>, <a href="#PlaceholderLikelihood.Fix1AxisMethod"><code>Fix1AxisMethod</code></a>, <a href="#PlaceholderLikelihood.ContinuationMethod"><code>ContinuationMethod</code></a> and <a href="#PlaceholderLikelihood.AnalyticalEllipseMethod"><code>AnalyticalEllipseMethod</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoelTrent/PlaceholderLikelihood.jl/blob/89e8c4a0590d5b349ec7c545ea4e050d8cfebb8d/src/types/bivariate_methods.jl#L404-L408">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlaceholderLikelihood.IterativeBoundaryMethod" href="#PlaceholderLikelihood.IterativeBoundaryMethod"><code>PlaceholderLikelihood.IterativeBoundaryMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IterativeBoundaryMethod(initial_num_points::Int, 
    angle_points_per_iter::Int, 
    edge_points_per_iter::Int, 
    radial_start_point_shift::Float64=rand(), 
    ellipse_sqrt_distortion::Float64=1.0;
    use_ellipse::Bool=false)</code></pre><p>Method for iteratively improving an initial boundary of <code>initial_num_points</code>, found by pushing out from the MLE point in directions defined by either <a href="#PlaceholderLikelihood.RadialMLEMethod"><code>RadialMLEMethod</code></a>, <code>use_ellipse=true</code>, or [<code>RadialRandomMethod</code>], <code>use_ellipse=false</code> (see <a href="../../../internal_library/bivariate/#PlaceholderLikelihood.findNpointpairs_radialMLE!"><code>PlaceholderLikelihood.findNpointpairs_radialMLE!</code></a>, <a href="user_interface/profiles_and_samples/@ref"><code>PlaceholderLikelihood.iterativeboundary_init</code></a> and <a href="user_interface/profiles_and_samples/@ref"><code>PlaceholderLikelihood.bivariate_confidenceprofile_iterativeboundary</code></a>).</p><p><strong>Arguments</strong></p><ul><li><code>initial_num_points</code>: a positive integer number of initial boundary points to find. </li><li><code>angle_points_per_iter</code>: a integer ≥ 0 for the number of edges to explore and improve based on the angle objective before switching to the edge objective. If <code>angle_points_per_iter &gt; 0</code> and <code>edge_points_per_iter &gt; 0</code> the angle objective is considered first.</li><li><code>edge_points_per_iter</code>:  a integer ≥ 0 for the number of edges to explore and improve based on the edge objective before switching back to the angle objective. If <code>angle_points_per_iter &gt; 0</code> and <code>edge_points_per_iter &gt; 0</code> the angle objective is considered first.</li><li><code>radial_start_point_shift</code>: a number ∈ [0.0,1.0]. Default is <code>rand()</code> (defined on [0.0,1.0]), meaning that by default a different set of initial points will be found each time.</li><li><code>ellipse_sqrt_distortion</code>: a number ∈ [0.0,1.0]. Default is <code>0.01</code>. </li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>use_ellipse</code>: Whether to find <code>initial_num_points</code> by searching in directions defined by an ellipse approximation, as in <a href="#PlaceholderLikelihood.RadialMLEMethod"><code>RadialMLEMethod</code></a>, or , as in <a href="#PlaceholderLikelihood.RadialRandomMethod"><code>RadialRandomMethod</code></a>. Default is <code>false</code>.</li></ul><p><strong>Details</strong></p><p>For additional information on the <code>radial_start_point_shift</code> and <code>ellipse_sqrt_distortion</code> arguments see the keyword arguments for <a href="https://joeltrent.github.io/EllipseSampling.jl/stable/user_interface/#EllipseSampling.generate_N_clustered_points"><code>generate_N_clustered_points</code></a> in <a href="https://joeltrent.github.io/EllipseSampling.jl/stable">EllipseSampling.jl</a>.</p><p>Recommended for use with the <a href="../profile_structs/#PlaceholderLikelihood.LogLikelihood"><code>LogLikelihood</code></a> profile type. Radial directions, edge length and internal angle calculations are rescaled by the relative magnitude/scale of the two interest parameters. This is so directions and regions explored and consequently the boundary found are not dominated by the parameter with the larger magnitude.</p><p>Once an initial boundary is found by pushing out from the MLE point in directions defined by either <a href="#PlaceholderLikelihood.RadialMLEMethod"><code>RadialMLEMethod</code></a> or [<code>RadialRandomMethod</code>], the method seeks to improve this boundary by minimising an internal angle and an edge length objective, each considered sequentially, until the desired number of boundary points are found. As such, the method can be thought of as a mesh smoothing or improvement algorithm; we can consider the boundary found at a given moment in time to be a N-sided polygon with edges between adjacent boundary points (vertices). </p><p>Regions we define as needing improvement are those with:</p><ol><li>Internal angles between adjacent edges that are far from being straight (180 degrees or π radians). The region defined by these edges is not well explored as the real boundary edge in this region likely has some degree of smooth curvature. It may also indicate that one of these edges cuts our boundary into a enclosed region and an unexplored region on the other side of the edge. In the event that a vertex is on a user-provided bound for a parameter, this objective is set to zero, as this angle region is a byproduct of user input and not the actual log-likelihood region. This objective is defined in <a href="../../../internal_library/bivariate/#PlaceholderLikelihood.internal_angle_from_pi!"><code>PlaceholderLikelihood.internal_angle_from_pi!</code></a>.</li><li>Edges between adjacent vertices that have a large euclidean distance. The regions between these vertices is not well explored as it is unknown whether the boundary actually is straight between these vertices. On average the closer two vertices are, the more likely the edge between the two points is well approximated by a straight line, and thus our mesh is a good representation of the true log-likelihood boundary. This objective is defined in <a href="../../../internal_library/bivariate/#PlaceholderLikelihood.edge_length"><code>PlaceholderLikelihood.edge_length</code></a>.</li></ol><p>The method is implemented as follows:</p><ol><li>Create edges between adjacent vertices on the intial boundary. Calculate angle and edge length objectives for these edges and vertices and place them into tracked heaps.</li><li>Until found the desired number of boundary points repeat steps 3 and 4.</li><li>For <code>angle_points_per_iter</code> points:<ol><li>Peek at the top vertex of the angle heap.</li><li>Place a candidate point in the middle of the edge connected to this vertex that has the larger angle at the vertex the edge connects to. This is so we explore the worse defined region of the boundary.</li><li>Use this candidate to find a new boundary point (see below).</li><li>If found a new boundary point, break edge we placed candidate on and replace with edges to the new boundary point, updating angle and edge length objectives in the tracked heap (see <a href="user_interface/profiles_and_samples/@ref"><code>PlaceholderLikelihood.heapupdates_success!</code></a>). Else break our polygon into multiple polygons (see <a href="user_interface/profiles_and_samples/@ref"><code>PlaceholderLikelihood.heapupdates_failure</code></a>).</li></ol></li><li>For <code>edge_points_per_iter</code> points:<ol><li>Peek at the top edge of the edge heap.</li><li>Place a candidate point in the middle of this edge.</li><li>Same as for step 3.3.</li><li>Same as for step 3.4.</li></ol></li></ol><div class="admonition is-info"><header class="admonition-header">angle_points_per_iter and edge_points_per_iter</header><div class="admonition-body"><p>At least one of <code>angle_points_per_iter</code> and <code>edge_points_per_iter</code> must be non-zero.</p></div></div><div class="admonition is-info"><header class="admonition-header">Using a candidate point to find a new boundary point</header><div class="admonition-body"><p>Uses <a href="../../../internal_library/bivariate/#PlaceholderLikelihood.newboundarypoint!"><code>PlaceholderLikelihood.newboundarypoint!</code></a>.</p><p>If a candidate point is on the log-likelihood threshold boundary, we accept the point.</p><p>If a candidate point is inside the boundary, then we search in the normal direction to the edge until we find a boundary point or hit the parameter bound, accepting either.</p><p>If a candidate point is outside the boundary we find the edge, <code>e_intersect</code> of our boundary polygon that is intersected by the line in the normal direction of the candidate edge, which passes through the candidate point. Once this edge is found, we find the vertex on <code>e_intersect</code> that is closest to our candidate point. We setup a 1D line search/bracketing method between these two points. In the event that no boundary points are found between these two points it is likely that multiple boundaries exist. If so, we break the candidate point&#39;s edge and <code>e_intersect</code> and reconnect the vertexes such that we now have multiple boundary polygons.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Largest boundary polygon at any iteration must have at least three points</header><div class="admonition-body"><p>If the largest polygon has less than two points the method will display a warning message and terminate, returning the boundary found up until then. </p></div></div><p><strong>Boundary finding method</strong></p><p>For the initial boundary, it uses a 1D bracketing algorithm between the MLE point and the point on the user-provided bounds in the search directions to find the boundary at the desired confidence level. For boundary improvement, if the candidate point is inside the boundary, it uses a 1D bracketing algorithm between an internal point and the point on the user-provided bounds in the search direction. If the candidate point is outside the boundary, it uses a derivative-free 1D line search algorithm in the search direction. If the derivative-free approach fails, it switches to a bracketing heuristic between the candidate point and closest vertex on <code>e_intersect</code>.</p><p>This method is unlikely to find boundaries that do not contain the MLE point (if they exist), but it can find them. If a boundary that does not contain the MLE point is found, it is not guaranteed to be explored. In this case the the method will inform the user that multiple boundaries likely exist for this combination of model parameters.</p><p><strong>Impact of parameter bounds</strong></p><p>If a parameter bound is in the way of reaching the boundary in a given search direction, the point on that bound will be returned as the boundary point. For the bracketing method to work, parameter values on the bounds need to be legal and return a non <code>Inf</code> value from the log-likelihood function. Interest parameter bounds that have ranges magnitudes larger than the range of the boundary may prevent the true boundary from being found. Additionally, the bracketing method will be less efficient if the interest parameter bounds are far from the true boundary. </p><p><strong>Internal Points</strong></p><p>Finds between 0 and <code>num_points - initial_num_points</code> internal points - internal points are found when the edge being considered&#39;s midpoint is inside the boundary. </p><p><strong>Supertype Hiearachy</strong></p><p><code>IterativeBoundaryMethod &lt;: AbstractBivariateVectorMethod &lt;: AbstractBivariateMethod &lt;: Any</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoelTrent/PlaceholderLikelihood.jl/blob/89e8c4a0590d5b349ec7c545ea4e050d8cfebb8d/src/types/bivariate_methods.jl#L41-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlaceholderLikelihood.RadialMLEMethod" href="#PlaceholderLikelihood.RadialMLEMethod"><code>PlaceholderLikelihood.RadialMLEMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RadialMLEMethod(ellipse_start_point_shift::Float64=rand(), 
    ellipse_sqrt_distortion::Float64=0.01)</code></pre><p>Method for finding the bivariate boundary of a confidence profile by bracketing between the MLE point and points on the provided bounds in directions given by points found on the boundary of a ellipse approximation of the log-likelihood function around the MLE, <code>e</code>, using <a href="https://joeltrent.github.io/EllipseSampling.jl/stable">EllipseSampling.jl</a> (see <a href="../../../internal_library/bivariate/#PlaceholderLikelihood.findNpointpairs_radialMLE!"><code>PlaceholderLikelihood.findNpointpairs_radialMLE!</code></a> and <a href="user_interface/profiles_and_samples/@ref"><code>PlaceholderLikelihood.bivariate_confidenceprofile_vectorsearch</code></a>)..</p><p><strong>Arguments</strong></p><ul><li><code>ellipse_start_point_shift</code>: a number ∈ [0.0,1.0]. Default is <code>rand()</code> (defined on [0.0,1.0]), meaning that by default a different set of points will be found each time.</li><li><code>ellipse_sqrt_distortion</code>: a number ∈ [0.0,1.0]. Default is <code>0.01</code>. </li></ul><p><strong>Details</strong></p><p>For additional information on arguments see the keyword arguments for <a href="https://joeltrent.github.io/EllipseSampling.jl/stable/user_interface/#EllipseSampling.generate_N_clustered_points"><code>generate_N_clustered_points</code></a> in <a href="https://joeltrent.github.io/EllipseSampling.jl/stable">EllipseSampling.jl</a>.</p><p>Recommended for use with the <a href="../profile_structs/#PlaceholderLikelihood.EllipseApprox"><code>EllipseApprox</code></a> profile type. Will produce reasonable results for the <a href="../profile_structs/#PlaceholderLikelihood.LogLikelihood"><code>LogLikelihood</code></a> profile type when bivariate profile boundaries are convex. Otherwise, <a href="#PlaceholderLikelihood.IterativeBoundaryMethod"><code>IterativeBoundaryMethod</code></a>, which has an option to use a starting solution from <a href="#PlaceholderLikelihood.RadialMLEMethod"><code>RadialMLEMethod</code></a>, is preferred as it iteratively improves the quality of the boundary and can discover regions not explored by this method. </p><p><strong>Boundary finding method</strong></p><p>Uses a 1D bracketing algorithm between the MLE point and the point on the user-provided bounds in the search directions to find the boundary at the desired confidence level.  </p><p>This method is unlikely to find boundaries that do not contain the MLE point (if they exist).</p><p><strong>Impact of parameter bounds</strong></p><p>If a parameter bound is in the way of reaching the boundary in a given search direction, the point on that bound will be returned as the boundary point. For the bracketing method to work, parameter values on the bounds need to be legal and return a non <code>Inf</code> value from the log-likelihood function. Interest parameter bounds that have ranges magnitudes larger than the range of the boundary may prevent the true boundary from being found. Additionally, the bracketing method will be less efficient if the interest parameter bounds are far from the true boundary. </p><p><strong>Internal Points</strong></p><p>Finds no internal points.</p><p><strong>Supertype Hiearachy</strong></p><p><code>RadialMLEMethod &lt;: AbstractBivariateVectorMethod &lt;: AbstractBivariateMethod &lt;: Any</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoelTrent/PlaceholderLikelihood.jl/blob/89e8c4a0590d5b349ec7c545ea4e050d8cfebb8d/src/types/bivariate_methods.jl#L146-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlaceholderLikelihood.RadialRandomMethod" href="#PlaceholderLikelihood.RadialRandomMethod"><code>PlaceholderLikelihood.RadialRandomMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RadialRandomMethod(num_radial_directions::Int)</code></pre><p>Method for finding the bivariate boundary of a confidence profile by finding internal boundary points using a uniform random distribution on provided bounds and choosing <code>num_radial_directions</code> to explore from these points (see <a href="user_interface/profiles_and_samples/@ref"><code>PlaceholderLikelihood.findNpointpairs_radialRandom!</code></a> and <a href="user_interface/profiles_and_samples/@ref"><code>PlaceholderLikelihood.bivariate_confidenceprofile_vectorsearch</code></a>).</p><p><strong>Arguments</strong></p><ul><li><code>num_radial_directions</code>: an integer greater than zero. </li></ul><p><strong>Details</strong></p><p>Recommended for use with the <a href="../profile_structs/#PlaceholderLikelihood.LogLikelihood"><code>LogLikelihood</code></a> profile type. Radial directions are rescaled by the relative magnitude/scale of the two interest parameters. This is so directions explored and consequently the boundary found are not dominated by the parameter with the larger magnitude.</p><p>The method first uniformly samples the region specified by the bounds for the two interest parameters until a point within the boundary is found. Then it chooses <code>num_radial_directions</code>, spaced uniformly around a circle, and rotates these directions by a random phase shift ∈ <code>[0.0, 2π/num_directions]</code> radians. These directions are then distorted by the relative magnitude/scale of the two interest parameters. Then for each of these directions, until it runs out of directions or finds the desired number of points, it finds the closest point on the bounds from the internal point in this direction. If the point on the bounds is outside the boundary, it accepts the point pair. A bracketing method is then used to find a boundary point between the point pair (the bound point and the internal point). The method continues searching for internal points and generating directions until the desired number of boundary points is found.</p><p>Given a fixed number of desired boundary points, we can decrease the cost of finding internal points by increasing the number of radial directions to explore, <code>num_radial_directions</code>, at each internal point. However, it is important to balance <code>num_radial_directions</code> with the desired number of boundary points. If <code>num_radial_directions</code> is large relative to the number of boundary points, then the boundary the method finds may constitute a local search around the found internal points. Resultantly, there may be regions were the boundary is not well explored. This will be less of an issue for more &#39;circular&#39; boundary regions.   </p><p><a href="#PlaceholderLikelihood.IterativeBoundaryMethod"><code>IterativeBoundaryMethod</code></a> may be preferred over this method if evaluating the log-likelihood function is expensive or the bounds provided for the interest parameters are much larger than the boundary, as the uniform random sampling for internal points will become very expensive. </p><p><strong>Boundary finding method</strong></p><p>Uses a 1D bracketing algorithm between an internal point and the point on the user-provided bounds in the search direction to find the boundary at the desired confidence level.  </p><p>This method can find multiple boundaries (if they exist).</p><p><strong>Impact of parameter bounds</strong></p><p>If a parameter bound is in the way of reaching the boundary in a given search direction, in contrast to <a href="#PlaceholderLikelihood.RadialMLEMethod"><code>RadialMLEMethod</code></a>, the point on that bound will not be returned as the boundary point. For the bracketing method to work, parameter values on the bounds need to be legal and return a non <code>Inf</code> value from the log-likelihood function. Interest parameter bounds that have ranges magnitudes larger than the range of the boundary may prevent the true boundary from being found. Additionally, the bracketing method will be less efficient if the interest parameter bounds are far from the true boundary. The method will fail if the interest parameter bounds are fully contained by the boundary.</p><p><strong>Internal Points</strong></p><p>Finds a minimum of <code>div(num_points, num_radial_directions, RoundUp)</code> internal points.</p><p><strong>Supertype Hiearachy</strong></p><p><code>RadialRandomMethod &lt;: AbstractBivariateVectorMethod &lt;: AbstractBivariateMethod &lt;: Any</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoelTrent/PlaceholderLikelihood.jl/blob/89e8c4a0590d5b349ec7c545ea4e050d8cfebb8d/src/types/bivariate_methods.jl#L191-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlaceholderLikelihood.SimultaneousMethod" href="#PlaceholderLikelihood.SimultaneousMethod"><code>PlaceholderLikelihood.SimultaneousMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SimultaneousMethod()</code></pre><p>Method for finding the bivariate boundary of a confidence profile by finding internal and external boundary points using a uniform random distribution on provided bounds, pairing these points in the order they&#39;re found and bracketing between each pair (see <a href="../../../internal_library/bivariate/#PlaceholderLikelihood.findNpointpairs_simultaneous!"><code>PlaceholderLikelihood.findNpointpairs_simultaneous!</code></a> and <a href="user_interface/profiles_and_samples/@ref"><code>PlaceholderLikelihood.bivariate_confidenceprofile_vectorsearch</code></a>).</p><p><strong>Details</strong></p><p>Recommended for use with the <a href="../profile_structs/#PlaceholderLikelihood.LogLikelihood"><code>LogLikelihood</code></a> profile type. </p><p>The method uniformly samples the region specified by the bounds for the two interest parameters until as many internal and external boundary points as the desired number of boundary points are found. These points are paired in the order they are found. A bracketing method is then used to find a boundary point between the point pair (the external point and the internal point).</p><p><a href="#PlaceholderLikelihood.RadialRandomMethod"><code>RadialRandomMethod</code></a> and <a href="#PlaceholderLikelihood.IterativeBoundaryMethod"><code>IterativeBoundaryMethod</code></a> are preferred over this method from a computational performance standpoint as they require fewer log-likelihood evalutions (when <a href="#PlaceholderLikelihood.RadialRandomMethod"><code>RadialRandomMethod</code></a> has parameter <code>num_radial_directions</code> &gt; 1). </p><p><strong>Boundary finding method</strong></p><p>Uses a 1D bracketing algorithm between a valid point pair to find the boundary at the desired confidence level.  </p><p>This method can find multiple boundaries (if they exist).</p><p><strong>Impact of parameter bounds</strong></p><p>If a parameter bound is in the way of reaching the boundary, points will not be put on that bound. Additionally, if the true boundary is very close to a parameter bound, the method will struggle to find this region of the boundary. This is because finding the boundary in this location requires generating a random point between the boundary and the parameter bound, which becomes more difficult the closer they are. Interest parameter bounds that have ranges magnitudes larger than the range of the boundary will make finding internal points very difficult, requiring a lot of computational effort. Similarly, the inverse will be true if external points are hard to find. The method will fail if the interest parameter bounds are fully contained by the boundary.</p><p><strong>Internal Points</strong></p><p>Finds <code>num_points</code> internal points.</p><p><strong>Supertype Hiearachy</strong></p><p><code>SimultaneousMethod &lt;: AbstractBivariateVectorMethod &lt;: AbstractBivariateMethod &lt;: Any</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoelTrent/PlaceholderLikelihood.jl/blob/89e8c4a0590d5b349ec7c545ea4e050d8cfebb8d/src/types/bivariate_methods.jl#L235-L265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlaceholderLikelihood.Fix1AxisMethod" href="#PlaceholderLikelihood.Fix1AxisMethod"><code>PlaceholderLikelihood.Fix1AxisMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Fix1AxisMethod()</code></pre><p>Method for finding the bivariate boundary of a confidence profile by using uniform random distributions on provided bounds to draw a value for one interest parameter, fix it, and draw two values for the other interest parameter, using the pair to find a boundary point using a bracketing method if the pair are a valid bracket (see <a href="user_interface/profiles_and_samples/@ref"><code>PlaceholderLikelihood.findNpointpairs_fix1axis!</code></a> and <a href="user_interface/profiles_and_samples/@ref"><code>PlaceholderLikelihood.bivariate_confidenceprofile_fix1axis</code></a>).</p><p><strong>Details</strong></p><p>Recommended for use with the <a href="../profile_structs/#PlaceholderLikelihood.LogLikelihood"><code>LogLikelihood</code></a> profile type. </p><p>The method finds the desired number of boundary points by fixing the first and second interest parameters for half of these points each. It first draws a value for the fixed parameter using a uniform random distribution on provided bounds (e.g. ψ<em>x). Then it draws two values for the unfixed parameter in the same fashion (e.g. ψ</em>y1 and ψ<em>y2]). If one of these points ([ψ</em>x, ψ<em>y1] and [ψ</em>x, ψ_y2]) is an internal point and the other an external point, the point pair is accepted as they are a valid bracket. A bracketing method is then used to find a boundary point between the point pair (the internal and external point). The method continues searching for valid point pairs until the desired number of boundary points is found.</p><p><a href="#PlaceholderLikelihood.RadialRandomMethod"><code>RadialRandomMethod</code></a> and <a href="#PlaceholderLikelihood.IterativeBoundaryMethod"><code>IterativeBoundaryMethod</code></a> are preferred over this method from a computational performance standpoint as they require fewer log-likelihood evalutions (when <a href="#PlaceholderLikelihood.RadialRandomMethod"><code>RadialRandomMethod</code></a> has parameter <code>num_radial_directions</code> &gt; 1). <a href="#PlaceholderLikelihood.SimultaneousMethod"><code>SimultaneousMethod</code></a> will also likely be more efficient, even though it uses four random numbers vs three, as it doesn&#39;t unneccesarily throw away points.  </p><p><strong>Boundary finding method</strong></p><p>Uses a 1D bracketing algorithm between a valid point pair, which are parallel to the x or y axis, to find the boundary at the desired confidence level.  </p><p>This method can find multiple boundaries (if they exist).</p><p><strong>Impact of parameter bounds</strong></p><p>If a parameter bound is in the way of reaching the boundary, points will not be put on that bound. Additionally, if the true boundary is very close to a parameter bound, the method will struggle to find this region of the boundary. This is because finding the boundary in this location requires generating a random point between the boundary and the parameter bound, which becomes more difficult the closer they are. Interest parameter bounds that have ranges magnitudes larger than the range of the boundary will make finding internal points very difficult, requiring a lot of computational effort. Similarly, the inverse will be true if external points are hard to find. The method will fail if the interest parameter bounds are fully contained by the boundary.</p><p><strong>Internal Points</strong></p><p>Finds <code>num_points</code> internal points.</p><p><strong>Supertype Hiearachy</strong></p><p><code>Fix1AxisMethod &lt;: AbstractBivariateMethod &lt;: Any</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoelTrent/PlaceholderLikelihood.jl/blob/89e8c4a0590d5b349ec7c545ea4e050d8cfebb8d/src/types/bivariate_methods.jl#L269-L299">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlaceholderLikelihood.AnalyticalEllipseMethod" href="#PlaceholderLikelihood.AnalyticalEllipseMethod"><code>PlaceholderLikelihood.AnalyticalEllipseMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AnalyticalEllipseMethod(ellipse_start_point_shift::Float64, 
    ellipse_sqrt_distortion::Float64)</code></pre><p>Method for sampling the desired number of boundary points on a ellipse approximation of the log-likelihood function centred at the maximum likelihood estimate point using <a href="https://joeltrent.github.io/EllipseSampling.jl/stable">EllipseSampling.jl</a>.</p><p><strong>Arguments</strong></p><ul><li><code>ellipse_start_point_shift</code>: a number ∈ [0.0,1.0]. Default is <code>rand()</code> (defined on [0.0,1.0]), meaning that by default a different set of points will be found each time.</li><li><code>ellipse_sqrt_distortion</code>: a number ∈ [0.0,1.0]. Default is <code>1.0</code>, meaning that by default points on the ellipse approximation are equally spaced with respect to arc length. </li></ul><p><strong>Details</strong></p><p>Used for the <a href="../profile_structs/#PlaceholderLikelihood.EllipseApproxAnalytical"><code>EllipseApproxAnalytical</code></a> profile type only: if this method is specified, then any user provided profile type will be overriden and replaced with <a href="../profile_structs/#PlaceholderLikelihood.EllipseApproxAnalytical"><code>EllipseApproxAnalytical</code></a>. This ellipse approximation ignores user provided bounds.</p><p>For additional information on arguments see the keyword arguments for <a href="https://joeltrent.github.io/EllipseSampling.jl/stable/user_interface/#EllipseSampling.generate_N_clustered_points"><code>generate_N_clustered_points</code></a> in <a href="https://joeltrent.github.io/EllipseSampling.jl/stable">EllipseSampling.jl</a>.</p><p><strong>Boundary finding method</strong></p><p>Explicitly finds the boundary using <a href="https://joeltrent.github.io/EllipseSampling.jl/stable">EllipseSampling.jl</a>.</p><p><strong>Internal Points</strong></p><p>Finds no internal points.</p><p><strong>Supertype Hiearachy</strong></p><p><code>AnalyticalEllipseMethod &lt;: AbstractBivariateMethod &lt;: Any</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoelTrent/PlaceholderLikelihood.jl/blob/89e8c4a0590d5b349ec7c545ea4e050d8cfebb8d/src/types/bivariate_methods.jl#L302-L329">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PlaceholderLikelihood.ContinuationMethod" href="#PlaceholderLikelihood.ContinuationMethod"><code>PlaceholderLikelihood.ContinuationMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ContinuationMethod(num_level_sets::Int, 
    ellipse_confidence_level::Float64, 
    ellipse_start_point_shift::Float64=rand(), 
    level_set_spacing::Symbol=:loglikelihood)</code></pre><p>Kept available for completeness but not recommended for use. A previous implementation of search directions from the MLE point was moved to [<code>RadialMLEMethod</code>].</p><p><strong>Arguments</strong></p><ul><li><code>num_level_sets</code>: the number of level sets used to get to the desired confidence level set.</li><li><code>ellipse_confidence_level</code>: a number ∈ (0.0, 1.0). the confidence level at which to construct the initial ellipse and find the initial level set boundary. Recommended to be around 0.1.</li><li><code>ellipse_start_point_shift</code>: a number ∈ [0.0,1.0]. Default is <code>rand()</code> (defined on [0.0,1.0]), meaning that by default a different set of points will be found each time.</li><li><code>ellipse_sqrt_distortion</code>: a number ∈ [0.0,1.0]. Default is <code>1.0</code>, meaning that by default points on the ellipse approximation are equally spaced with respect to arc length. </li><li><code>level_set_spacing</code>: a Symbol ∈ [:loglikelihood, :confidence]. Whether to space level sets uniformly in confidence level space or log-likelihood space, between the first level set found and the level set of desired confidence level. Default is :loglikelihood.</li></ul><p><strong>Details</strong></p><p>The method finds an initial boundary at a low confidence level close to the <code>ellipse_confidence_level</code> (see <a href="../../../internal_library/bivariate/#PlaceholderLikelihood.initial_continuation_solution!"><code>initial_continuation_solution!</code></a>). Then it &#39;continues&#39; this initial boundary sequentially to <code>num_level_sets</code> higher confidence level boundaries until the desired confidence level is reached. </p><p>Presently this continuation is done by finding a point inside the boundary that is as close as possible to being a point that makes the boundary a <a href="https://en.wikipedia.org/wiki/Star_domain">star domain</a> and is close to the centre of the area of the boundary in the x and y axes. We refer to this point as a &#39;star point&#39;, or a point that can see all the points on the boundary, without being blocked by an edge. We use a heuristic to estimate this, sampling points within the boundary and using these to produce kmeans, of which one is hopefully a star point and at the centre of the boundary. </p><p>If we find a star point we then, for every point on the current boundary, push out in the direction defined by the line segment connecting the star point and the boundary to find the next confidence level boundary. If we do not find a star point, we assign each of the boundary points to the Kmeans point they are closest to (using a Euclidean distance metric), and use the direction defined by the line segments between a boundary point and it&#39;s associated Kmeans point to find the next confidence level boundary. This direction heuristic is carried out by <a href="../../../internal_library/bivariate/#PlaceholderLikelihood.refine_search_directions!"><code>refine_search_directions!</code></a>. </p><p>A traveling salesman heuristic is used to reorder the boundary points into a new minimum perimeter polygon, <a href="../../../internal_library/bivariate/#PlaceholderLikelihood.minimum_perimeter_polygon!"><code>PlaceholderLikelihood.minimum_perimeter_polygon!</code></a>, if the continuation of one boundary to the next causes the mapping of adjacent vertices to change (expected if a star point is not found). </p><p>For additional information on the <code>ellipse_start_point_shift</code> and <code>ellipse_sqrt_distortion</code> arguments see the keyword arguments for <a href="https://joeltrent.github.io/EllipseSampling.jl/stable/user_interface/#EllipseSampling.generate_N_clustered_points"><code>generate_N_clustered_points</code></a> in <a href="https://joeltrent.github.io/EllipseSampling.jl/stable">EllipseSampling.jl</a>.</p><p><strong>Boundary finding method</strong></p><p>Uses a derivative-free 1D line search algorithm to find the boundary at subsequent confidence levels. If the derivative-free approach fails, it switches to a bracketing algorithm between a given boundary point and the point on the user-provided bounds in the search direction.</p><p>This method is unlikely to find boundaries that do not contain the MLE point (if they exist).</p><p><strong>Internal Points</strong></p><p>Finds <code>num_points * num_level_sets</code> internal points at distinct level sets.</p><p><strong>Supertype Hiearachy</strong></p><p><code>ContinuationMethod &lt;: AbstractBivariateMethod &lt;: Any</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoelTrent/PlaceholderLikelihood.jl/blob/89e8c4a0590d5b349ec7c545ea4e050d8cfebb8d/src/types/bivariate_methods.jl#L340-L380">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../univariate/">« Univariate Profiles</a><a class="docs-footer-nextpage" href="../dimensional/">Dimensional Samples »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Tuesday 27 June 2023 05:25">Tuesday 27 June 2023</span>. Using Julia version 1.9.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
