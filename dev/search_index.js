var documenterSearchIndex = {"docs":
[{"location":"internal_library/#Internal-Library","page":"Internal Library","title":"Internal Library","text":"","category":"section"},{"location":"user_interface/profiles_and_samples/bivariate/","page":"Bivariate Profiles","title":"Bivariate Profiles","text":"Pages = [\"bivariate.md\"]","category":"page"},{"location":"user_interface/profiles_and_samples/bivariate/#Bivariate-Profiles","page":"Bivariate Profiles","title":"Bivariate Profiles","text":"","category":"section"},{"location":"user_interface/profiles_and_samples/bivariate/","page":"Bivariate Profiles","title":"Bivariate Profiles","text":"bivariate_confidenceprofiles!","category":"page"},{"location":"user_interface/profiles_and_samples/bivariate/#PlaceholderLikelihood.bivariate_confidenceprofiles!","page":"Bivariate Profiles","title":"PlaceholderLikelihood.bivariate_confidenceprofiles!","text":"bivariate_confidenceprofiles!(model::LikelihoodModel, θcombinations::Vector{Vector{Int}}, num_points::Int; <keyword arguments>)\n\nFinds `num_points` `profile_type` boundary points at a specified `confidence_level` for each combination of interest parameters using a specified `method`, optionally saving any found internal points.\n\nArguments\n\nmodel: a LikelihoodModel containing model information, saved profiles and predictions.\nθcombinations: vector of pairs of parameters to profile, as a vector of vectors of model parameter indexes.\nnum_points: number of points to find on the boundary at the specified confidence level. Depending on the method, if a region of the user-provided bounds is inside the boundary some of these points will be on the bounds and inside the boundary. \n\nKeyword Arguments\n\nconfidence_level: a number ∈ (0.0, 1.0) for the confidence level to find the profile_type boundary at. Default is 0.95 (95%).\nprofile_type: whether to use the true loglikelihood function or an ellipse approximation of the loglikelihood function centred at the MLE (with optional use of parameter bounds). Available profile types are LogLikelihood, EllipseApprox and EllipseApproxAnalytical. Default is LogLikelihood() (LogLikelihood).\nmethod: a method of type AbstractBivariateMethod. For a list of available methods use bivariate_methods() (bivariate_methods). Default is RadialRandomMethod(3) (RadialRandomMethod).\nθcombinations_is_unique: boolean variable specifying whether all parameter combinations in θcombinations are ordered by parameter index and are unique. Default is false.\nsave_internal_points: boolean variable specifying whether to save points found inside the boundary during boundary computation. Internal points can be plotted in bivariate profile plots and will be used to generate predictions from a given bivariate profile. Default is true.\nexisting_profiles: Symbol ∈ [:ignore, :merge, :overwrite] specifying what to do if profiles already exist for a given θcombination, confidence_level, profile_type and method. See below for each symbol's meanings. Default is :merge.\nshow_progress: boolean variable specifying whether to display progress bars on the percentage of θcombinations completed and estimated time of completion. Default is model.show_progress.\n\n!!! note existingprofiles meanings     * :ignore means profiles that already exist will not be recomputed even if they contain fewer `numpointsboundary points.      * :merge means profiles that already exist will be merged with profiles from the current algorithm run to reachnumpoints. If the existing profile already has at leastnumpointsboundary points then that profile will not be recomputed. Otherwise, the specified method will be run starting from the difference betweennum_points` and the number of points in the existing profile. The result of that method run will be merged with the existing profile.       * :overwrite means profiles that already exist will be overwritten, regardless of how many points they contain.\n\nDetails\n\nModifies model in place. Using bivariate_confidenceprofile this function calls the algorithm/method specified by method for each parameter combination in θcombinations (depending on the setting for existing_profiles and num_points if these profiles already exist). Updates model.biv_profiles_df for each successful profile and saves their results as a BivariateConfidenceStruct in model.biv_profiles_dict, where the keys for the dictionary is the row number in model.biv_profiles_df of the corresponding profile.\n\n\n\n\n\nbivariate_confidenceprofiles!(model::LikelihoodModel, θcombinations_symbols::Union{Vector{Vector{Symbol}}, Vector{Tuple{Symbol, Symbol}}}, num_points::Int; <keyword arguments>)\n\nProfiles just the provided θcombinations_symbols parameter pairs, provided as either a vector of vectors or a vector of tuples.\n\n\n\n\n\nbivariate_confidenceprofiles!(model::LikelihoodModel, profile_m_random_combinations::Int, num_points::Int; <keyword arguments>)\n\nProfiles m random two-way combinations of model parameters (sampling without replacement), where 0 < m ≤ binomial(model.core.num_pars,2).\n\nθcombinations_is_unique is not a valid keyword argument for this function method as it internally produces the parameter combinations which are guaranteed to be unique.\n\n\n\n\n\nbivariate_confidenceprofiles!(model::LikelihoodModel, num_points::Int; <keyword arguments>)\n\nProfiles all two-way combinations of model parameters.\n\nθcombinations_is_unique is not a valid keyword argument for this function method as it internally produces the parameter combinations which are guaranteed to be unique.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/profiles_and_samples/bivariate/#Methods","page":"Bivariate Profiles","title":"Methods","text":"","category":"section"},{"location":"user_interface/profiles_and_samples/bivariate/","page":"Bivariate Profiles","title":"Bivariate Profiles","text":"AbstractBivariateMethod\nAbstractBivariateVectorMethod\nbivariate_methods\nIterativeBoundaryMethod\nRadialMLEMethod\nRadialRandomMethod\nSimultaneousMethod\nFix1AxisMethod\nAnalyticalEllipseMethod\nContinuationMethod","category":"page"},{"location":"user_interface/profiles_and_samples/bivariate/#PlaceholderLikelihood.AbstractBivariateMethod","page":"Bivariate Profiles","title":"PlaceholderLikelihood.AbstractBivariateMethod","text":"AbstractBivariateMethod\n\nSupertype for bivariate boundary finding methods. Use bivariate_methods() for a list of available methods (see bivariate_methods).\n\nSubtypes\n\nAbstractBivariateVectorMethod\n\nFix1AxisMethod\n\nContinuationMethod\n\nAnalyticalEllipseMethod\n\n\n\n\n\n","category":"type"},{"location":"user_interface/profiles_and_samples/bivariate/#PlaceholderLikelihood.AbstractBivariateVectorMethod","page":"Bivariate Profiles","title":"PlaceholderLikelihood.AbstractBivariateVectorMethod","text":"AbstractBivariateVectorMethod <: AbstractBivariateMethod\n\nSupertype for bivariate boundary finding methods that search between two distinct points. \n\nSubtypes\n\nIterativeBoundaryMethod\n\nRadialMLEMethod\n\nRadialRandomMethod\n\nSimultaneousMethod\n\nSupertype Hiearachy\n\nAbstractBivariateVectorMethod <: AbstractBivariateMethod <: Any\n\n\n\n\n\n","category":"type"},{"location":"user_interface/profiles_and_samples/bivariate/#PlaceholderLikelihood.bivariate_methods","page":"Bivariate Profiles","title":"PlaceholderLikelihood.bivariate_methods","text":"bivariate_methods()\n\nPrints a list of available bivariate methods. Available bivariate methods include IterativeBoundaryMethod, RadialRandomMethod, RadialMLEMethod, SimultaneousMethod, Fix1AxisMethod, ContinuationMethod and AnalyticalEllipseMethod.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/profiles_and_samples/bivariate/#PlaceholderLikelihood.IterativeBoundaryMethod","page":"Bivariate Profiles","title":"PlaceholderLikelihood.IterativeBoundaryMethod","text":"IterativeBoundaryMethod(initial_num_points::Int, angle_points_per_iter::Int, edge_points_per_iter::Int, radial_start_point_shift::Float64=rand(), ellipse_sqrt_distortion::Float64=1.0, use_ellipse::Bool=false)\n\nMethod for iteratively improving an initial boundary of initial_num_points, found by pushing out from the MLE point in directions defined by either RadialMLEMethod, use_ellipse=true, or [RadialRandomMethod], use_ellipse=false (see PlaceholderLikelihood.findNpointpairs_radialMLE!, PlaceholderLikelihood.iterativeboundary_init and PlaceholderLikelihood.bivariate_confidenceprofile_iterativeboundary).\n\nArguments\n\ninitial_num_points: a positive integer number of initial boundary points to find. \nangle_points_per_iter: a integer ≥ 0 for the number of edges to explore and improve based on the angle objective before switching to the edge objective. If angle_points_per_iter > 0 and edge_points_per_iter > 0 the angle objective is considered first.\nedge_points_per_iter:  a integer ≥ 0 for the number of edges to explore and improve based on the edge objective before switching back to the angle objective. If angle_points_per_iter > 0 and edge_points_per_iter > 0 the angle objective is considered first.\nradial_start_point_shift: a number ∈ [0.0,1.0]. Default is rand() (defined on [0.0,1.0]), meaning that by default a different set of initial points will be found each time.\nellipse_sqrt_distortion: a number ∈ [0.0,1.0]. Default is 0.01. \n\nKeyword Arguments\n\nuse_ellipse: Whether to find initial_num_points by searching in directions defined by an ellipse approximation, as in RadialMLEMethod, or , as in RadialRandomMethod. Default is false.\n\nDetails\n\nFor additional information on the radial_start_point_shift and ellipse_sqrt_distortion arguments see the keyword arguments for generate_N_clustered_points in EllipseSampling.jl.\n\nRecommended for use with the LogLikelihood profile type. Radial directions, edge length and internal angle calculations are rescaled by the relative magnitude/scale of the two interest parameters. This is so directions and regions explored and consequently the boundary found are not dominated by the parameter with the larger magnitude.\n\nOnce an initial boundary is found by pushing out from the MLE point in directions defined by either RadialMLEMethod or [RadialRandomMethod], the method seeks to improve this boundary by minimising an internal angle and an edge length objective, each considered sequentially, until the desired number of boundary points are found. As such, the method can be thought of as a mesh smoothing or improvement algorithm; we can consider the boundary found at a given moment in time to be a N-sided polygon with edges between adjacent boundary points (vertices). \n\nRegions we define as needing improvement are those with:\n\nInternal angles between adjacent edges that are far from being straight (180 degrees or π radians). The region defined by these edges is not well explored as the real boundary edge in this region likely has some degree of smooth curvature. It may also indicate that one of these edges cuts our boundary into a enclosed region and an unexplored region on the other side of the edge. In the event that a vertex is on a user-provided bound for a parameter, this objective is set to zero, as this angle region is a byproduct of user input and not the actual loglikelihood region. This objective is defined in PlaceholderLikelihood.internal_angle_from_pi!.\nEdges between adjacent vertices that have a large euclidean distance. The regions between these vertices is not well explored as it is unknown whether the boundary actually is straight between these vertices. On average the closer two vertices are, the more likely the edge between the two points is well approximated by a straight line, and thus our mesh is a good representation of the true loglikelihood boundary. This objective is defined in PlaceholderLikelihood.edge_length.\n\nThe method is implemented as follows:\n\nCreate edges between adjacent vertices on the intial boundary. Calculate angle and edge length objectives for these edges and vertices and place them into tracked heaps.\nUntil found the desired number of boundary points repeat steps 3 and 4.\nFor angle_points_per_iter points:\nPeek at the top vertex of the angle heap.\nPlace a candidate point in the middle of the edge connected to this vertex that has the larger angle at the vertex the edge connects to. This is so we explore the worse defined region of the boundary.\nUse this candidate to find a new boundary point (see below).\nIf found a new boundary point, break edge we placed candidate on and replace with edges to the new boundary point, updating angle and edge length objectives in the tracked heap (see PlaceholderLikelihood.heapupdates_success!). Else break our polygon into multiple polygons (see PlaceholderLikelihood.heapupdates_failure).\nFor edge_points_per_iter points:\nPeek at the top edge of the edge heap.\nPlace a candidate point in the middle of this edge.\nSame as for step 3.3.\nSame as for step 3.4.\n\n!!! note anglepointsperiter and edgepointsperiter\n\nAt least one of `angle_points_per_iter` and `edge_points_per_iter` must be non-zero.\n\n!!! note Using a candidate point to find a new boundary point\n\nUses [`PlaceholderLikelihood.newboundarypoint!`](@ref).\n\nIf a candidate point is on the loglikelihood threshold boundary, we accept the point.\n\nIf a candidate point is inside the boundary, then we search in the normal direction to the edge until we find a boundary point or hit the parameter bound, accepting either.\n\nIf a candidate point is outside the boundary we find the edge, `e_intersect` of our boundary polygon that is intersected by the line in the normal direction of the candidate edge, which passes through the candidate point. Once this edge is found, we find the vertex on `e_intersect` that is closest to our candidate point. We setup a 1D line search/bracketing method between these two points. In the event that no boundary points are found between these two points it is likely that multiple boundaries exist. If so, we break the candidate point's edge and `e_intersect` and reconnect the vertexes such that we now have multiple boundary polygons.\n\n!!! warn Largest boundary polygon at any iteration must have at least three points.\n\nIf the largest polygon has less than two points the method will display a warning message and terminate, returning the boundary found up until then.\n\nBoundary finding method\n\nFor the initial boundary, it uses a 1D bracketing algorithm between the MLE point and the point on the user-provided bounds in the search directions to find the boundary at the desired confidence level. For boundary improvement, if the candidate point is inside the boundary, it uses a 1D bracketing algorithm between an internal point and the point on the user-provided bounds in the search direction. If the candidate point is outside the boundary, it uses a derivative-free 1D line search algorithm in the search direction. If the derivative-free approach fails, it switches to a bracketing heuristic between the candidate point and closest vertex on e_intersect.\n\nThis method is unlikely to find boundaries that do not contain the MLE point (if they exist), but it can find them. If a boundary that does not contain the MLE point is found, it is not guaranteed to be explored. In this case the the method will inform the user that multiple boundaries likely exist for this combination of model parameters.\n\nImpact of parameter bounds\n\nIf a parameter bound is in the way of reaching the boundary in a given search direction, the point on that bound will be returned as the boundary point. For the bracketing method to work, parameter values on the bounds need to be legal and return a non Inf value from the loglikelihood function. Interest parameter bounds that have ranges magnitudes larger than the range of the boundary may prevent the true boundary from being found. Additionally, the bracketing method will be less efficient if the interest parameter bounds are far from the true boundary. \n\nInternal Points\n\nFinds between 0 and num_points - initial_num_points internal points - internal points are found when the edge being considered's midpoint is inside the boundary. \n\nSupertype Hiearachy\n\nIterativeBoundaryMethod <: AbstractBivariateVectorMethod <: AbstractBivariateMethod <: Any\n\n\n\n\n\n","category":"type"},{"location":"user_interface/profiles_and_samples/bivariate/#PlaceholderLikelihood.RadialMLEMethod","page":"Bivariate Profiles","title":"PlaceholderLikelihood.RadialMLEMethod","text":"RadialMLEMethod(ellipse_start_point_shift::Float64=rand(), ellipse_sqrt_distortion::Float64=0.01)\n\nMethod for finding the bivariate boundary of a confidence profile by bracketing between the MLE point and points on the provided bounds in directions given by points found on the boundary of a ellipse approximation of the loglikelihood function around the MLE, e, using EllipseSampling.jl (see PlaceholderLikelihood.findNpointpairs_radialMLE! and PlaceholderLikelihood.bivariate_confidenceprofile_vectorsearch)..\n\nArguments\n\nellipse_start_point_shift: a number ∈ [0.0,1.0]. Default is rand() (defined on [0.0,1.0]), meaning that by default a different set of points will be found each time.\nellipse_sqrt_distortion: a number ∈ [0.0,1.0]. Default is 0.01. \n\nDetails\n\nFor additional information on arguments see the keyword arguments for generate_N_clustered_points in EllipseSampling.jl.\n\nRecommended for use with the EllipseApprox profile type. Will produce reasonable results for the LogLikelihood profile type when bivariate profile boundaries are convex. Otherwise, IterativeBoundaryMethod, which has an option to use a starting solution from RadialMLEMethod, is preferred as it iteratively improves the quality of the boundary and can discover regions not explored by this method. \n\nBoundary finding method\n\nUses a 1D bracketing algorithm between the MLE point and the point on the user-provided bounds in the search directions to find the boundary at the desired confidence level.  \n\nThis method is unlikely to find boundaries that do not contain the MLE point (if they exist).\n\nImpact of parameter bounds\n\nIf a parameter bound is in the way of reaching the boundary in a given search direction, the point on that bound will be returned as the boundary point. For the bracketing method to work, parameter values on the bounds need to be legal and return a non Inf value from the loglikelihood function. Interest parameter bounds that have ranges magnitudes larger than the range of the boundary may prevent the true boundary from being found. Additionally, the bracketing method will be less efficient if the interest parameter bounds are far from the true boundary. \n\nInternal Points\n\nFinds no internal points.\n\nSupertype Hiearachy\n\nRadialMLEMethod <: AbstractBivariateVectorMethod <: AbstractBivariateMethod <: Any\n\n\n\n\n\n","category":"type"},{"location":"user_interface/profiles_and_samples/bivariate/#PlaceholderLikelihood.RadialRandomMethod","page":"Bivariate Profiles","title":"PlaceholderLikelihood.RadialRandomMethod","text":"RadialRandomMethod(num_radial_directions::Int)\n\nMethod for finding the bivariate boundary of a confidence profile by finding internal boundary points using a uniform random distribution on provided bounds and choosing num_radial_directions to explore from these points (see PlaceholderLikelihood.findNpointpairs_radialRandom! and PlaceholderLikelihood.bivariate_confidenceprofile_vectorsearch).\n\nArguments\n\nnum_radial_directions: an integer greater than zero. \n\nDetails\n\nRecommended for use with the LogLikelihood profile type. Radial directions are rescaled by the relative magnitude/scale of the two interest parameters. This is so directions explored and consequently the boundary found are not dominated by the parameter with the larger magnitude.\n\nThe method first uniformly samples the region specified by the bounds for the two interest parameters until a point within the boundary is found. Then it chooses num_radial_directions, spaced uniformly around a circle, and rotates these directions by a random phase shift ∈ [0.0, 2π/num_directions] radians. These directions are then distorted by the relative magnitude/scale of the two interest parameters. Then for each of these directions, until it runs out of directions or finds the desired number of points, it finds the closest point on the bounds from the internal point in this direction. If the point on the bounds is outside the boundary, it accepts the point pair. A bracketing method is then used to find a boundary point between the point pair (the bound point and the internal point). The method continues searching for internal points and generating directions until the desired number of boundary points is found.\n\nGiven a fixed number of desired boundary points, we can decrease the cost of finding internal points by increasing the number of radial directions to explore, num_radial_directions, at each internal point. However, it is important to balance num_radial_directions with the desired number of boundary points. If num_radial_directions is large relative to the number of boundary points, then the boundary the method finds may constitute a local search around the found internal points. Resultantly, there may be regions were the boundary is not well explored. This will be less of an issue for more 'circular' boundary regions.   \n\nIterativeBoundaryMethod may be preferred over this method if evaluating the loglikelihood function is expensive or the bounds provided for the interest parameters are much larger than the boundary, as the uniform random sampling for internal points will become very expensive. \n\nBoundary finding method\n\nUses a 1D bracketing algorithm between an internal point and the point on the user-provided bounds in the search direction to find the boundary at the desired confidence level.  \n\nThis method can find multiple boundaries (if they exist).\n\nImpact of parameter bounds\n\nIf a parameter bound is in the way of reaching the boundary in a given search direction, in contrast to RadialMLEMethod, the point on that bound will not be returned as the boundary point. For the bracketing method to work, parameter values on the bounds need to be legal and return a non Inf value from the loglikelihood function. Interest parameter bounds that have ranges magnitudes larger than the range of the boundary may prevent the true boundary from being found. Additionally, the bracketing method will be less efficient if the interest parameter bounds are far from the true boundary. The method will fail if the interest parameter bounds are fully contained by the boundary.\n\nInternal Points\n\nFinds a minimum of div(num_points, num_radial_directions, RoundUp) internal points.\n\nSupertype Hiearachy\n\nRadialRandomMethod <: AbstractBivariateVectorMethod <: AbstractBivariateMethod <: Any\n\n\n\n\n\n","category":"type"},{"location":"user_interface/profiles_and_samples/bivariate/#PlaceholderLikelihood.SimultaneousMethod","page":"Bivariate Profiles","title":"PlaceholderLikelihood.SimultaneousMethod","text":"SimultaneousMethod()\n\nMethod for finding the bivariate boundary of a confidence profile by finding internal and external boundary points using a uniform random distribution on provided bounds, pairing these points in the order they're found and bracketing between each pair (see PlaceholderLikelihood.findNpointpairs_simultaneous! and PlaceholderLikelihood.bivariate_confidenceprofile_vectorsearch).\n\nDetails\n\nRecommended for use with the LogLikelihood profile type. \n\nThe method uniformly samples the region specified by the bounds for the two interest parameters until as many internal and external boundary points as the desired number of boundary points are found. These points are paired in the order they are found. A bracketing method is then used to find a boundary point between the point pair (the external point and the internal point).\n\nRadialRandomMethod and IterativeBoundaryMethod are preferred over this method from a computational performance standpoint as they require fewer loglikelihood evalutions (when RadialRandomMethod has parameter num_radial_directions > 1). \n\nBoundary finding method\n\nUses a 1D bracketing algorithm between a valid point pair to find the boundary at the desired confidence level.  \n\nThis method can find multiple boundaries (if they exist).\n\nImpact of parameter bounds\n\nIf a parameter bound is in the way of reaching the boundary, points will not be put on that bound. Additionally, if the true boundary is very close to a parameter bound, the method will struggle to find this region of the boundary. This is because finding the boundary in this location requires generating a random point between the boundary and the parameter bound, which becomes more difficult the closer they are. Interest parameter bounds that have ranges magnitudes larger than the range of the boundary will make finding internal points very difficult, requiring a lot of computational effort. Similarly, the inverse will be true if external points are hard to find. The method will fail if the interest parameter bounds are fully contained by the boundary.\n\nInternal Points\n\nFinds num_points internal points.\n\nSupertype Hiearachy\n\nSimultaneousMethod <: AbstractBivariateVectorMethod <: AbstractBivariateMethod <: Any\n\n\n\n\n\n","category":"type"},{"location":"user_interface/profiles_and_samples/bivariate/#PlaceholderLikelihood.Fix1AxisMethod","page":"Bivariate Profiles","title":"PlaceholderLikelihood.Fix1AxisMethod","text":"Fix1AxisMethod()\n\nMethod for finding the bivariate boundary of a confidence profile by using uniform random distributions on provided bounds to draw a value for one interest parameter, fix it, and draw two values for the other interest parameter, using the pair to find a boundary point using a bracketing method if the pair are a valid bracket (see PlaceholderLikelihood.findNpointpairs_fix1axis! and PlaceholderLikelihood.bivariate_confidenceprofile_fix1axis).\n\nDetails\n\nRecommended for use with the LogLikelihood profile type. \n\nThe method finds the desired number of boundary points by fixing the first and second interest parameters for half of these points each. It first draws a value for the fixed parameter using a uniform random distribution on provided bounds (e.g. Ψx). Then it draws two values for the unfixed parameter in the same fashion (e.g. Ψy1 and Ψy2]). If one of these points ([Ψx, Ψy1] and [Ψx, Ψ_y2]) is an internal point and the other an external point, the point pair is accepted as they are a valid bracket. A bracketing method is then used to find a boundary point between the point pair (the internal and external point). The method continues searching for valid point pairs until the desired number of boundary points is found.\n\nRadialRandomMethod and IterativeBoundaryMethod are preferred over this method from a computational performance standpoint as they require fewer loglikelihood evalutions (when RadialRandomMethod has parameter num_radial_directions > 1). SimultaneousMethod will also likely be more efficient, even though it uses four random numbers vs three, as it doesn't unneccesarily throw away points.  \n\nBoundary finding method\n\nUses a 1D bracketing algorithm between a valid point pair, which are parallel to the x or y axis, to find the boundary at the desired confidence level.  \n\nThis method can find multiple boundaries (if they exist).\n\nImpact of parameter bounds\n\nIf a parameter bound is in the way of reaching the boundary, points will not be put on that bound. Additionally, if the true boundary is very close to a parameter bound, the method will struggle to find this region of the boundary. This is because finding the boundary in this location requires generating a random point between the boundary and the parameter bound, which becomes more difficult the closer they are. Interest parameter bounds that have ranges magnitudes larger than the range of the boundary will make finding internal points very difficult, requiring a lot of computational effort. Similarly, the inverse will be true if external points are hard to find. The method will fail if the interest parameter bounds are fully contained by the boundary.\n\nInternal Points\n\nFinds num_points internal points.\n\nSupertype Hiearachy\n\nFix1AxisMethod <: AbstractBivariateMethod <: Any\n\n\n\n\n\n","category":"type"},{"location":"user_interface/profiles_and_samples/bivariate/#PlaceholderLikelihood.AnalyticalEllipseMethod","page":"Bivariate Profiles","title":"PlaceholderLikelihood.AnalyticalEllipseMethod","text":"AnalyticalEllipseMethod(ellipse_start_point_shift::Float64, ellipse_sqrt_distortion::Float64)\n\nMethod for sampling the desired number of boundary points on a ellipse approximation of the loglikelihood function centred at the maximum likelihood estimate point using EllipseSampling.jl.\n\nArguments\n\nellipse_start_point_shift: a number ∈ [0.0,1.0]. Default is rand() (defined on [0.0,1.0]), meaning that by default a different set of points will be found each time.\nellipse_sqrt_distortion: a number ∈ [0.0,1.0]. Default is 1.0, meaning that by default points on the ellipse approximation are equally spaced with respect to arc length. \n\nDetails\n\nUsed for the EllipseApproxAnalytical profile type only: if this method is specified, then any user provided profile type will be overriden and replaced with EllipseApproxAnalytical. This ellipse approximation ignores user provided bounds.\n\nFor additional information on arguments see the keyword arguments for generate_N_clustered_points in EllipseSampling.jl.\n\nBoundary finding method\n\nExplicitly finds the boundary using EllipseSampling.jl.\n\nInternal Points\n\nFinds no internal points.\n\nSupertype Hiearachy\n\nAnalyticalEllipseMethod <: AbstractBivariateMethod <: Any\n\n\n\n\n\n","category":"type"},{"location":"user_interface/profiles_and_samples/bivariate/#PlaceholderLikelihood.ContinuationMethod","page":"Bivariate Profiles","title":"PlaceholderLikelihood.ContinuationMethod","text":"ContinuationMethod(num_level_sets::Int, ellipse_confidence_level::Float64, ellipse_start_point_shift::Float64=rand(), level_set_spacing::Symbol=:loglikelihood)\n\nKept available for completeness but not recommended for use. A previous implementation of search directions from the MLE point was moved to [RadialMLEMethod].\n\nArguments\n\nnum_level_sets: the number of level sets used to get to the highest confidence level set specified in targetconfidencelevels. num_level_sets ≥ length(targetconfidencelevels)\nellipse_confidence_level: a number ∈ (0.0, 1.0). the confidence level at which to construct the initial ellipse and find the initial level set boundary. Recommended to be around 0.1.\nellipse_start_point_shift: a number ∈ [0.0,1.0]. Default is rand() (defined on [0.0,1.0]), meaning that by default a different set of points will be found each time.\nellipse_sqrt_distortion: a number ∈ [0.0,1.0]. Default is 1.0, meaning that by default points on the ellipse approximation are equally spaced with respect to arc length. \nlevel_set_spacing: a Symbol ∈ [:loglikelihood, :confidence]. Whether to space level sets uniformly in confidence level space or loglikelihood space, between the first level set found and the level set of desired confidence level. Default is :loglikelihood.\n\nDetails\n\nThe method finds an initial boundary at a low confidence level close to the ellipse_confidence_level (see initial_continuation_solution!). Then it 'continues' this initial boundary sequentially to num_level_sets higher confidence level boundaries until the desired confidence level is reached. Presently this continuation is done by finding a point inside the boundary that is as close as possible to being a point that makes the boundary a star domain and is close to the centre of the area of the boundary in the x and y axes. We refer to this point as a 'star point', or a point that can see all the points on the boundary, without being blocked by an edge. We use a heuristic to estimate this, sampling points within the boundary and using these to produce kmeans, of which one is hopefully a star point and at the centre of the boundary. If we find a star point we then, for every point on the current boundary, push out in the direction defined by the line segment connecting the star point and the boundary to find the next confidence level boundary. If we do not find a star point, we assign each of the boundary points to the Kmeans point they are closest to (using a Euclidean distance metric), and use the direction defined by the line segments between a boundary point and it's associated Kmeans point to find the next confidence level boundary. This direction heuristic is carried out by refine_search_directions!. A traveling salesman heuristic is used to reorder the boundary points into a new minimum perimeter polygon, PlaceholderLikelihood.minimum_perimeter_polygon!, if the continuation of one boundary to the next causes the mapping of adjacent vertices to change (expected if a star point is not found). \n\nFor additional information on the ellipse_start_point_shift and ellipse_sqrt_distortion arguments see the keyword arguments for generate_N_clustered_points in EllipseSampling.jl.\n\nBoundary finding method\n\nUses a derivative-free 1D line search algorithm to find the boundary at subsequent confidence levels. If the derivative-free approach fails, it switches to a bracketing algorithm between a given boundary point and the point on the user-provided bounds in the search direction.\n\nThis method is unlikely to find boundaries that do not contain the MLE point (if they exist).\n\nInternal Points\n\nFinds num_points * num_level_sets internal points at distinct level sets.\n\nSupertype Hiearachy\n\nContinuationMethod <: AbstractBivariateMethod <: Any\n\n\n\n\n\n","category":"type"},{"location":"quick_start/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"user_interface/plots/#Plots","page":"Plots","title":"Plots","text":"","category":"section"},{"location":"user_interface/plots/#Univariate-Profiles","page":"Plots","title":"Univariate Profiles","text":"","category":"section"},{"location":"user_interface/plots/","page":"Plots","title":"Plots","text":"plot_univariate_profiles\nplot_univariate_profiles_comparison","category":"page"},{"location":"user_interface/plots/#Bivariate-Profiles-and-Samples","page":"Plots","title":"Bivariate Profiles and Samples","text":"","category":"section"},{"location":"user_interface/plots/","page":"Plots","title":"Plots","text":"plot_bivariate_profiles\nplot_bivariate_profiles_comparison\nplot_bivariate_profiles_iterativeboundary_gif","category":"page"},{"location":"user_interface/plots/#Predictions","page":"Plots","title":"Predictions","text":"","category":"section"},{"location":"user_interface/plots/","page":"Plots","title":"Plots","text":"plot_predictions_individual\nplot_predictions_union","category":"page"},{"location":"user_interface/plots/#PlaceholderLikelihood.plot_predictions_union","page":"Plots","title":"PlaceholderLikelihood.plot_predictions_union","text":"includelowerconfidence_levels is only used for 2d bivariate boundaries\n\n\n\n\n\n","category":"function"},{"location":"user_interface/profiles_and_samples/dimensional/","page":"Dimensional Samples","title":"Dimensional Samples","text":"Pages = [\"dimensional.md\"]","category":"page"},{"location":"user_interface/profiles_and_samples/dimensional/#Dimensional-Samples","page":"Dimensional Samples","title":"Dimensional Samples","text":"","category":"section"},{"location":"user_interface/profiles_and_samples/dimensional/","page":"Dimensional Samples","title":"Dimensional Samples","text":"We can generate samples within the loglikelihood boundary at any dimension of model interest parameters.","category":"page"},{"location":"user_interface/profiles_and_samples/dimensional/#Sample-Types","page":"Dimensional Samples","title":"Sample Types","text":"","category":"section"},{"location":"user_interface/profiles_and_samples/dimensional/","page":"Dimensional Samples","title":"Dimensional Samples","text":"AbstractSampleType\nUniformGridSamples\nUniformRandomSamples\nLatinHypercubeSamples","category":"page"},{"location":"user_interface/profiles_and_samples/dimensional/#PlaceholderLikelihood.AbstractSampleType","page":"Dimensional Samples","title":"PlaceholderLikelihood.AbstractSampleType","text":"AbstractSampleType\n\nSupertype for sample types.\n\nSubtypes\n\nUniformGridSamples\n\nUniformRandomSamples\n\nLatinHypercubeSamples\n\n\n\n\n\n","category":"type"},{"location":"user_interface/profiles_and_samples/dimensional/#PlaceholderLikelihood.UniformGridSamples","page":"Dimensional Samples","title":"PlaceholderLikelihood.UniformGridSamples","text":"UniformGridSamples()\n\nEvaluate the parameter bounds space on a uniform grid and keep samples that are inside the particular profile_type's boundary. \n\nSupertype Hiearachy\n\nUniformGridSamples <: AbstractSampleType <: Any\n\n\n\n\n\n","category":"type"},{"location":"user_interface/profiles_and_samples/dimensional/#PlaceholderLikelihood.UniformRandomSamples","page":"Dimensional Samples","title":"PlaceholderLikelihood.UniformRandomSamples","text":"UniformRandomSamples()\n\nTake uniform random samples of parameter bounds space and keep samples that are inside the particular profile_type's boundary. \n\nSupertype Hiearachy\n\nUniformRandomSamples <: AbstractSampleType <: Any\n\n\n\n\n\n","category":"type"},{"location":"user_interface/profiles_and_samples/dimensional/#PlaceholderLikelihood.LatinHypercubeSamples","page":"Dimensional Samples","title":"PlaceholderLikelihood.LatinHypercubeSamples","text":"LatinHypercubeSamples()\n\nCreate a Latin Hypercube sampling plan in parameter bounds space and keep samples that are inside the particular profile_type's boundary. Uses LatinHypercubeSampling.jl.\n\nSupertype Hiearachy\n\nLatinHypercubeSamples <: AbstractSampleType <: Any\n\n\n\n\n\n","category":"type"},{"location":"user_interface/profiles_and_samples/dimensional/#Full-Likelihood-Sampling","page":"Dimensional Samples","title":"Full Likelihood Sampling","text":"","category":"section"},{"location":"user_interface/profiles_and_samples/dimensional/","page":"Dimensional Samples","title":"Dimensional Samples","text":"full_likelihood_sample!","category":"page"},{"location":"user_interface/profiles_and_samples/dimensional/#PlaceholderLikelihood.full_likelihood_sample!","page":"Dimensional Samples","title":"PlaceholderLikelihood.full_likelihood_sample!","text":"full_likelihood_sample!(model::LikelihoodModel,\n    num_points_to_sample::Union{Int, Vector{Int}};\n    confidence_level::Float64=0.95,\n    sample_type::AbstractSampleType=LatinHypercubeSamples(),\n    lb::AbstractVector{<:Real}=Float64[],\n    ub::AbstractVector{<:Real}=Float64[],\n    use_threads::Bool=true,\n    existing_profiles::Symbol=:overwrite)\n\n\n\n\n\n","category":"function"},{"location":"user_interface/profiles_and_samples/dimensional/#Dimensional-Likelihood-Sampling","page":"Dimensional Samples","title":"Dimensional Likelihood Sampling","text":"","category":"section"},{"location":"user_interface/profiles_and_samples/dimensional/","page":"Dimensional Samples","title":"Dimensional Samples","text":"Note: dimensional likelihood samples can be 'full' likelihood samples as well.","category":"page"},{"location":"user_interface/profiles_and_samples/dimensional/","page":"Dimensional Samples","title":"Dimensional Samples","text":"dimensional_likelihood_sample!\nbivariate_concave_hull","category":"page"},{"location":"user_interface/profiles_and_samples/dimensional/#PlaceholderLikelihood.dimensional_likelihood_sample!","page":"Dimensional Samples","title":"PlaceholderLikelihood.dimensional_likelihood_sample!","text":"dimensional_likelihood_sample!(model::LikelihoodModel,\n    θindices::Vector{Vector{Int}},\n    num_points_to_sample::Union{Int, Vector{Int}};\n    confidence_level::Float64=0.95,\n    sample_type::AbstractSampleType=LatinHypercubeSamples(),\n    lb::AbstractVector{<:Real}=Float64[],\n    ub::AbstractVector{<:Real}=Float64[],\n    θs_is_unique::Bool=false,\n    use_threads::Bool=true,\n    existing_profiles::Symbol=:overwrite,\n    show_progress::Bool=model.show_progress)\n\n\n\n\n\n","category":"function"},{"location":"user_interface/predictions/","page":"Predictions","title":"Predictions","text":"Pages = [\"predictions.md\"]","category":"page"},{"location":"user_interface/predictions/#Predictions","page":"Predictions","title":"Predictions","text":"","category":"section"},{"location":"user_interface/predictions/","page":"Predictions","title":"Predictions","text":"In the event that a prediction function has not been added to the LikelihoodModel struct yet, we can add one using add_prediction_function!","category":"page"},{"location":"user_interface/predictions/","page":"Predictions","title":"Predictions","text":"add_prediction_function!\ncheck_prediction_function_exists","category":"page"},{"location":"user_interface/predictions/","page":"Predictions","title":"Predictions","text":"Then to generate predictions we can use one of three functions, depending on whether we want to generate predictions from univariate or bivariate profiles, or dimensional samples.","category":"page"},{"location":"user_interface/predictions/","page":"Predictions","title":"Predictions","text":"generate_predictions_univariate!\ngenerate_predictions_bivariate! \ngenerate_predictions_dim_samples!","category":"page"},{"location":"user_interface/predictions/#PlaceholderLikelihood.generate_predictions_univariate!","page":"Predictions","title":"PlaceholderLikelihood.generate_predictions_univariate!","text":"\n\n\n\n","category":"function"},{"location":"user_interface/initialisation/","page":"Initialisation","title":"Initialisation","text":"Pages = [\"initialisation.md\"]","category":"page"},{"location":"user_interface/initialisation/#Initialisation","page":"Initialisation","title":"Initialisation","text":"","category":"section"},{"location":"user_interface/initialisation/","page":"Initialisation","title":"Initialisation","text":"LikelihoodModel\nCoreLikelihoodModel\nEllipseMLEApprox\ninitialiseLikelihoodModel","category":"page"},{"location":"user_interface/initialisation/#PlaceholderLikelihood.LikelihoodModel","page":"Initialisation","title":"PlaceholderLikelihood.LikelihoodModel","text":"LikelihoodModel(core::CoreLikelihoodModel, ellipse_MLE_approx::Union{Missing,EllipseMLEApprox},\n    num_uni_profiles::Int, num_biv_profiles::Int, num_dim_samples::Int, \n    uni_profiles_df::DataFrame, biv_profiles_df::DataFrame, dim_samples_df::DataFrame, \n    uni_profile_row_exists::Dict{Tuple{Int,AbstractProfileType},DefaultDict{Float64,Int}},\n    biv_profile_row_exists::Dict{Tuple{Tuple{Int,Int},AbstractProfileType,AbstractBivariateMethod},DefaultDict{Float64,Int}},\n    dim_samples_row_exists::Dict{Union{AbstractSampleType,Tuple{Vector{Int},AbstractSampleType}},DefaultDict{Float64,Int}},\n    uni_profiles_dict::Dict{Int,UnivariateConfidenceStruct}, biv_profiles_dict::Dict{Int,BivariateConfidenceStruct}, dim_samples_dict::Dict{Int,SampledConfidenceStruct},\n    uni_predictions_dict::Dict{Int,AbstractPredictionStruct}, biv_predictions_dict::Dict{Int,AbstractPredictionStruct}, dim_predictions_dict::Dict{Int,AbstractPredictionStruct},\n    show_progress::Bool)\n\nStruct containing all the information required to compute profiles, samples and predictions. Created by initialiseLikelihoodModel.\n\nFields\n\ncore: a [CoreLikelihoodModel] struct.\nellipse_MLE_approx: a [EllipseMLEApprox] struct OR a missing value if the ellipse approximation of the loglikelihood at the MLE point has not been evaluated yet. \nnum_uni_profiles: the number of different univariate profiles that have been evaluated (distinct combinations of different confidence levels, AbstractProfileType structs and single interest parameters). Specifies the number of valid rows in uni_profiles_df.  \nnum_biv_profiles: the number of different bivariate profiles that have been evaluated (distinct combinations of different confidence levels, AbstractProfileType structs, AbstractBivariateMethod structs and two interest parameters). Specifies the number of valid rows in biv_profiles_df.  \nnum_dim_samples: the number of different dimensional profiles that have been evaluated (distinct combinations of different confidence levels, AbstractProfileType structs, AbstractSampleType structs and sets of interest parameters). Specifies the number of valid rows in dim_samples_df.  \nuni_profiles_df: a DataFrame with each row containing information on each univariate profile evaluated, where the row index is the key for that profile in uni_profiles_dict and uni_predictions_dict.\nbiv_profiles_df: a DataFrame with each row containing information on each bivariate profile evaluated, where the row index is the key for that profile in biv_profiles_dict and biv_predictions_dict.\ndim_samples_df: a DataFrame with each row containing information on each dimensional sample evaluated, where the row index is the key for that sample in dim_samples_dict and dim_predictions_dict.\nuni_profile_row_exists: a dictionary containing information on whether a row in uni_profiles_df exists for a given combination of interest parameter, AbstractProfileType and confidence level. If it does exist, it's value will be the row index in uni_profiles_df otherwise it will be 0.\nbiv_profile_row_exists: a dictionary containing information on whether a row in biv_profiles_df exists for a given combination of two interest parameters, AbstractProfileType, AbstractBivariateMethod and confidence level. If it does exist, it's value will be the row index in biv_profiles_df otherwise it will be 0.\ndim_samples_row_exists: a dictionary containing information on whether a row in dim_samples_df exists for a given combination of interest parameter, AbstractProfileType, AbstractSampleType and confidence level. If it does exist, it's value will be the row index in dim_samples_df otherwise it will be 0.\nuni_profiles_dict: a dictionary with keys of type Integer and values of type [UnivariateConfidenceStruct] containing the profile for each valid row in uni_profiles_df. The row index of uni_profiles_df is the key for the corresponding profile.\nbiv_profiles_dict: a dictionary with keys of type Integer and values of type [BivariateConfidenceStruct] containing the profile for each valid row in biv_profiles_df. The row index of biv_profiles_df is the key for the corresponding profile.\ndim_samples_dict: a dictionary with keys of type Integer and values of type [SampledConfidenceStruct] containing the profile for each valid row in dim_samples_df. The row index of dim_samples_df is the key for the corresponding profile.\nuni_predictions_dict: a dictionary with keys of type Integer and values of type PredictionStruct containing the predictions from the profiles in uni_profiles_dict for each valid row in uni_profiles_df. The row index of uni_profiles_df is the key for the corresponding prediction, if that prediction has been calculated using generate_predictions_univariate!. \nbiv_predictions_dict: a dictionary with keys of type Integer and values of type PredictionStruct containing the predictions from the profiles in biv_profiles_dict for each valid row in biv_profiles_df. The row index of biv_profiles_df is the key for the corresponding prediction, if that prediction has been calculated using generate_predictions_bivariate!. \ndim_predictions_dict: a dictionary with keys of type Integer and values of type PredictionStruct containing the predictions from the profiles in dim_samples_dict for each valid row in dim_samples_df. The row index of dim_samples_df is the key for the corresponding prediction, if that prediction has been calculated using generate_predictions_dim_samples!. \nshow_progress: a boolean specifying whether to show the progress of profile methods with respect to sets of interest parameter(s).\n\nSupertype Hiearachy\n\nLikelihoodModel <: Any\n\n\n\n\n\n","category":"type"},{"location":"user_interface/initialisation/#PlaceholderLikelihood.CoreLikelihoodModel","page":"Initialisation","title":"PlaceholderLikelihood.CoreLikelihoodModel","text":"CoreLikelihoodModel(loglikefunction::Function, predictfunction::Union{Function,Missing}, \n    data::Union{Tuple,NamedTuple}, θnames::Vector{<:Symbol}, θname_to_index::Dict{Symbol,Int}, \n    θlb::AbstractVector{<:Real}, θub::AbstractVector{<:Real}, θmagnitudes::AbstractVector{<:Real}, \n    θmle::Vector{<:Float64}, ymle::Array{<:Real}, maximisedmle::Float64, num_pars::Int)\n\nStruct containing the core information required to define a LikelihoodModel. For additional information on parameters (where repeated), see initialiseLikelihoodModel.\n\nFields\n\nloglikefunction: a loglikelihood function which takes two arguments, θ and data, in that order.\npredictfunction: a prediction function to generate model predictions from that is paired with the loglikefunction. \ndata: a Tuple or a NamedTuple containing any additional information required by the loglikelihood function, such as the time points to be evaluated at.\nθnames: a vector of symbols containing the names of each parameter, e.g. [:λ, :K, :C0].\nθname_to_index: a dictionary with keys of type Symbol and values of type Int, with the key being an element of θnames and the value being the corresponding index of the key in θnames.\nθlb: a vector of lower bounds on parameters. \nθub: a vector of upper bounds on parameters. \nθmagnitudes: a vector of the relative magnitude of each parameter. \nθmle: a vector containing the maximum likelihood estimate for each parameter.\nymle: an array containing the output of the prediction function at θmle and data.\nmaximisedmle: the value of the loglikelihood function evaluated at θmle.\nnum_pars: the number of model parameters, length(θnames).\n\nSupertype Hiearachy\n\nCoreLikelihoodModel <: Any\n\n\n\n\n\n","category":"type"},{"location":"user_interface/initialisation/#PlaceholderLikelihood.EllipseMLEApprox","page":"Initialisation","title":"PlaceholderLikelihood.EllipseMLEApprox","text":"EllipseMLEApprox(Hmle::Matrix{<:Float64}, Γmle::Matrix{<:Float64})\n\nStruct containing two n*n arrays representing the ellipse approximation of the loglikelihood function around the MLE point. See getMLE_ellipse_approximation!\n\nFields\n\nHmle: a n*n array, where n is the number of model parameters, containing the negative Hessian of the loglikelihood function evaluated at the MLE point. \nΓmle: a n*n array, where n is the number of model parameters, containing the inverse of Hmle.\n\nSupertype Hiearachy\n\nEllipseMLEApprox <: Any\n\n\n\n\n\n","category":"type"},{"location":"user_interface/initialisation/#PlaceholderLikelihood.initialiseLikelihoodModel","page":"Initialisation","title":"PlaceholderLikelihood.initialiseLikelihoodModel","text":"initialiseLikelihoodModel(loglikefunction::Function,\n    predictfunction::Union{Function, Missing},\n    data::Union{Tuple, NamedTuple},\n    θnames::Vector{<:Symbol},\n    θinitialGuess::AbstractVector{<:Real},\n    θlb::AbstractVector{<:Real},\n    θub::AbstractVector{<:Real},\n    θmagnitudes::AbstractVector{<:Real}=Float64[];\n    uni_row_prealloaction_size=NaN,\n    biv_row_preallocation_size=NaN,\n    dim_row_preallocation_size=NaN,\n    show_progress=true)\n\nInitialises a LikelihoodModel struct, which contains all model information, profiles, samples and predictions.\n\nArguments\n\nloglikefunction: a loglikelihood function which takes two arguments, θ and data, in that order, where θ is a vector containing the values of each parameter in θnames and data is a Tuple or NamedTuple - see data below.\npredictfunction: a prediction function to generate model predictions from that is paired with the loglikefunction. Takes three arguments, θ, data and t, in that order, where θ and data are the same as for loglikefunction and t needs to be an optional third argument. When t is not specified, the prediction function should be evaluated for the same time points/independent variable as the data. When t is specified, the prediction function should be evaluated for those specified time points/independent variable. It can also be missing if no function is provided during model initialisation, because predictions are not required when evaluating parameter profiles. The function can be added at a later point using add_prediction_function!.\ndata: a Tuple or a NamedTuple containing any additional information required by the loglikelihood function, such as the time points to be evaluated at.\nθnames: a vector of symbols containing the names of each parameter, e.g. [:λ, :K, :C0].\nθinitialguess: a vector containing the initial guess for the values of each parameter. Used to find the MLE point.\nθlb: a vector of lower bounds on parameters. \nθub: a vector of upper bounds on parameters. \nθmagnitudes: a vector of the relative magnitude of each parameter. If not provided, it will be estimated using the difference of θlb and θub using PlaceholderLikelihood.calculate_θmagnitudes. Can be updated after initialisation using setθmagnitudes!.\n\nTO DO OTHER ARGUMENTS\n\n\n\n\n\ninitialiseLikelihoodModel(loglikefunction::Function,\n    data::Union{Tuple, NamedTuple},\n    θnames::Vector{<:Symbol},\n    θinitialGuess::Vector{<:Float64},\n    θlb::Vector{<:Float64},\n    θub::Vector{<:Float64},\n    θmagnitudes::Vector{<:Real}=zeros(0);\n    uni_row_prealloaction_size=NaN,\n    biv_row_preallocation_size=NaN,\n    dim_row_preallocation_size=NaN)\n\nAlternate version of initialiseLikelihoodModel that can be called without a prediction function. The function can be added at a later point using add_prediction_function!.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/initialisation/#Parameter-Transformations","page":"Initialisation","title":"Parameter Transformations","text":"","category":"section"},{"location":"user_interface/initialisation/","page":"Initialisation","title":"Initialisation","text":"transformbounds\ntransformbounds_NLopt","category":"page"},{"location":"user_interface/initialisation/#PlaceholderLikelihood.transformbounds","page":"Initialisation","title":"PlaceholderLikelihood.transformbounds","text":"parameters are vectors of ints - i.e. call using vectors of ints directly or look up position of parameter from a symbol vector using a lookup table. Note. we assume that ordering remains the same. A 'independentParameter' is one where the new parameter Θ[i] depends only on f(θ[i]). A 'dependentParameter' is one where the new parameter Θ[i] depends on f(θ[i], θ[j], j!=i)\n\nI suspect that the dependentParameter heuristic may fail if there are multiple local minima - a binary integer  programme may be required instead (however, integer requirement on variables can be relaxed)\n\nONLY VALID FOR MONOTONIC (increasing or decreasing) TRANSFORMATIONS OF VARIABLES\n\n\n\n\n\n","category":"function"},{"location":"user_interface/initialisation/#PlaceholderLikelihood.transformbounds_NLopt","page":"Initialisation","title":"PlaceholderLikelihood.transformbounds_NLopt","text":"transformbounds_NLopt(transformfun::Function, lb::AbstractVector{<:Real}, ub::AbstractVector{<:Real})\n\n\n\n\n\n","category":"function"},{"location":"user_interface/initialisation/#Optimisation-of-Nuisance-Parameters","page":"Initialisation","title":"Optimisation of Nuisance Parameters","text":"","category":"section"},{"location":"user_interface/initialisation/","page":"Initialisation","title":"Initialisation","text":"This is presently done using a predefined NLopt optimiser. ","category":"page"},{"location":"user_interface/initialisation/","page":"Initialisation","title":"Initialisation","text":"optimise\noptimise_unbounded","category":"page"},{"location":"user_interface/initialisation/#PlaceholderLikelihood.optimise","page":"Initialisation","title":"PlaceholderLikelihood.optimise","text":"optimise(fun, θ₀, lb, ub;\n    dv = false, method = dv ? :LD_LBFGS : :LN_BOBYQA)\n\nNLopt optimiser used for calculating the values of nuisance parameters.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/initialisation/#PlaceholderLikelihood.optimise_unbounded","page":"Initialisation","title":"PlaceholderLikelihood.optimise_unbounded","text":"optimise_unbounded(fun, θ₀;\n    dv = false, method = dv ? :LD_LBFGS : :LN_BOBYQA)\n\nAlternative version of optimise without nuisance parameter bounds. Used for computing the nuisance parameters of EllipseApproxAnalytical profiles.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/profiles_and_samples/profile_structs/","page":"Structs and Profile Types","title":"Structs and Profile Types","text":"Pages = [\"profile_structs.md\"]","category":"page"},{"location":"user_interface/profiles_and_samples/profile_structs/#Structs-and-Profile-Types","page":"Structs and Profile Types","title":"Structs and Profile Types","text":"","category":"section"},{"location":"user_interface/profiles_and_samples/profile_structs/#Structs","page":"Structs and Profile Types","title":"Structs","text":"","category":"section"},{"location":"user_interface/profiles_and_samples/profile_structs/","page":"Structs and Profile Types","title":"Structs and Profile Types","text":"PointsAndLogLikelihood\nAbstractConfidenceStruct\nUnivariateConfidenceStruct\nBivariateConfidenceStruct\nSampledConfidenceStruct","category":"page"},{"location":"user_interface/profiles_and_samples/profile_structs/#PlaceholderLikelihood.PointsAndLogLikelihood","page":"Structs and Profile Types","title":"PlaceholderLikelihood.PointsAndLogLikelihood","text":"PointsAndLogLikelihood(points::Array{Float64}, ll::Vector{<:Float64}, boundary_col_indices::Vector{<:Int64}=zeros(Int, 0)))\n\nStruct that stores an array of parameter points, their corresponding loglikelihood value and, in the case of univariate profiles, the column indices in points of the confidence interval parameters.\n\nFields\n\npoints: an array of points stored in columns, with each row corresponding to the respective index of each model parameter. For the UnivariateConfidenceStruct type, these points are stored in column-wise order of increasing interest parameter magnitude. For the BivariateConfidenceStruct type these points are stored in the order they are found. \nll: a vector of loglikelihood function values corresponding to the point in each column of points. This number is standardised so that regardless of whether the true loglikelihood function or an ellipse approximation of the function is evaluated, the value of the MLE point is 0.0. \nboundary_col_indices: a vector that is empty for the BivariateConfidenceStruct type and of length two for the UnivariateConfidenceStruct type. Contains the column indices in points of the confidence interval parameters for the UnivariateConfidenceStruct type. Default is an empty vector.\n\n\n\n\n\n","category":"type"},{"location":"user_interface/profiles_and_samples/profile_structs/#PlaceholderLikelihood.AbstractConfidenceStruct","page":"Structs and Profile Types","title":"PlaceholderLikelihood.AbstractConfidenceStruct","text":"AbstractConfidenceStruct\n\nSupertype for confidence boundary storage structs.\n\nSubtypes\n\nUnivariateConfidenceStruct\n\nBivariateConfidenceStruct\n\nSampledConfidenceStruct\n\n\n\n\n\n","category":"type"},{"location":"user_interface/profiles_and_samples/profile_structs/#PlaceholderLikelihood.UnivariateConfidenceStruct","page":"Structs and Profile Types","title":"PlaceholderLikelihood.UnivariateConfidenceStruct","text":"UnivariateConfidenceStruct(confidence_interval::Vector{<:Float64}, interval_points::PointsAndLogLikelihood)\n\nStruct that stores the confidence interval of a given interest parameter as well as points sampled within (and outside) the confidence interval and their corresponding loglikelihood values.\n\nFields\n\nconfidence_interval: a vector of length two with the confidence interval for a given interest parameter. If an entry has value NaN, that side of the confidence interval is outside the corresponding bound on the interest parameter.\ninterval_points: a PointsAndLogLikelihood struct containing any points that have been evaluated inside or outside the interval by get_points_in_interval!, their corresponding loglikelihood function value and the column indices of the confidence_interval points in interval_points.points. Points can be evaluated and stored that are outside the confidence interval so that loglikelihood profile plots are defined outside of the confidence interval. interval_points.points is stored in column-wise order of increasing interest parameter magnitude. \n\nSupertype Hiearachy\n\nUnivariateConfidenceStruct <: AbstractConfidenceStruct <: Any\n\n\n\n\n\n","category":"type"},{"location":"user_interface/profiles_and_samples/profile_structs/#PlaceholderLikelihood.BivariateConfidenceStruct","page":"Structs and Profile Types","title":"PlaceholderLikelihood.BivariateConfidenceStruct","text":"BivariateConfidenceStruct(confidence_boundary::Matrix{Float64}, internal_points::PointsAndLogLikelihood=PointsAndLogLikelihood(zeros(size(x, 1), 0), zeros(0)))\n\nStruct that stores samples produced by an AbstractBivariateMethod that are on the bivariate confidence boundary of two interest parameters at a given confidence level and, if save_internal_points=true, any internal points found during the method with their corresponding loglikelihood values. Use bivariate_methods() for a list of available methods (see bivariate_methods).\n\nFields\n\nconfidence_boundary: an array of boundary points stored in columns, with each row corresponding to the respective index of each model parameter. This array can contain points that are inside the bivariate confidence boundary if the method being used brackets between an internal point and a point on the user-provided bounds: these points will be on a user-provided parameter bound.\ninternal_points: a PointsAndLogLikelihood struct containing points and their corresponding loglikelihood values that were found during a method, if save_internal_points=true. Default is an empty PointsAndLogLikelihood struct (used if save_internal_points=false).\n\nSupertype Hiearachy\n\nBivariateConfidenceStruct <: AbstractConfidenceStruct <: Any\n\n\n\n\n\n","category":"type"},{"location":"user_interface/profiles_and_samples/profile_structs/#PlaceholderLikelihood.SampledConfidenceStruct","page":"Structs and Profile Types","title":"PlaceholderLikelihood.SampledConfidenceStruct","text":"SampledConfidenceStruct(points::Array{Float64}, ll::Vector{<:Float64})\n\nStruct that stores samples produced by an AbstractSampleType that are within the confidence boundary of sample_dimension interest parameters at a given confidence level, with their corresponding loglikelihood values.\n\nFields\n\npoints: an array of points stored in columns, with each row corresponding to the respective index of each model parameter. \nll: a vector of loglikelihood function values corresponding to the point in each column of points. This number is standardised so that regardless of whether the true loglikelihood function or an ellipse approximation of the function is evaluated, the value of the MLE point is 0.0. \n\nSupertype Hiearachy\n\nSampledConfidenceStruct <: AbstractConfidenceStruct <: Any\n\n\n\n\n\n","category":"type"},{"location":"user_interface/profiles_and_samples/profile_structs/#Profile-Types","page":"Structs and Profile Types","title":"Profile Types","text":"","category":"section"},{"location":"user_interface/profiles_and_samples/profile_structs/","page":"Structs and Profile Types","title":"Structs and Profile Types","text":"Profile type is a Struct that specifies whether the profile to be taken uses the true loglikelihood function or an ellipse approximation of the loglikelihood function centred at the MLE (with optional use of parameter bounds).","category":"page"},{"location":"user_interface/profiles_and_samples/profile_structs/","page":"Structs and Profile Types","title":"Structs and Profile Types","text":"AbstractProfileType\nAbstractEllipseProfileType\nLogLikelihood\nEllipseApprox\nEllipseApproxAnalytical","category":"page"},{"location":"user_interface/profiles_and_samples/profile_structs/#PlaceholderLikelihood.AbstractProfileType","page":"Structs and Profile Types","title":"PlaceholderLikelihood.AbstractProfileType","text":"AbstractProfileType\n\nSupertype for profile types.\n\nSubtypes\n\nLogLikelihood\n\nAbstractEllipseProfileType\n\n\n\n\n\n","category":"type"},{"location":"user_interface/profiles_and_samples/profile_structs/#PlaceholderLikelihood.AbstractEllipseProfileType","page":"Structs and Profile Types","title":"PlaceholderLikelihood.AbstractEllipseProfileType","text":"AbstractProfileType\n\nSupertype for ellipse approximation profile types.\n\nSubtypes\n\nEllipseApprox\n\nEllipseApproxAnalytical\n\nSupertype Hiearachy\n\nAbstractProfileType <: AbstractProfileType <: Any\n\n\n\n\n\n","category":"type"},{"location":"user_interface/profiles_and_samples/profile_structs/#PlaceholderLikelihood.LogLikelihood","page":"Structs and Profile Types","title":"PlaceholderLikelihood.LogLikelihood","text":"LogLikelihood()\n\nUse the true loglikelihood function for confidence profile evaluation. The methods IterativeBoundaryMethod and RadialRandomMethod are recommended for use with this profile type.\n\nSupertype Hiearachy\n\nLogLikelihood <: AbstractProfileType <: Any\n\n\n\n\n\n","category":"type"},{"location":"user_interface/profiles_and_samples/profile_structs/#PlaceholderLikelihood.EllipseApprox","page":"Structs and Profile Types","title":"PlaceholderLikelihood.EllipseApprox","text":"EllipseApprox()\n\nUse an ellipse approximation of the loglikelihood function centred at the MLE with use of parameter bounds for confidence profile evaluation. The method RadialMLEMethod is recommended for use with this profile type.\n\nSupertype Hiearachy\n\nEllipseApprox <: AbstractEllipseProfileType <: AbstractProfileType <: Any\n\n\n\n\n\n","category":"type"},{"location":"user_interface/profiles_and_samples/profile_structs/#PlaceholderLikelihood.EllipseApproxAnalytical","page":"Structs and Profile Types","title":"PlaceholderLikelihood.EllipseApproxAnalytical","text":"EllipseApproxAnalytical()\n\nUse an ellipse approximation of the loglikelihood function centred at the MLE without use of parameter bounds for confidence profile evaluation. As no parameter bounds are involved, it can be analytically evaluated. The method AnalyticalEllipseMethod is recommended for use with this profile type - it analytically samples points on the confidence profile boundary using EllipseSampling.jl. Other methods can be used, but they will all be unable to find interest parameter points outside user-provided parameter bounds (although nuisance parameters will be allowed outside these bounds).\n\nSupertype Hiearachy\n\nEllipseApproxAnalytical <: AbstractEllipseProfileType <: AbstractProfileType <: Any\n\n\n\n\n\n","category":"type"},{"location":"user_interface/profiles_and_samples/univariate/","page":"Univariate Profiles","title":"Univariate Profiles","text":"Pages = [\"univariate.md\"]","category":"page"},{"location":"user_interface/profiles_and_samples/univariate/#Univariate-Profiles","page":"Univariate Profiles","title":"Univariate Profiles","text":"","category":"section"},{"location":"user_interface/profiles_and_samples/univariate/","page":"Univariate Profiles","title":"Univariate Profiles","text":"univariate_confidenceintervals!\nget_points_in_interval!","category":"page"},{"location":"user_interface/profiles_and_samples/univariate/#PlaceholderLikelihood.univariate_confidenceintervals!","page":"Univariate Profiles","title":"PlaceholderLikelihood.univariate_confidenceintervals!","text":"existing_profiles is what to do if existing profile of specified parameters exist ∈ :ignore, overwrite \n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = PlaceholderLikelihood","category":"page"},{"location":"#PlaceholderLikelihood","page":"Home","title":"PlaceholderLikelihood","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for PlaceholderLikelihood.","category":"page"}]
}
