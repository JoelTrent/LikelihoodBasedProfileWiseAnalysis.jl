var documenterSearchIndex = {"docs":
[{"location":"internal_library/initialisation/#Initialisation","page":"Initialisation","title":"Initialisation","text":"","category":"section"},{"location":"internal_library/initialisation/","page":"Initialisation","title":"Initialisation","text":"Pages = [\"initialisation.md\"]","category":"page"},{"location":"internal_library/initialisation/","page":"Initialisation","title":"Initialisation","text":"PlaceholderLikelihood.init_uni_profiles_df\nPlaceholderLikelihood.init_biv_profiles_df\nPlaceholderLikelihood.init_dim_samples_df\nPlaceholderLikelihood.init_uni_profile_row_exists!\nPlaceholderLikelihood.init_biv_profile_row_exists!\nPlaceholderLikelihood.init_dim_samples_row_exists!","category":"page"},{"location":"internal_library/initialisation/#PlaceholderLikelihood.init_uni_profiles_df","page":"Initialisation","title":"PlaceholderLikelihood.init_uni_profiles_df","text":"init_uni_profiles_df(num_rows::Int; existing_largest_row::Int=0)\n\nInitialises the DataFrame of model.uni_profiles_df with num_rows initial rows. In the event that the DataFrame already exists and more rows are being added, keyword argument, existing_largest_row, will be the number of rows in the existing dataframe, so that values of row_ind when concatenating the DataFrames will increase in steps of 1.\n\n\n\n\n\n","category":"function"},{"location":"internal_library/initialisation/#PlaceholderLikelihood.init_biv_profiles_df","page":"Initialisation","title":"PlaceholderLikelihood.init_biv_profiles_df","text":"init_biv_profiles_df(num_rows::Int; existing_largest_row::Int=0)\n\nInitialises the DataFrame of model.biv_profiles_df with num_rows initial rows. In the event that the DataFrame already exists and more rows are being added, keyword argument, existing_largest_row, will be the number of rows in the existing dataframe, so that values of row_ind when concatenating the DataFrames will increase in steps of 1.\n\n\n\n\n\n","category":"function"},{"location":"internal_library/initialisation/#PlaceholderLikelihood.init_dim_samples_df","page":"Initialisation","title":"PlaceholderLikelihood.init_dim_samples_df","text":"init_dim_samples_df(num_rows::Int; existing_largest_row::Int=0)\n\nInitialises the DataFrame of model.dim_samples_df with num_rows initial rows. In the event that the DataFrame already exists and more rows are being added, keyword argument, existing_largest_row, will be the number of rows in the existing dataframe, so that values of row_ind when concatenating the DataFrames will increase in steps of 1.\n\n\n\n\n\n","category":"function"},{"location":"internal_library/initialisation/#PlaceholderLikelihood.init_uni_profile_row_exists!","page":"Initialisation","title":"PlaceholderLikelihood.init_uni_profile_row_exists!","text":"init_uni_profile_row_exists!(model::LikelihoodModel, \n    θs_to_profile::Vector{<:Int}, \n    profile_type::AbstractProfileType)\n\nInitialises the dictionary entry in model.uni_profile_row_exists for the key (θi, profile_type), where θi is an element of θs_to_profile, with a DefaultDict with key of type Float64 (a confidence level) and default value of 0.\n\n\n\n\n\n","category":"function"},{"location":"internal_library/initialisation/#PlaceholderLikelihood.init_biv_profile_row_exists!","page":"Initialisation","title":"PlaceholderLikelihood.init_biv_profile_row_exists!","text":"init_biv_profile_row_exists!(model::LikelihoodModel, \n    θcombinations::Vector{Vector{Int}}, \n    profile_type::AbstractProfileType, \n    method::AbstractBivariateMethod)\n\nInitialises the dictionary entry in model.biv_profile_row_exists for the key ((ind1, ind2), profile_type, method), where (ind1, ind2) is a combination in θcombinations, with a DefaultDict with key of type Float64 (a confidence level) and default value of 0.\n\n\n\n\n\n","category":"function"},{"location":"internal_library/initialisation/#PlaceholderLikelihood.init_dim_samples_row_exists!","page":"Initialisation","title":"PlaceholderLikelihood.init_dim_samples_row_exists!","text":"init_dim_samples_row_exists!(model::LikelihoodModel, \n    sample_type::AbstractSampleType)\n\nInitialises the dictionary entry in model.dim_samples_row_exists for the key (sample_type) with a DefaultDict with key of type Float64 (a confidence level) and default value of 0. For a full likelihood sample (dimension equal to the number of model parameters).\n\n\n\n\n\ninit_dim_samples_row_exists!(model::LikelihoodModel, \n    θindices::Vector{Vector{Int}}, \n    sample_type::AbstractSampleType)\n\nInitialises the dictionary entry in model.dim_samples_row_exists for the key (θvec, sample_type), where θvec is a vector in θindices, with a DefaultDict with key of type Float64 (a confidence level) and default value of 0. For a non-full likelihood sample (dimension less than the number of model parameters).\n\n\n\n\n\n","category":"function"},{"location":"internal_library/initialisation/#Estimating-Parameter-Magnitudes-and-Bounds","page":"Initialisation","title":"Estimating Parameter Magnitudes and Bounds","text":"","category":"section"},{"location":"internal_library/initialisation/","page":"Initialisation","title":"Initialisation","text":"PlaceholderLikelihood.calculate_θmagnitudes","category":"page"},{"location":"internal_library/initialisation/#PlaceholderLikelihood.calculate_θmagnitudes","page":"Initialisation","title":"PlaceholderLikelihood.calculate_θmagnitudes","text":"calculate_θmagnitudes(θlb::Vector{<:Float64}, θub::Vector{<:Float64})\n\nEstimates the magnitude for each parameter using the difference between parameter bounds. If a bound is an Inf, the value is set to NaN. Values are divided by the minimum estimated magnitude such that the returned magnitudes have a lowest value of 1.0.\n\n\n\n\n\n","category":"function"},{"location":"internal_library/initialisation/#Parameter-Transformations","page":"Initialisation","title":"Parameter Transformations","text":"","category":"section"},{"location":"internal_library/initialisation/","page":"Initialisation","title":"Initialisation","text":"PlaceholderLikelihood.checkforInf","category":"page"},{"location":"internal_library/initialisation/#PlaceholderLikelihood.checkforInf","page":"Initialisation","title":"PlaceholderLikelihood.checkforInf","text":"checkforInf(x::AbstractVector{<:Real})\n\nWarns via a message if any of the bounds returned given the provided forward transformation are +/-Inf.\n\nArguments\n\nx: vector of transformed bounds. \n\n\n\n\n\n","category":"function"},{"location":"internal_library/plots/#Plotting-Functions","page":"Plotting Functions","title":"Plotting Functions","text":"","category":"section"},{"location":"internal_library/plots/","page":"Plotting Functions","title":"Plotting Functions","text":"Pages = [\"plots.md\"]","category":"page"},{"location":"internal_library/plots/#Helper-Functions","page":"Plotting Functions","title":"Helper Functions","text":"","category":"section"},{"location":"internal_library/plots/","page":"Plotting Functions","title":"Plotting Functions","text":"PlaceholderLikelihood.profilecolor\nPlaceholderLikelihood.profile1Dlinestyle\nPlaceholderLikelihood.profile2Dmarkershape\nPlaceholderLikelihood.θs_to_plot_typeconversion\nPlaceholderLikelihood.θcombinations_to_plot_typeconversion","category":"page"},{"location":"internal_library/plots/#Plots","page":"Plotting Functions","title":"Plots","text":"","category":"section"},{"location":"internal_library/plots/","page":"Plotting Functions","title":"Plotting Functions","text":"PlaceholderLikelihood.plot1Dprofile!\nPlaceholderLikelihood.addMLEandLLstar!\nPlaceholderLikelihood.plot2Dboundary!\nPlaceholderLikelihood.addMLE!\nPlaceholderLikelihood.plotprediction!\nPlaceholderLikelihood.add_yMLE!\nPlaceholderLikelihood.add_extrema!","category":"page"},{"location":"user_interface/profiles_and_samples/univariate/#Univariate-Profiles","page":"Univariate Profiles","title":"Univariate Profiles","text":"","category":"section"},{"location":"user_interface/profiles_and_samples/univariate/","page":"Univariate Profiles","title":"Univariate Profiles","text":"Pages = [\"univariate.md\"]","category":"page"},{"location":"user_interface/profiles_and_samples/univariate/","page":"Univariate Profiles","title":"Univariate Profiles","text":"univariate_confidenceintervals!\nget_points_in_interval!\nget_uni_confidence_interval\nget_uni_confidence_interval_points","category":"page"},{"location":"user_interface/profiles_and_samples/univariate/#PlaceholderLikelihood.univariate_confidenceintervals!","page":"Univariate Profiles","title":"PlaceholderLikelihood.univariate_confidenceintervals!","text":"univariate_confidenceintervals!(model::LikelihoodModel, \n    θs_to_profile::Vector{<:Int64}=collect(1:model.core.num_pars); \n    <keyword arguments>)\n\nComputes likelihood-based confidence interval profiles for the provided θs_to_profile interest parameters, where θs_to_profile is a vector of Int corresponding to the parameter indexes in model.core.θnames. Saves these profiles by modifying model in place.\n\nArguments\n\nmodel: a LikelihoodModel containing model information, saved profiles and predictions.\nθs_to_profile: vector of parameters to profile, as a vector of model parameter indexes. Default is collect(1:model.core.num_pars), or all parameters.\n\nKeyword Arguments\n\nconfidence_level: a number ∈ (0.0, 1.0) for the confidence level to evaluate the confidence interval. Default is 0.95 (95%).\nprofile_type: whether to use the true log-likelihood function or an ellipse approximation of the log-likelihood function centred at the MLE (with optional use of parameter bounds). Available profile types are LogLikelihood, EllipseApprox and EllipseApproxAnalytical. Default is LogLikelihood() (LogLikelihood).\nuse_existing_profiles: boolean variable specifying whether to use existing profiles of a parameter θi to decrease the width of the bracket used to search for the desired confidence interval using PlaceholderLikelihood.get_interval_brackets. Default is false.\nθs_is_unique: boolean variable specifying whether all parameter indexes in θs_to_profile are ordered by parameter index (ascending) and unique. Default is false.\nnum_points_in_interval: an integer number of points to optionally evaluate within the confidence interval for each interest parameter using get_points_in_interval!. Points are linearly spaced in the interval and have their optimised log-likelihood value recorded. Useful for plots that visualise the confidence interval or for predictions from univariate profiles. Default is 0. \nadditional_width: a Real number greater than or equal to zero. Specifies the additional width to optionally evaluate outside the confidence interval's width if num_points_in_interval is greater than 0 using get_points_in_interval!. Half of this additional width will be placed on either side of the confidence interval. If the additional width goes outside a bound on the parameter, only up to the bound will be considered. The spacing of points in the additional width will try to match the spacing of points evaluated inside the interval. Useful for plots that visualise the confidence interval as it shows the trend of the log-likelihood profile outside the interval range. Default is 0.0.\nexisting_profiles: Symbol ∈ [:ignore, :overwrite] specifying what to do if profiles already exist for a given interest parameter, confidence_level and profile_type. See below for each symbol's meanings. Default is :merge.\nshow_progress: boolean variable specifying whether to display progress bars on the percentage of θs_to_profile completed and estimated time of completion. Default is model.show_progress.\n\nnote: existing_profiles meanings\n:ignore means profiles that already exist will not be recomputed. \n:overwrite means profiles that already exist will be overwritten.\n\nDetails\n\nUsing univariate_confidenceinterval this function uses a bracketing method for each interest parameter in θs_to_profile (depending on the setting for existing_profiles if these profiles already exist). Updates model.uni_profiles_df for each successful profile and saves their results as a UnivariateConfidenceStruct in model.uni_profiles_dict, where the keys for the dictionary is the row number in model.uni_profiles_df of the corresponding profile.\n\n\n\n\n\nunivariate_confidenceintervals!(model::LikelihoodModel, \n    θs_to_profile::Vector{<:Symbol}; \n    <keyword arguments>)\n\nProfiles only the provided θs_to_profile interest parameters, where θs_to_profile is a vector of Symbol corresponding to the parameter symbols in model.core.θnames.\n\n\n\n\n\nunivariate_confidenceintervals!(model::LikelihoodModel, \n    profile_m_random_combinations::Int; \n    <keyword arguments>)\n\nProfiles m random interest parameters (sampling without replacement), where 0 < m ≤ model.core.num_pars.\n\nwarning: θs_is_unique keyword argument\nθs_is_unique is not a valid keyword argument for this function method as it internally produces the parameter combinations which are guaranteed to be unique.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/profiles_and_samples/univariate/#PlaceholderLikelihood.get_points_in_interval!","page":"Univariate Profiles","title":"PlaceholderLikelihood.get_points_in_interval!","text":"get_points_in_interval!(model::LikelihoodModel, \n    num_points_in_interval::Int; \n    confidence_levels::Vector{<:Float64}=Float64[], \n    profile_types::Vector{<:AbstractProfileType}=AbstractProfileType[], \n    additional_width::Real=0.0)\n\nEvaluate and save num_points_in_interval linearly spaced points between the confidence intervals of existing univariate profiles that meet the requirements of PlaceholderLikelihood.desired_df_subset (see Keyword Arguments), as well as any additional width on the sides of the interval. Modifies model in place.\n\nArguments\n\nmodel: a LikelihoodModel containing model information, saved profiles and predictions.\nnum_points_in_interval: an integer number of points to evaluate within the confidence interval. Points are linearly spaced in the interval and have their optimised log-likelihood value recorded. Useful for plots that visualise the confidence interval or for predictions from univariate profiles. \n\nKeyword Arguments\n\nconfidence_levels: a vector of confidence levels or a Float64 of a single confidence level. If empty, all confidence levels of univariate profiles will be considered for finding interval points. Otherwise, only confidence levels of univariate profiles in confidence_levels will be considered.\nprofile_types: a vector of AbstractProfileType structs. If empty, all profile types of univariate profiles are considered. Otherwise, only univariate profiles with matching profile types will be considered.\nadditional_width: a Real number greater than or equal to zero. Specifies the additional width to optionally evaluate outside the confidence interval's width. Half of this additional width will be placed on either side of the confidence interval. If the additional width goes outside a bound on the parameter, only up to the bound will be considered. The spacing of points in the additional width will try to match the spacing of points evaluated inside the interval. Useful for plots that visualise the confidence interval as it shows the trend of the log-likelihood profile outside the interval range. Default is 0.0.\n\nDetails\n\nInterval points and their corresponding log-likelihood values are stored in the interval_points field of a UnivariateConfidenceStruct. These are updated using PlaceholderLikelihood.update_uni_dict_internal!.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/profiles_and_samples/univariate/#PlaceholderLikelihood.get_uni_confidence_interval","page":"Univariate Profiles","title":"PlaceholderLikelihood.get_uni_confidence_interval","text":"get_uni_confidence_interval(model::LikelihoodModel, uni_row_number::Int)\n\nReturns the confidence interval corresponding to the profile in row uni_row_number of model.uni_profiles_df as a vector of length two. If an entry has value NaN, that side of the confidence interval is outside the corresponding bound on the interest parameter.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/profiles_and_samples/univariate/#PlaceholderLikelihood.get_uni_confidence_interval_points","page":"Univariate Profiles","title":"PlaceholderLikelihood.get_uni_confidence_interval_points","text":"get_uni_confidence_interval_points(model::LikelihoodModel, uni_row_number::Int)\n\nReturns the interval points PointsAndLogLikelihood struct corresponding to the profile in row uni_row_number of model.uni_profiles_df.\n\n\n\n\n\n","category":"function"},{"location":"quick_start/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"note: Note\nTO DO","category":"page"},{"location":"user_interface/plots/#Plots","page":"Plots","title":"Plots","text":"","category":"section"},{"location":"user_interface/plots/","page":"Plots","title":"Plots","text":"Pages = [\"plots.md\"]","category":"page"},{"location":"user_interface/plots/#Univariate-Profiles","page":"Plots","title":"Univariate Profiles","text":"","category":"section"},{"location":"user_interface/plots/","page":"Plots","title":"Plots","text":"plot_univariate_profiles\nplot_univariate_profiles_comparison","category":"page"},{"location":"user_interface/plots/#Bivariate-Profiles-and-Samples","page":"Plots","title":"Bivariate Profiles and Samples","text":"","category":"section"},{"location":"user_interface/plots/","page":"Plots","title":"Plots","text":"plot_bivariate_profiles\nplot_bivariate_profiles_comparison\nplot_bivariate_profiles_iterativeboundary_gif","category":"page"},{"location":"user_interface/plots/#Predictions","page":"Plots","title":"Predictions","text":"","category":"section"},{"location":"user_interface/plots/","page":"Plots","title":"Plots","text":"plot_predictions_individual\nplot_predictions_union","category":"page"},{"location":"user_interface/plots/#PlaceholderLikelihood.plot_predictions_union","page":"Plots","title":"PlaceholderLikelihood.plot_predictions_union","text":"includelowerconfidence_levels is only used for 2d bivariate boundaries\n\n\n\n\n\n","category":"function"},{"location":"internal_library/predictions/#Prediction-Functions","page":"Prediction Functions","title":"Prediction Functions","text":"","category":"section"},{"location":"internal_library/predictions/","page":"Prediction Functions","title":"Prediction Functions","text":"Pages = [\"predictions.md\"]","category":"page"},{"location":"internal_library/predictions/","page":"Prediction Functions","title":"Prediction Functions","text":"PlaceholderLikelihood.generate_prediction\nPlaceholderLikelihood.generate_prediction_univariate\nPlaceholderLikelihood.generate_prediction_bivariate","category":"page"},{"location":"internal_library/predictions/#PlaceholderLikelihood.generate_prediction","page":"Prediction Functions","title":"PlaceholderLikelihood.generate_prediction","text":"If a model has multiple predictive variables, it assumes that model.predictfunction stores the prediction for each variable in its columns. We are going to store values for each variable in the 3rd dimension (row=dim1, col=dim2, page/sheet=dim3)\n\n\n\n\n\n","category":"function"},{"location":"user_interface/initialisation/#Initialisation","page":"Initialisation","title":"Initialisation","text":"","category":"section"},{"location":"user_interface/initialisation/","page":"Initialisation","title":"Initialisation","text":"Pages = [\"initialisation.md\"]","category":"page"},{"location":"user_interface/initialisation/","page":"Initialisation","title":"Initialisation","text":"initialiseLikelihoodModel\nLikelihoodModel\nCoreLikelihoodModel","category":"page"},{"location":"user_interface/initialisation/#PlaceholderLikelihood.initialiseLikelihoodModel","page":"Initialisation","title":"PlaceholderLikelihood.initialiseLikelihoodModel","text":"initialiseLikelihoodModel(loglikefunction::Function,\n    predictfunction::Union{Function, Missing},\n    data::Union{Tuple, NamedTuple},\n    θnames::Vector{<:Symbol},\n    θinitialGuess::AbstractVector{<:Real},\n    θlb::AbstractVector{<:Real},\n    θub::AbstractVector{<:Real},\n    θmagnitudes::AbstractVector{<:Real}=Float64[];\n    uni_row_prealloaction_size=NaN,\n    biv_row_preallocation_size=NaN,\n    dim_row_preallocation_size=NaN,\n    show_progress=true)\n\nInitialises a LikelihoodModel struct, which contains all model information, profiles, samples and predictions.\n\nArguments\n\nloglikefunction: a loglikelihood function which takes two arguments, θ and data, in that order, where θ is a vector containing the values of each parameter in θnames and data is a Tuple or NamedTuple - see data below.\npredictfunction: a prediction function to generate model predictions from that is paired with the loglikefunction. Takes three arguments, θ, data and t, in that order, where θ and data are the same as for loglikefunction and t needs to be an optional third argument. When t is not specified, the prediction function should be evaluated for the same time points/independent variable as the data. When t is specified, the prediction function should be evaluated for those specified time points/independent variable. It can also be missing if no function is provided to initialiseLikelihoodModel, because predictions are not required when evaluating parameter profiles. The function can be added at a later point using add_prediction_function!.\ndata: a Tuple or a NamedTuple containing any additional information required by the log-likelihood function, such as the time points to be evaluated at.\nθnames: a vector of symbols containing the names of each parameter, e.g. [:λ, :K, :C0].\nθinitialguess: a vector containing the initial guess for the values of each parameter. Used to find the MLE point.\nθlb: a vector of lower bounds on parameters. \nθub: a vector of upper bounds on parameters. \nθmagnitudes: a vector of the relative magnitude of each parameter. If not provided, it will be estimated using the difference of θlb and θub with PlaceholderLikelihood.calculate_θmagnitudes. Can be updated after initialisation using setθmagnitudes!.\n\nKeyword Arguments\n\nuni_row_prealloaction_size: number of rows of uni_profiles_df to preallocate. Default is NaN (a single row).\nbiv_row_preallocation_size:number of rows of biv_profiles_df to preallocate. Default is NaN (a single row).\ndim_row_preallocation_size: number of rows of dim_samples_df to preallocate. Default is NaN (a single row).\nshow_progress: Whether to show the progress of profiling across sets of interest parameters. \n\n\n\n\n\ninitialiseLikelihoodModel(loglikefunction::Function,\n    data::Union{Tuple, NamedTuple},\n    θnames::Vector{<:Symbol},\n    θinitialGuess::Vector{<:Float64},\n    θlb::Vector{<:Float64},\n    θub::Vector{<:Float64},\n    θmagnitudes::Vector{<:Real}=zeros(0);\n    uni_row_prealloaction_size=NaN,\n    biv_row_preallocation_size=NaN,\n    dim_row_preallocation_size=NaN,\n    show_progress=true)\n\nAlternate version of initialiseLikelihoodModel that can be called without a prediction function. The function can be added at a later point using add_prediction_function!.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/initialisation/#PlaceholderLikelihood.LikelihoodModel","page":"Initialisation","title":"PlaceholderLikelihood.LikelihoodModel","text":"LikelihoodModel(core::CoreLikelihoodModel, \n    ellipse_MLE_approx::Union{Missing, EllipseMLEApprox},\n    num_uni_profiles::Int, \n    num_biv_profiles::Int, \n    num_dim_samples::Int, \n    uni_profiles_df::DataFrame, \n    biv_profiles_df::DataFrame, \n    dim_samples_df::DataFrame, \n    uni_profile_row_exists::Dict{Tuple{Int, AbstractProfileType}, DefaultDict{Float64, Int}},\n    biv_profile_row_exists::Dict{Tuple{Tuple{Int, Int}, AbstractProfileType, AbstractBivariateMethod}, DefaultDict{Float64, Int}},\n    dim_samples_row_exists::Dict{Union{AbstractSampleType, Tuple{Vector{Int}, AbstractSampleType}}, DefaultDict{Float64, Int}},\n    uni_profiles_dict::Dict{Int, UnivariateConfidenceStruct}, \n    biv_profiles_dict::Dict{Int, BivariateConfidenceStruct}, \n    dim_samples_dict::Dict{Int, SampledConfidenceStruct},\n    uni_predictions_dict::Dict{Int, AbstractPredictionStruct}, \n    biv_predictions_dict::Dict{Int, AbstractPredictionStruct}, \n    dim_predictions_dict::Dict{Int, AbstractPredictionStruct},\n    show_progress::Bool)\n\nStruct containing all the information required to compute profiles, samples and predictions. Created by initialiseLikelihoodModel.\n\nFields\n\ncore: a [CoreLikelihoodModel] struct.\nellipse_MLE_approx: a [EllipseMLEApprox] struct OR a missing value if the ellipse approximation of the log-likelihood at the MLE point has not been evaluated yet. \nnum_uni_profiles: the number of different univariate profiles that have been evaluated (distinct combinations of different confidence levels, AbstractProfileType structs and single interest parameters). Specifies the number of valid rows in uni_profiles_df.  \nnum_biv_profiles: the number of different bivariate profiles that have been evaluated (distinct combinations of different confidence levels, AbstractProfileType structs, AbstractBivariateMethod structs and two interest parameters). Specifies the number of valid rows in biv_profiles_df.  \nnum_dim_samples: the number of different dimensional profiles that have been evaluated (distinct combinations of different confidence levels, AbstractProfileType structs, AbstractSampleType structs and sets of interest parameters). Specifies the number of valid rows in dim_samples_df.  \nuni_profiles_df: a DataFrame with each row containing information on each univariate profile evaluated, where the row index is the key for that profile in uni_profiles_dict and uni_predictions_dict.\nbiv_profiles_df: a DataFrame with each row containing information on each bivariate profile evaluated, where the row index is the key for that profile in biv_profiles_dict and biv_predictions_dict.\ndim_samples_df: a DataFrame with each row containing information on each dimensional sample evaluated, where the row index is the key for that sample in dim_samples_dict and dim_predictions_dict.\nuni_profile_row_exists: a dictionary containing information on whether a row in uni_profiles_df exists for a given combination of interest parameter, AbstractProfileType and confidence level. If it does exist, it's value will be the row index in uni_profiles_df otherwise it will be 0.\nbiv_profile_row_exists: a dictionary containing information on whether a row in biv_profiles_df exists for a given combination of two interest parameters, AbstractProfileType, AbstractBivariateMethod and confidence level. If it does exist, it's value will be the row index in biv_profiles_df otherwise it will be 0.\ndim_samples_row_exists: a dictionary containing information on whether a row in dim_samples_df exists for a given combination of interest parameter, AbstractProfileType, AbstractSampleType and confidence level. If it does exist, it's value will be the row index in dim_samples_df otherwise it will be 0.\nuni_profiles_dict: a dictionary with keys of type Integer and values of type [UnivariateConfidenceStruct] containing the profile for each valid row in uni_profiles_df. The row index of uni_profiles_df is the key for the corresponding profile.\nbiv_profiles_dict: a dictionary with keys of type Integer and values of type [BivariateConfidenceStruct] containing the profile for each valid row in biv_profiles_df. The row index of biv_profiles_df is the key for the corresponding profile.\ndim_samples_dict: a dictionary with keys of type Integer and values of type [SampledConfidenceStruct] containing the profile for each valid row in dim_samples_df. The row index of dim_samples_df is the key for the corresponding profile.\nuni_predictions_dict: a dictionary with keys of type Integer and values of type PredictionStruct containing the predictions from the profiles in uni_profiles_dict for each valid row in uni_profiles_df. The row index of uni_profiles_df is the key for the corresponding prediction, if that prediction has been calculated using generate_predictions_univariate!. \nbiv_predictions_dict: a dictionary with keys of type Integer and values of type PredictionStruct containing the predictions from the profiles in biv_profiles_dict for each valid row in biv_profiles_df. The row index of biv_profiles_df is the key for the corresponding prediction, if that prediction has been calculated using generate_predictions_bivariate!. \ndim_predictions_dict: a dictionary with keys of type Integer and values of type PredictionStruct containing the predictions from the profiles in dim_samples_dict for each valid row in dim_samples_df. The row index of dim_samples_df is the key for the corresponding prediction, if that prediction has been calculated using generate_predictions_dim_samples!. \nshow_progress: a boolean specifying whether to show the progress of profile methods with respect to sets of interest parameter(s).\n\nSupertype Hiearachy\n\nLikelihoodModel <: Any\n\n\n\n\n\n","category":"type"},{"location":"user_interface/initialisation/#PlaceholderLikelihood.CoreLikelihoodModel","page":"Initialisation","title":"PlaceholderLikelihood.CoreLikelihoodModel","text":"CoreLikelihoodModel(loglikefunction::Function, \n    predictfunction::Union{Function, Missing}, \n    data::Union{Tuple, NamedTuple}, \n    θnames::Vector{<:Symbol}, \n    θname_to_index::Dict{Symbol, Int}, \n    θlb::AbstractVector{<:Real}, \n    θub::AbstractVector{<:Real}, \n    θmagnitudes::AbstractVector{<:Real}, \n    θmle::Vector{<:Float64}, \n    ymle::Array{<:Real}, \n    maximisedmle::Float64, \n    num_pars::Int)\n\nStruct containing the core information required to define a LikelihoodModel. For additional information on parameters (where repeated), see initialiseLikelihoodModel.\n\nFields\n\nloglikefunction: a log-likelihood function which takes two arguments, θ and data, in that order.\npredictfunction: a prediction function to generate model predictions from that is paired with the loglikefunction. \ndata: a Tuple or a NamedTuple containing any additional information required by the log-likelihood function, such as the time points to be evaluated at.\nθnames: a vector of symbols containing the names of each parameter, e.g. [:λ, :K, :C0].\nθname_to_index: a dictionary with keys of type Symbol and values of type Int, with the key being an element of θnames and the value being the corresponding index of the key in θnames.\nθlb: a vector of lower bounds on parameters. \nθub: a vector of upper bounds on parameters. \nθmagnitudes: a vector of the relative magnitude of each parameter. \nθmle: a vector containing the maximum likelihood estimate for each parameter.\nymle: an array containing the output of the prediction function at θmle and data.\nmaximisedmle: the value of the log-likelihood function evaluated at θmle.\nnum_pars: the number of model parameters, length(θnames).\n\nSupertype Hiearachy\n\nCoreLikelihoodModel <: Any\n\n\n\n\n\n","category":"type"},{"location":"user_interface/initialisation/#Ellipse-Approximation","page":"Initialisation","title":"Ellipse Approximation","text":"","category":"section"},{"location":"user_interface/initialisation/","page":"Initialisation","title":"Initialisation","text":"getMLE_ellipse_approximation!\ncheck_ellipse_approx_exists!\nEllipseMLEApprox","category":"page"},{"location":"user_interface/initialisation/#PlaceholderLikelihood.EllipseMLEApprox","page":"Initialisation","title":"PlaceholderLikelihood.EllipseMLEApprox","text":"EllipseMLEApprox(Hmle::Matrix{<:Float64}, Γmle::Matrix{<:Float64})\n\nStruct containing two n*n arrays representing the ellipse approximation of the log-likelihood function around the MLE point. See getMLE_ellipse_approximation!\n\nFields\n\nHmle: a n*n array, where n is the number of model parameters, containing the negative Hessian of the log-likelihood function evaluated at the MLE point. \nΓmle: a n*n array, where n is the number of model parameters, containing the inverse of Hmle.\n\nSupertype Hiearachy\n\nEllipseMLEApprox <: Any\n\n\n\n\n\n","category":"type"},{"location":"user_interface/initialisation/#Modifying-Parameter-Magnitudes-and-Bounds","page":"Initialisation","title":"Modifying Parameter Magnitudes and Bounds","text":"","category":"section"},{"location":"user_interface/initialisation/","page":"Initialisation","title":"Initialisation","text":"setmagnitudes!\nsetbounds!","category":"page"},{"location":"user_interface/initialisation/#PlaceholderLikelihood.setmagnitudes!","page":"Initialisation","title":"PlaceholderLikelihood.setmagnitudes!","text":"setmagnitudes!(model::LikelihoodModel, θmagnitudes::AbstractVector{<:Real})\n\nUpdates the magnitudes of each parameter in model from model.core.θmagnitudes to θmagnitudes.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/initialisation/#PlaceholderLikelihood.setbounds!","page":"Initialisation","title":"PlaceholderLikelihood.setbounds!","text":"setbounds!(model::LikelihoodModel; \n    lb::AbstractVector{<:Real}=Float64[], \n    ub::AbstractVector{<:Real}=Float64[])\n\nUpdates the parameter bounds in model from model.core.θlb to lb if specified and from model.core.θub to ub if specified. lb and ub are keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/initialisation/#Parameter-Transformations","page":"Initialisation","title":"Parameter Transformations","text":"","category":"section"},{"location":"user_interface/initialisation/","page":"Initialisation","title":"Initialisation","text":"transformbounds\ntransformbounds_NLopt","category":"page"},{"location":"user_interface/initialisation/#PlaceholderLikelihood.transformbounds","page":"Initialisation","title":"PlaceholderLikelihood.transformbounds","text":"transformbounds(transformfun::Function, \n    lb::AbstractVector{<:Real}, \n    ub::AbstractVector{<:Real}, \n    independentParameterIndexes::Vector{<:Int}=Int[], \n    dependentParameterIndexes::Vector{<:Int}=Int[])\n\nparameters are vectors of ints - i.e. call using vectors of ints directly or look up position of parameter from a symbol vector using a lookup table. Note. we assume that ordering remains the same. A 'independentParameter' is one where the new parameter Θ[i] depends only on f(θ[i]). A 'dependentParameter' is one where the new parameter Θ[i] depends on f(θ[i], θ[j], j!=i).\n\nI suspect that the dependentParameter heuristic may fail if there are multiple local minima - a binary integer programme may be required instead (however, integer requirement on variables can be relaxed)\n\nONLY VALID FOR MONOTONIC (increasing or decreasing) TRANSFORMATIONS OF VARIABLES\n\n\n\n\n\n","category":"function"},{"location":"user_interface/initialisation/#PlaceholderLikelihood.transformbounds_NLopt","page":"Initialisation","title":"PlaceholderLikelihood.transformbounds_NLopt","text":"transformbounds_NLopt(transformfun::Function, \n    lb::AbstractVector{<:Real}, \n    ub::AbstractVector{<:Real})\n\n\n\n\n\n","category":"function"},{"location":"user_interface/initialisation/#Optimisation-of-Nuisance-Parameters","page":"Initialisation","title":"Optimisation of Nuisance Parameters","text":"","category":"section"},{"location":"user_interface/initialisation/","page":"Initialisation","title":"Initialisation","text":"This is presently done using a predefined NLopt optimiser. ","category":"page"},{"location":"user_interface/initialisation/","page":"Initialisation","title":"Initialisation","text":"optimise\noptimise_unbounded","category":"page"},{"location":"user_interface/initialisation/#PlaceholderLikelihood.optimise","page":"Initialisation","title":"PlaceholderLikelihood.optimise","text":"optimise(fun, θ₀, lb, ub;\n    dv = false, method = dv ? :LD_LBFGS : :LN_BOBYQA)\n\nNLopt optimiser used for calculating the values of nuisance parameters.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/initialisation/#PlaceholderLikelihood.optimise_unbounded","page":"Initialisation","title":"PlaceholderLikelihood.optimise_unbounded","text":"optimise_unbounded(fun, θ₀;\n    dv = false, method = dv ? :LD_LBFGS : :LN_BOBYQA)\n\nAlternative version of optimise without nuisance parameter bounds. Used for computing the nuisance parameters of EllipseApproxAnalytical profiles.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/profiles_and_samples/profile_structs/#Structs-and-Profile-Types","page":"Structs and Profile Types","title":"Structs and Profile Types","text":"","category":"section"},{"location":"user_interface/profiles_and_samples/profile_structs/","page":"Structs and Profile Types","title":"Structs and Profile Types","text":"Pages = [\"profile_structs.md\"]","category":"page"},{"location":"user_interface/profiles_and_samples/profile_structs/#Structs","page":"Structs and Profile Types","title":"Structs","text":"","category":"section"},{"location":"user_interface/profiles_and_samples/profile_structs/","page":"Structs and Profile Types","title":"Structs and Profile Types","text":"PointsAndLogLikelihood\nAbstractConfidenceStruct\nUnivariateConfidenceStruct\nBivariateConfidenceStruct\nSampledConfidenceStruct","category":"page"},{"location":"user_interface/profiles_and_samples/profile_structs/#PlaceholderLikelihood.PointsAndLogLikelihood","page":"Structs and Profile Types","title":"PlaceholderLikelihood.PointsAndLogLikelihood","text":"PointsAndLogLikelihood(points::Array{Float64}, \n    ll::Vector{<:Float64}, \n    boundary_col_indices::Vector{<:Int64}=zeros(Int, 0)))\n\nStruct that stores an array of parameter points, their corresponding log-likelihood value and, in the case of univariate profiles, the column indices in points of the confidence interval parameters.\n\nFields\n\npoints: an array of points stored in columns, with each row corresponding to the respective index of each model parameter. For the UnivariateConfidenceStruct type, these points are stored in column-wise order of increasing interest parameter magnitude. For the BivariateConfidenceStruct type these points are stored in the order they are found. \nll: a vector of log-likelihood function values corresponding to the point in each column of points. This number is standardised so that regardless of whether the true log-likelihood function or an ellipse approximation of the function is evaluated, the value of the MLE point is 0.0. \nboundary_col_indices: a vector that is empty for the BivariateConfidenceStruct type and of length two for the UnivariateConfidenceStruct type. Contains the column indices in points of the confidence interval parameters for the UnivariateConfidenceStruct type. Default is an empty vector.\n\n\n\n\n\n","category":"type"},{"location":"user_interface/profiles_and_samples/profile_structs/#PlaceholderLikelihood.AbstractConfidenceStruct","page":"Structs and Profile Types","title":"PlaceholderLikelihood.AbstractConfidenceStruct","text":"AbstractConfidenceStruct\n\nSupertype for confidence boundary storage structs.\n\nSubtypes\n\nUnivariateConfidenceStruct\n\nBivariateConfidenceStruct\n\nSampledConfidenceStruct\n\n\n\n\n\n","category":"type"},{"location":"user_interface/profiles_and_samples/profile_structs/#PlaceholderLikelihood.UnivariateConfidenceStruct","page":"Structs and Profile Types","title":"PlaceholderLikelihood.UnivariateConfidenceStruct","text":"UnivariateConfidenceStruct(confidence_interval::Vector{<:Float64}, \n    interval_points::PointsAndLogLikelihood)\n\nStruct that stores the confidence interval of a given interest parameter as well as points sampled within (and outside) the confidence interval and their corresponding log-likelihood values.\n\nFields\n\nconfidence_interval: a vector of length two with the confidence interval for a given interest parameter. If an entry has value NaN, that side of the confidence interval is outside the corresponding bound on the interest parameter.\ninterval_points: a PointsAndLogLikelihood struct containing any points that have been evaluated inside or outside the interval by get_points_in_interval!, their corresponding log-likelihood function value and the column indices of the confidence_interval points in interval_points.points. Points can be evaluated and stored that are outside the confidence interval so that log-likelihood profile plots are defined outside of the confidence interval. interval_points.points is stored in column-wise order of increasing interest parameter magnitude. \n\nSupertype Hiearachy\n\nUnivariateConfidenceStruct <: AbstractConfidenceStruct <: Any\n\n\n\n\n\n","category":"type"},{"location":"user_interface/profiles_and_samples/profile_structs/#PlaceholderLikelihood.BivariateConfidenceStruct","page":"Structs and Profile Types","title":"PlaceholderLikelihood.BivariateConfidenceStruct","text":"BivariateConfidenceStruct(confidence_boundary::Matrix{Float64}, \n    internal_points::PointsAndLogLikelihood = PointsAndLogLikelihood(zeros(size(x, 1), 0), zeros(0)))\n\nStruct that stores samples produced by an AbstractBivariateMethod that are on the bivariate confidence boundary of two interest parameters at a given confidence level and, if save_internal_points=true, any internal points found during the method with their corresponding log-likelihood values. Use bivariate_methods() for a list of available methods (see bivariate_methods).\n\nFields\n\nconfidence_boundary: an array of boundary points stored in columns, with each row corresponding to the respective index of each model parameter. This array can contain points that are inside the bivariate confidence boundary if the method being used brackets between an internal point and a point on the user-provided bounds: these points will be on a user-provided parameter bound.\ninternal_points: a PointsAndLogLikelihood struct containing points and their corresponding log-likelihood values that were found during a method, if save_internal_points=true. Default is an empty PointsAndLogLikelihood struct (used if save_internal_points=false).\n\nSupertype Hiearachy\n\nBivariateConfidenceStruct <: AbstractConfidenceStruct <: Any\n\n\n\n\n\n","category":"type"},{"location":"user_interface/profiles_and_samples/profile_structs/#PlaceholderLikelihood.SampledConfidenceStruct","page":"Structs and Profile Types","title":"PlaceholderLikelihood.SampledConfidenceStruct","text":"SampledConfidenceStruct(points::Array{Float64}, \n    ll::Vector{<:Float64})\n\nStruct that stores samples produced by an AbstractSampleType that are within the confidence boundary of sample_dimension interest parameters at a given confidence level, with their corresponding log-likelihood values.\n\nFields\n\npoints: an array of points stored in columns, with each row corresponding to the respective index of each model parameter. \nll: a vector of log-likelihood function values corresponding to the point in each column of points. This number is standardised so that regardless of whether the true log-likelihood function or an ellipse approximation of the function is evaluated, the value of the MLE point is 0.0. \n\nSupertype Hiearachy\n\nSampledConfidenceStruct <: AbstractConfidenceStruct <: Any\n\n\n\n\n\n","category":"type"},{"location":"user_interface/profiles_and_samples/profile_structs/#Profile-Types","page":"Structs and Profile Types","title":"Profile Types","text":"","category":"section"},{"location":"user_interface/profiles_and_samples/profile_structs/","page":"Structs and Profile Types","title":"Structs and Profile Types","text":"Profile type is a Struct that specifies whether the profile to be taken uses the true loglikelihood function or an ellipse approximation of the loglikelihood function centred at the MLE (with optional use of parameter bounds).","category":"page"},{"location":"user_interface/profiles_and_samples/profile_structs/","page":"Structs and Profile Types","title":"Structs and Profile Types","text":"AbstractProfileType\nAbstractEllipseProfileType\nLogLikelihood\nEllipseApprox\nEllipseApproxAnalytical","category":"page"},{"location":"user_interface/profiles_and_samples/profile_structs/#PlaceholderLikelihood.AbstractProfileType","page":"Structs and Profile Types","title":"PlaceholderLikelihood.AbstractProfileType","text":"AbstractProfileType\n\nSupertype for profile types.\n\nSubtypes\n\nLogLikelihood\n\nAbstractEllipseProfileType\n\n\n\n\n\n","category":"type"},{"location":"user_interface/profiles_and_samples/profile_structs/#PlaceholderLikelihood.AbstractEllipseProfileType","page":"Structs and Profile Types","title":"PlaceholderLikelihood.AbstractEllipseProfileType","text":"AbstractProfileType\n\nSupertype for ellipse approximation profile types.\n\nSubtypes\n\nEllipseApprox\n\nEllipseApproxAnalytical\n\nSupertype Hiearachy\n\nAbstractProfileType <: AbstractProfileType <: Any\n\n\n\n\n\n","category":"type"},{"location":"user_interface/profiles_and_samples/profile_structs/#PlaceholderLikelihood.LogLikelihood","page":"Structs and Profile Types","title":"PlaceholderLikelihood.LogLikelihood","text":"LogLikelihood()\n\nUse the true log-likelihood function for confidence profile evaluation. The methods IterativeBoundaryMethod and RadialRandomMethod are recommended for use with this profile type.\n\nSupertype Hiearachy\n\nLogLikelihood <: AbstractProfileType <: Any\n\n\n\n\n\n","category":"type"},{"location":"user_interface/profiles_and_samples/profile_structs/#PlaceholderLikelihood.EllipseApprox","page":"Structs and Profile Types","title":"PlaceholderLikelihood.EllipseApprox","text":"EllipseApprox()\n\nUse an ellipse approximation of the log-likelihood function centred at the MLE with use of parameter bounds for confidence profile evaluation. The method RadialMLEMethod is recommended for use with this profile type.\n\nSupertype Hiearachy\n\nEllipseApprox <: AbstractEllipseProfileType <: AbstractProfileType <: Any\n\n\n\n\n\n","category":"type"},{"location":"user_interface/profiles_and_samples/profile_structs/#PlaceholderLikelihood.EllipseApproxAnalytical","page":"Structs and Profile Types","title":"PlaceholderLikelihood.EllipseApproxAnalytical","text":"EllipseApproxAnalytical()\n\nUse an ellipse approximation of the log-likelihood function centred at the MLE without use of parameter bounds for confidence profile evaluation. As no parameter bounds are involved, it can be analytically evaluated. The method AnalyticalEllipseMethod is recommended for use with this profile type - it analytically samples points on the confidence profile boundary using EllipseSampling.jl. Other methods can be used, but they will all be unable to find interest parameter points outside user-provided parameter bounds (although nuisance parameters will be allowed outside these bounds).\n\nSupertype Hiearachy\n\nEllipseApproxAnalytical <: AbstractEllipseProfileType <: AbstractProfileType <: Any\n\n\n\n\n\n","category":"type"},{"location":"user_interface/coverage/univariate_intervals/#Parameter-Confidence-Intervals","page":"Parameter Confidence Intervals","title":"Parameter Confidence Intervals","text":"","category":"section"},{"location":"user_interface/coverage/univariate_intervals/","page":"Parameter Confidence Intervals","title":"Parameter Confidence Intervals","text":"Pages = [\"univariate_intervals.md\"]","category":"page"},{"location":"user_interface/coverage/univariate_intervals/","page":"Parameter Confidence Intervals","title":"Parameter Confidence Intervals","text":"check_univariate_parameter_coverage","category":"page"},{"location":"user_interface/coverage/univariate_intervals/#PlaceholderLikelihood.check_univariate_parameter_coverage","page":"Parameter Confidence Intervals","title":"PlaceholderLikelihood.check_univariate_parameter_coverage","text":"check_univariate_parameter_coverage(data_generator::Function, \n    generator_args::Union{Tuple, NamedTuple},\n    model::LikelihoodModel, \n    N::Int, \n    θtrue::AbstractVector{<:Real}, \n    θs::AbstractVector{<:Int64},\n    θinitialguess::AbstractVector{<:Real}=θtrue; \n    confidence_level::Float64=0.95, \n    profile_type::AbstractProfileType=LogLikelihood(), \n    θs_is_unique::Bool=false,\n    coverage_estimate_confidence_level::Float64=0.95,\n    show_progress::Bool=model.show_progress,\n    distributed_over_parameters::Bool=false)\n\nPerforms a simulation to estimate the coverage of univariate confidence intervals for parameters in θs given a model by: repeatedly drawing new observed data using data_generator for fixed true parameter values, θtrue, fitting the model and univariate confidence intervals, and checking whether the confidence interval for the parameters of interest contain the true parameter value in θtrue. The estimated coverage is returned with a default 95% confidence interval within a DataFrame. \n\nArguments\n\ndata_generator: a function with two arguments which generates data for fixed time points and true model parameters corresponding to the log-likelihood function contained in model. The two arguments must be the vector of true model parameters, θtrue, and a Tuple or NamedTuple, generator_args. Outputs a data Tuple or NamedTuple that corresponds to the log-likelihood function contained in model.\ngenerator_args: a Tuple or NamedTuple containing any additional information required by both the log-likelihood function and data_generator, such as the time points to be evaluated at. If evaluating the log-likelihood function requires more than just the simulated data, arguments for the data output of data_generator should be passed in via generator_args. \nmodel: a LikelihoodModel containing model information, saved profiles and predictions.\nN: a positive number of coverage simulations.\nθtrue: a vector of true parameters values of the model for simulating data with. \nθs: a vector of parameters to profile, as a vector of model parameter indexes.\nθinitialguess: a vector containing the initial guess for the values of each parameter. Used to find the MLE point in each iteration of the simulation. Default is θtrue.\n\nKeyword Arguments\n\nconfidence_level: a number ∈ (0.0, 1.0) for the confidence level to evaluate the confidence interval coverage at. Default is 0.95 (95%).\nprofile_type: whether to use the true log-likelihood function or an ellipse approximation of the log-likelihood function centred at the MLE (with optional use of parameter bounds). Available profile types are LogLikelihood, EllipseApprox and EllipseApproxAnalytical. Default is LogLikelihood() (LogLikelihood).\nθs_is_unique: boolean variable specifying whether all parameter indexes in θs are ordered by parameter index (ascending) and unique. Default is false.\ncoverage_estimate_confidence_level: a number ∈ (0.0, 1.0) for the level of a confidence interval of the estimated coverage. Default is 0.95 (95%).\nshow_progress: boolean variable specifying whether to display progress bars on the percentage of simulation iterations completed and estimated time of completion. Default is model.show_progress.\ndistributed_over_parameters: boolean variable specifying whether to distribute the workload of the simulation across simulation iterations or across the individual confidence interval calculations within each iteration. Default is false.\n\nDetails\n\nThis simulated coverage check is used to estimate the performance of parameter confidence intervals. For a 95% confidence interval of a interest parameter θi it is expected that under repeated experiments from an underlying true model (data generation) which are used to construct a confidence interval for θi using the method used in univariate_confidenceintervals!, 95% of the intervals constructed would contain the true value for θi. In our simulation where the values of our true parameters, θtrue, are known this is equivalent to whether the confidence interval for θi contains the value θtrue[θi]. \n\nThe uncertainty in estimates of the coverage under the simulated model will decrease as the number of simulations, N, is increased. Confidence intervals for the coverage estimate are provided to quantify this uncertainty.\n\nnote: Recommended setting for distributed_over_parameters\nIf the number of processes available to use is significantly greater than the number of model parameters or only a few model parameters are being checked for coverage, false is recommended.   \nIf system memory or model size in system memory is a concern, or the number of processes available is similar or less than the number of model parameters being checked, true will likely be more appropriate. \nWhen set to false, a separate LikelihoodModel struct will be used by each process, as opposed to only one when set to true, which could be an issue for larger models. \n\nThe 95% confidence interval for the estimated coverage is a Clopper-Pearson interval on a binomial test generated using HypothesisTests.jl.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/coverage/univariate_intervals/#Example-usage","page":"Parameter Confidence Intervals","title":"Example usage","text":"","category":"section"},{"location":"internal_library/common/#Common-Functions","page":"Common Functions","title":"Common Functions","text":"","category":"section"},{"location":"internal_library/common/","page":"Common Functions","title":"Common Functions","text":"Pages = [\"common.md\"]","category":"page"},{"location":"internal_library/common/","page":"Common Functions","title":"Common Functions","text":"PlaceholderLikelihood.convertθnames_toindices\nPlaceholderLikelihood.ll_correction\nPlaceholderLikelihood.get_target_loglikelihood\nPlaceholderLikelihood.get_consistent_tuple\nPlaceholderLikelihood.desired_df_subset","category":"page"},{"location":"internal_library/common/#PlaceholderLikelihood.convertθnames_toindices","page":"Common Functions","title":"PlaceholderLikelihood.convertθnames_toindices","text":"convertθnames_toindices(model::LikelihoodModel, \n    θnames_to_convert::Vector{<:Symbol})\n\nConverts a vector of symbols representing parameters in model to a vector of each symbol's corresponding index in model.core.θnames.\n\n\n\n\n\nconvertθnames_toindices(model::LikelihoodModel, \n    θnames_to_convert::Union{Vector{Vector{Symbol}}, Vector{Tuple{Symbol, Symbol}}})\n\nConverts a vector of vectors or tuples containing symbols representing parameters in model to a vector of vectors containing each symbol's corresponding index in model.core.θnames.\n\n\n\n\n\n","category":"function"},{"location":"internal_library/common/#PlaceholderLikelihood.ll_correction","page":"Common Functions","title":"PlaceholderLikelihood.ll_correction","text":"ll_correction(model::LikelihoodModel, \n    profile_type::AbstractProfileType, \n    ll::Float64)\n\nIf a profile_type is LogLikelihood(), it corrects ll such that an input log-likelihood value (which has value of zero at the MLE) will now have a value of model.core.maximisedmle at the MLE. Otherwise, a copy of ll is returned, as both ellipse approximation profile types have a log-likelihood value of 0.0 at the MLE.\n\n\n\n\n\n","category":"function"},{"location":"internal_library/common/#PlaceholderLikelihood.get_target_loglikelihood","page":"Common Functions","title":"PlaceholderLikelihood.get_target_loglikelihood","text":"get_target_loglikelihood(model::LikelihoodModel, \n    confidence_level::Float64, \n    profile_type::AbstractProfileType, \n    dof::Int)\n\nReturns the target log-likelihood / threshold at a confidence level and degrees of freedom, dof (the number of interest parameters), required for a particular profile_type to be in the confidence set. Uses PlaceholderLikelihood.ll_correction \n\n\n\n\n\n","category":"function"},{"location":"internal_library/common/#PlaceholderLikelihood.get_consistent_tuple","page":"Common Functions","title":"PlaceholderLikelihood.get_consistent_tuple","text":"get_consistent_tuple(model::LikelihoodModel, \n    confidence_level::Float64, \n    profile_type::AbstractProfileType, \n    dof::Int)\n\nReturns a tuple containing the values needed for log-likelihood evaluation and finding function zeros, including the target log-likelihood, number of model parameters, log-likelihood function to use and data tuple for evaluating the log-likelihood function.\n\n\n\n\n\n","category":"function"},{"location":"internal_library/common/#PlaceholderLikelihood.desired_df_subset","page":"Common Functions","title":"PlaceholderLikelihood.desired_df_subset","text":"desired_df_subset(df::DataFrame, \n    num_used_rows::Int, \n    confidence_levels::Union{Float64, Vector{<:Float64}}, \n    sample_types::Vector{<:AbstractSampleType}; \n    sample_dimension::Int=0, \n    for_prediction_generation::Bool=false, \n    for_prediction_plots::Bool=false, \n    include_higher_confidence_levels::Bool=false)\n\nReturns a view of df that includes only valid rows ∈ 1:num_used_rows, and rows that contain all of the values specified within function arguments. For dimensional samples.\n\nArguments\n\ndf: a DataFrame - model.dim_samples_df.\nnum_used_rows: the number of valid rows in df - model.num_dim_samples.\nconfidence_levels: a vector of confidence levels or a Float64 of a single confidence level. If empty, all confidence levels in df are allowed. Otherwise, if include_higher_confidence_levels == true and confidence_levels is a Float64, all confidence levels greater than or equal to confidence_levels are allowed. Else, only matching confidence levels in df are allowed.\nsample_types: a vector of AbstractSampleType structs. If empty, all sample types in df are allowed. Otherwise, only matching sample types in df are allowed.\n\nKeyword Arguments\n\nsample_dimension: an integer greater than or equal to 0; if non-zero only matching dimensions of interest parameters in df are allowed, otherwise all are a allowed. Default is 0.\nfor_prediction_generation: a boolean specifying whether only rows which have not had predictions evaluated are allowed. As predictions do not need to be generated for rows which already have them evaluated. \nfor_prediction_plots: a boolean specifying whether only rows which have had predictions evaluated are allowed. As prediction plots can only include rows which have evaluated predictions. \ninclude_higher_confidence_levels: a boolean specifying whether all confidence levels greater than or equal to confidence_levels are allowed. Useful for prediction plots as a dimensional sample can be evaluated at a high confidence level (e.g. 0.95) and then used at a lower confidence level (e.g. 0.9), extracting only the sample points that are in the 0.9 confidence set.\n\n\n\n\n\ndesired_df_subset(df::DataFrame, \n    num_used_rows::Int, \n    θs_of_interest::Vector{<:Int}, \n    confidence_levels::Union{Float64, Vector{<:Float64}}, \n    profile_types::Vector{<:AbstractProfileType}; \n    for_points_in_interval::Tuple{Bool,Int,Real}=(false,0,0), \n    for_prediction_generation::Bool=false, \n    for_prediction_plots::Bool=false)\n\nReturns a view of df that includes only valid rows ∈ 1:num_used_rows, and rows that contain all of the values specified within function arguments. For univariate profiles.\n\nArguments\n\ndf: a DataFrame - model.uni_profiles_df.\nnum_used_rows: the number of valid rows in df - model.num_uni_profiles.\nconfidence_levels: a vector of confidence levels or a Float64 of a single confidence level. If empty, all confidence levels in df are allowed. Otherwise, if include_higher_confidence_levels == true and confidence_levels is a Float64, all confidence levels greater than or equal to confidence_levels are allowed. Else, only matching confidence levels in df are allowed.\nprofile_types: a vector of AbstractProfileType structs. If empty, all profile types in df are allowed. Otherwise, only matching profile types in df are allowed.\n\nKeyword Arguments\n\nfor_points_in_interval: a tuple used for only extracting the rows that need to have points in the confidence interval evaluated by get_points_in_interval!. Default is (false, 0, 0).\nfor_prediction_generation: a boolean specifying whether only rows which have not had predictions evaluated are allowed. As predictions do not need to be generated for rows which already have them evaluated. \nfor_prediction_plots: a boolean specifying whether only rows which have had predictions evaluated are allowed. As prediction plots can only include rows which have evaluated predictions. \n\n\n\n\n\ndesired_df_subset(df::DataFrame, \n    num_used_rows::Int, \n    θs_of_interest::Vector{Tuple{Int,Int}}, \n    confidence_levels::Union{Float64, Vector{<:Float64}}, \n    profile_types::Vector{<:AbstractProfileType}, \n    methods::Vector{<:AbstractBivariateMethod}=AbstractBivariateMethod[]; \n    for_prediction_generation::Bool=false, \n    for_prediction_plots::Bool=false, \n    include_lower_confidence_levels::Bool=false)\n\nReturns a view of df that includes only valid rows ∈ 1:num_used_rows, and rows that contain all of the values specified within function arguments. For bivariate profiles.\n\nArguments\n\ndf: a DataFrame - model.biv_profiles_df.\nnum_used_rows: the number of valid rows in df - model.num_biv_profiles.\nconfidence_levels: a vector of confidence levels or a Float64 of a single confidence level. If empty, all confidence levels in df are allowed. Otherwise, if include_higher_confidence_levels == true and confidence_levels is a Float64, all confidence levels greater than or equal to confidence_levels are allowed. Else, only matching confidence levels in df are allowed.\nprofile_types: a vector of AbstractProfileType structs. If empty, all profile types in df are allowed. Otherwise, only matching profile types in df are allowed.\nmethods: a vector of AbstractBivariateMethod structs. If empty, all methods in df are allowed. Otherwise, only methods of the same type in df are allowed.\n\nKeyword Arguments\n\nfor_prediction_generation: a boolean specifying whether only rows which have not had predictions evaluated are allowed. As predictions do not need to be generated for rows which already have them evaluated. \nfor_prediction_plots: a boolean specifying whether only rows which have had predictions evaluated are allowed. As prediction plots can only include rows which have evaluated predictions. \ninclude_lower_confidence_levels: a boolean specifying whether all confidence levels less than or equal to confidence_levels are allowed. Useful for prediction plots if a given set of bivariate profiles has few internal points evaluated, meaning some information about predictions may be missing. Bivariate profiles at lower confidence levels are by definition inside the desired confidence interval and may provide additional information on predictions.\n\n\n\n\n\n","category":"function"},{"location":"internal_library/bivariate/#Bivariate-Functions","page":"Bivariate Functions","title":"Bivariate Functions","text":"","category":"section"},{"location":"internal_library/bivariate/","page":"Bivariate Functions","title":"Bivariate Functions","text":"Pages = [\"bivariate.md\"]","category":"page"},{"location":"internal_library/bivariate/#Initialisation-and-Array-Mapping","page":"Bivariate Functions","title":"Initialisation and Array Mapping","text":"","category":"section"},{"location":"internal_library/bivariate/","page":"Bivariate Functions","title":"Bivariate Functions","text":"PlaceholderLikelihood.variablemapping2dranges\nPlaceholderLikelihood.variablemapping2d!\nPlaceholderLikelihood.boundsmapping2d!\nPlaceholderLikelihood.init_bivariate_parameters","category":"page"},{"location":"internal_library/bivariate/#Likelihood-Optimisation","page":"Bivariate Functions","title":"Likelihood Optimisation","text":"","category":"section"},{"location":"internal_library/bivariate/","page":"Bivariate Functions","title":"Bivariate Functions","text":"PlaceholderLikelihood.bivariateΨ!\nPlaceholderLikelihood.bivariateΨ_vectorsearch!\nPlaceholderLikelihood.bivariateΨ_continuation!\nPlaceholderLikelihood.bivariateΨ_gradient!\nPlaceholderLikelihood.bivariateΨ_ellipse_analytical\nPlaceholderLikelihood.bivariateΨ_ellipse_analytical_vectorsearch\nPlaceholderLikelihood.bivariateΨ_ellipse_analytical_continuation\nPlaceholderLikelihood.bivariateΨ_ellipse_analytical_gradient\nPlaceholderLikelihood.bivariateΨ_ellipse_unbounded","category":"page"},{"location":"internal_library/bivariate/#PlaceholderLikelihood.bivariateΨ_gradient!","page":"Bivariate Functions","title":"PlaceholderLikelihood.bivariateΨ_gradient!","text":"Requires optimal values of nuisance parameters at point Ψ to be contained in p.λ_opt\n\n\n\n\n\n","category":"function"},{"location":"internal_library/bivariate/#Finding-Points-on-2D-bounds","page":"Bivariate Functions","title":"Finding Points on 2D bounds","text":"","category":"section"},{"location":"internal_library/bivariate/","page":"Bivariate Functions","title":"Bivariate Functions","text":"PlaceholderLikelihood.findpointonbounds","category":"page"},{"location":"internal_library/bivariate/#Main-Confidence-Boundary-Logic","page":"Bivariate Functions","title":"Main Confidence Boundary Logic","text":"","category":"section"},{"location":"internal_library/bivariate/","page":"Bivariate Functions","title":"Bivariate Functions","text":"Note: AnalyticalEllipseMethod is calculated using generate_N_clustered_points from EllipseSampling.jl within PlaceholderLikelihood.bivariate_confidenceprofile.","category":"page"},{"location":"internal_library/bivariate/","page":"Bivariate Functions","title":"Bivariate Functions","text":"PlaceholderLikelihood.add_biv_profiles_rows!\nPlaceholderLikelihood.set_biv_profiles_row!\nPlaceholderLikelihood.get_bivariate_opt_func\nPlaceholderLikelihood.get_λs_bivariate_ellipse_analytical!\nPlaceholderLikelihood.bivariate_confidenceprofile\nBase.merge(::BivariateConfidenceStruct, ::BivariateConfidenceStruct)","category":"page"},{"location":"internal_library/bivariate/#PlaceholderLikelihood.add_biv_profiles_rows!","page":"Bivariate Functions","title":"PlaceholderLikelihood.add_biv_profiles_rows!","text":"add_biv_profiles_rows!(model::LikelihoodModel, num_rows_to_add::Int)\n\nAdds num_rows_to_add rows to model.biv_profiles_df. \n\n\n\n\n\n","category":"function"},{"location":"internal_library/bivariate/#PlaceholderLikelihood.set_biv_profiles_row!","page":"Bivariate Functions","title":"PlaceholderLikelihood.set_biv_profiles_row!","text":"set_biv_profiles_row!(model::LikelihoodModel, \n    row_ind::Int, \n    θcombination::Tuple{Int, Int},\n    not_evaluated_internal_points::Bool, \n    not_evaluated_predictions::Bool,\n    confidence_level::Float64, \n    profile_type::AbstractProfileType,\n    method::AbstractBivariateMethod, \n    num_points::Int)\n\nSets the columns of row row_ind of model.biv_profiles_df to contain the relevant info about a just conducted profile. model.biv_profiles_dict contains the profile for row row_ind at key row_ind.  \n\n\n\n\n\n","category":"function"},{"location":"internal_library/bivariate/#PlaceholderLikelihood.get_bivariate_opt_func","page":"Bivariate Functions","title":"PlaceholderLikelihood.get_bivariate_opt_func","text":"get_bivariate_opt_func(profile_type::AbstractProfileType, method::AbstractBivariateMethod)\n\nReturns the correct bivariate optimisation function used to find the optimal values of nuisance parameters at a set of interest parameters for the profile_type log-likelihood function. The optimisation function returns the value of the profile_type log-likelihood function as well as finding the optimal nuisance parameters and saving these in one of it's inputs.\n\n\n\n\n\n","category":"function"},{"location":"internal_library/bivariate/#PlaceholderLikelihood.get_λs_bivariate_ellipse_analytical!","page":"Bivariate Functions","title":"PlaceholderLikelihood.get_λs_bivariate_ellipse_analytical!","text":"get_λs_bivariate_ellipse_analytical!(boundary,\n    num_points::Int,\n    consistent::NamedTuple, \n    ind1::Int, \n    ind2::Int, \n    num_pars::Int,\n    initGuess::Vector{<:Float64}, \n    θranges::Tuple{T, T, T}, \n    λranges::Tuple{T, T, T},\n    samples_all_pars::Union{Missing, Matrix{Float64}}=missing) where T<:UnitRange\n\nDetermines the nuisance parameters for a EllipseApproxAnalytical boundary profile by optimising over the unbounded ellipse approximation of the log-likelihood centred at the MLE. At higher confidence levels, where the ellipse approximation is less accurate, it is likely that predictions produced by running the model with these optimised nuisance parameters will be unrealistic and/or the parameters themselves may be infeasible for the model. \n\n\n\n\n\n","category":"function"},{"location":"internal_library/bivariate/#PlaceholderLikelihood.bivariate_confidenceprofile","page":"Bivariate Functions","title":"PlaceholderLikelihood.bivariate_confidenceprofile","text":"bivariate_confidenceprofile(bivariate_optimiser::Function,\n    model::LikelihoodModel, \n    num_points::Int,\n    confidence_level::Float64,\n    consistent::NamedTuple,\n    ind1::Int,\n    ind2::Int,\n    profile_type::AbstractProfileType,\n    method::AbstractBivariateMethod,\n    mle_targetll::Float64,\n    save_internal_points::Bool,\n    channel::RemoteChannel)\n\nReturns a BivariateConfidenceStruct containing the num_points boundary points and internal points (if save_internal_points=true) for the specified combination of parameters ind1 and ind2, and profile_type at confidence_level using method. Calls the desired method. Called by bivariate_confidenceprofiles!.\n\n\n\n\n\n","category":"function"},{"location":"internal_library/bivariate/#Base.merge-Tuple{BivariateConfidenceStruct, BivariateConfidenceStruct}","page":"Bivariate Functions","title":"Base.merge","text":"Base.merge(a::BivariateConfidenceStruct, b::BivariateConfidenceStruct)\n\nSpecifies how to merge two variables with type BivariateConfidenceStruct.\n\n\n\n\n\n","category":"method"},{"location":"internal_library/bivariate/#Minimum-Perimeter-Polygon","page":"Bivariate Functions","title":"Minimum Perimeter Polygon","text":"","category":"section"},{"location":"internal_library/bivariate/","page":"Bivariate Functions","title":"Bivariate Functions","text":"PlaceholderLikelihood.minimum_perimeter_polygon!","category":"page"},{"location":"internal_library/bivariate/#PlaceholderLikelihood.minimum_perimeter_polygon!","page":"Bivariate Functions","title":"PlaceholderLikelihood.minimum_perimeter_polygon!","text":"minimum_perimeter_polygon!(points::Array{<:Real,2})\n\nGiven a set of N points that define a boundary polygon in a 2 row, N column array, solve a minimum perimeter polygon TSP problem, reorder these points in place and return the path used (vertices in order of visitation). Uses TravelingSalesmanHeuristics.jl.\n\n\n\n\n\n","category":"function"},{"location":"internal_library/bivariate/#Iterative-Boundary-Method","page":"Bivariate Functions","title":"Iterative Boundary Method","text":"","category":"section"},{"location":"internal_library/bivariate/","page":"Bivariate Functions","title":"Bivariate Functions","text":"For IterativeBoundaryMethod.","category":"page"},{"location":"internal_library/bivariate/","page":"Bivariate Functions","title":"Bivariate Functions","text":"PlaceholderLikelihood.findNpointpairs_radialMLE!\nPlaceholderLikelihood.edge_length\nPlaceholderLikelihood.internal_angle_from_pi!\nPlaceholderLikelihood.internal_angle_from_pi\nPlaceholderLikelihood.iterativeboundary_init\nPlaceholderLikelihood.newboundarypoint!\nPlaceholderLikelihood.heapupdates_success!\nPlaceholderLikelihood.heapupdates_failure!\nPlaceholderLikelihood.polygon_break_and_rejoin!\nPlaceholderLikelihood.bivariate_confidenceprofile_iterativeboundary","category":"page"},{"location":"internal_library/bivariate/#PlaceholderLikelihood.findNpointpairs_radialMLE!","page":"Bivariate Functions","title":"PlaceholderLikelihood.findNpointpairs_radialMLE!","text":"Distorts uniformly spaced angles on a circle to angles on an ellipse representative of the relative magnitude of each parameter. If the magnitude of a parameter is a NaN value (i.e. either bound is Inf), then the relative magnitude is set to 1.0, as no information is known about its magnitude.\n\nAngles are anticlockwise\n\n\n\n\n\n","category":"function"},{"location":"internal_library/bivariate/#PlaceholderLikelihood.edge_length","page":"Bivariate Functions","title":"PlaceholderLikelihood.edge_length","text":"edge_length(boundary, inds1, inds2, relative_magnitude)\n\nEuclidean distance between two vertices (length of an edge), scaled by the relative magnitude of parameters, so that each dimension has roughly the same weight.\n\n\n\n\n\n","category":"function"},{"location":"internal_library/bivariate/#PlaceholderLikelihood.internal_angle_from_pi!","page":"Bivariate Functions","title":"PlaceholderLikelihood.internal_angle_from_pi!","text":"internal_angle_from_pi!(vertex_internal_angle_objs, \n    indexes::UnitRange, \n    boundary, \n    adjacent_vertices)\n\nThe magnitude the internal angle in radians between two adjacent edges is from pi radians - i.e. how far away the two edges are from representing a straight boundary. If a boundary is straight then the objective is 0.0 radians, whereas if the boundary has an internal angle of pi/4 radians (45 deg) the objective is pi*3/4 (135 deg). Computes this by considering the angle between the two vectors that can be used to represent the edges (using AngleBetweenVectors.jl).\n\n\n\n\n\n","category":"function"},{"location":"internal_library/bivariate/#PlaceholderLikelihood.newboundarypoint!","page":"Bivariate Functions","title":"PlaceholderLikelihood.newboundarypoint!","text":"newboundarypoint!(p::NamedTuple, \n    point_is_on_bounds::BitVector, \n    edge_anti_on_bounds::BitVector, \n    boundary::Matrix{Float64}, \n    boundary_all::Matrix{Float64}, \n    internal_all::Matrix{Float64}, \n    ll_values::Vector{Float64}, \n    internal_count::Int,\n    bivariate_optimiser::Function, \n    model::LikelihoodModel, \n    edge_anti::Vector{Int}, \n    num_vertices::Int, \n    ind1::Int, \n    ind2::Int,\n    biv_opt_is_ellipse_analytical::Bool, \n    ve1::Int, \n    ve2::Int, \n    relative_magnitude::Float64, \n    bound_warning::Bool, \n    save_internal_points::Bool)\n\n\n\n\n\n","category":"function"},{"location":"internal_library/bivariate/#PlaceholderLikelihood.heapupdates_failure!","page":"Bivariate Functions","title":"PlaceholderLikelihood.heapupdates_failure!","text":"This function is used in the event that no boundary points are found using newboundarypoint. Failure means it is likely that multiple level sets exist. If so, we break the edges of the candidate point and e_intersect and reconnect the vertexes such that we now have multiple boundary polygons.\n\nIf we only have one or two points on one of these boundary polygons we will display an info message as no additional points can be found from the method directly.\n\nIf we have three or more points on these boundary polygons, then there should be no problems finding other parts of these polygons.\n\nIf the largest polygon has less than two points the method will display a warning message and terminate, returning the boundary found up until then. \n\n\n\n\n\n","category":"function"},{"location":"internal_library/bivariate/#Vectorsearch-Methods","page":"Bivariate Functions","title":"Vectorsearch Methods","text":"","category":"section"},{"location":"internal_library/bivariate/","page":"Bivariate Functions","title":"Bivariate Functions","text":"For the RadialRandomMethod, RadialMLEMethod and SimultaneousMethod.","category":"page"},{"location":"internal_library/bivariate/","page":"Bivariate Functions","title":"Bivariate Functions","text":"PlaceholderLikelihood.generatepoint\nPlaceholderLikelihood.findNpointpairs_simultaneous!\nPlaceholderLikelihood.find_m_spaced_radialdirections\nPlaceholderLikelihood.findNpointpairs_radialrandom!\nPlaceholderLikelihood.bivariate_confidenceprofile_vectorsearch","category":"page"},{"location":"internal_library/bivariate/#PlaceholderLikelihood.findNpointpairs_simultaneous!","page":"Bivariate Functions","title":"PlaceholderLikelihood.findNpointpairs_simultaneous!","text":"At later stage, implement with maxIters in the event that either the user-specified bounds don't contain internal points (or similarly external points) for a given confidence region (i.e. bounds either don't contain the 2D boundary at a confidence level OR the 2D boundary at a confidence level contains the bounds)\n\n\n\n\n\n","category":"function"},{"location":"internal_library/bivariate/#PlaceholderLikelihood.findNpointpairs_radialrandom!","page":"Bivariate Functions","title":"PlaceholderLikelihood.findNpointpairs_radialrandom!","text":"Distorts uniformly spaced angles on a circle to angles on an ellipse representative of the relative magnitude of each parameter. If the magnitude of a parameter is a NaN value (i.e. either bound is Inf), then the relative magnitude is set to 1.0, as no information is known about its magnitude.\n\n\n\n\n\n","category":"function"},{"location":"internal_library/bivariate/#Fix1Axis-Method","page":"Bivariate Functions","title":"Fix1Axis Method","text":"","category":"section"},{"location":"internal_library/bivariate/","page":"Bivariate Functions","title":"Bivariate Functions","text":"For Fix1AxisMethod.","category":"page"},{"location":"internal_library/bivariate/","page":"Bivariate Functions","title":"Bivariate Functions","text":"PlaceholderLikelihood.findNpointpairs_fix1axis!\nPlaceholderLikelihood.bivariate_confidenceprofile_fix1axis!","category":"page"},{"location":"internal_library/bivariate/#Continuation-Method","page":"Bivariate Functions","title":"Continuation Method","text":"","category":"section"},{"location":"internal_library/bivariate/","page":"Bivariate Functions","title":"Bivariate Functions","text":"For ContinuationMethod.","category":"page"},{"location":"internal_library/bivariate/","page":"Bivariate Functions","title":"Bivariate Functions","text":"PlaceholderLikelihood.update_targetll!\nPlaceholderLikelihood.normal_vector_i_2d!\nPlaceholderLikelihood.continuation_line_search!\nPlaceholderLikelihood.continuation_inwards_radial_search!\nPlaceholderLikelihood.initial_continuation_solution!\nPlaceholderLikelihood.bivariate_confidenceprofile_continuation\nPlaceholderLikelihood.star_obj\nPlaceholderLikelihood.boundary_smoother!\nPlaceholderLikelihood.refine_search_directions!","category":"page"},{"location":"internal_library/bivariate/#PlaceholderLikelihood.continuation_line_search!","page":"Bivariate Functions","title":"PlaceholderLikelihood.continuation_line_search!","text":"startlevelset only has two rows. Within this function we keep track of both the 2d points on the boundary - as this is all that needs to be known to get to the next point\n\nFor a given level set to get to, that's larger than all points in current level set. \n\nFind normal direction at each point (either using ForwardDiff or a first order approximation)\nCheck where this normal direction intersects bounds and ensure that the next level set is bracketed by current point and point on boundary\nIf a bracket between current point and point on boundary does not exist the level set point recorded will be the point on the boundary\ninit guess for nuisance parameters should be their value at current point\nusing vector search bivariate function as input to find_zero(), using Order0 method, with starting guess of Ψ=0\nrecord point at that level set\n\np and pointison_bounds is mutated by this function.\n\nLATER: Update to allow specification of alternate method to find_zero(), e.g. Order8 OR alternate method using NLsolve (and LineSearches) in \"2DGradientLinesearchTests.jl\" which is gradient based.\n\n\n\n\n\n","category":"function"},{"location":"internal_library/bivariate/#PlaceholderLikelihood.initial_continuation_solution!","page":"Bivariate Functions","title":"PlaceholderLikelihood.initial_continuation_solution!","text":"The initial ellipse solution also should be in feasible region: contained within bounds specified for interest parameters. WARN if it is not - may cause some unexpected behaviour if the parameter is meant to be ≥ 0, yet is allowed to start there in the initial ellipse solution.\n\nFind extrema of true log likelihoods of initial ellipse solution 3 cases:  Case 1 is preferred. Warnings will be raised for both Case 2 and 3 Case 1: If min ll > than target ll of smallest target confidence level (preferred approach atm). Then line search from initial ellipse to ll boundary defined by min ll and this is the starting continuation solution. Line search in direction specified by forward diff at point\n\nCase 2: If max ll < than target ll of smallest target confidence level. Line search radially towards the mle solution from the ellipse to the smallest target confidence level boundary and this is the starting continuation solution. In case two, this counts as a 'level set'.\n\nCase 3: If min ll and max ll bracket the smallest target confidence level. Then line search radially towards the mle solution from initial ellipse to ll boundary defined by max ll and this is the starting continuation solution.\n\nFor both Case 2 and 3, could use gradient at initial elipse point rather than going radially towards the mle, but in my opinion may not be able to find the log likelihood boundary.\n\n\n\n\n\n","category":"function"},{"location":"internal_library/bivariate/#PlaceholderLikelihood.bivariate_confidenceprofile_continuation","page":"Bivariate Functions","title":"PlaceholderLikelihood.bivariate_confidenceprofile_continuation","text":"bivariateoptimiser is the optimiser to use with findzero bivariateoptimisergradient is the optimiser to use with ForwardDiff.gradient and to evaluate the obj value for the initial ellipse solution.\n\n\n\n\n\n","category":"function"},{"location":"internal_library/bivariate/#PlaceholderLikelihood.star_obj","page":"Bivariate Functions","title":"PlaceholderLikelihood.star_obj","text":"star_obj(centers, points)\n\ncenters have 2D points stored in columns.\n\npoints have 2D boundary points stored in columns and are in either clockwise or anticlockwise order of polygon connection.\n\n\n\n\n\n","category":"function"},{"location":"internal_library/bivariate/#PlaceholderLikelihood.boundary_smoother!","page":"Bivariate Functions","title":"PlaceholderLikelihood.boundary_smoother!","text":"smooth_boundary!(points, point_is_on_bounds)\n\npoints has 2D boundary points stored in columns and are in either clockwise or anticlockwise order of polygon connection. points is edited in place.\n\nPoints that we know are on the provided bounds are not moved/smoothed, although their presence will impact what the smoother tries to do.\n\nSmoother must attempt to ensure that smoothed points don't go outside the level set boundary???? - may need to evaluate ll for every smoothed point to guarantee this.\n\n\n\n\n\n","category":"function"},{"location":"internal_library/bivariate/#PlaceholderLikelihood.refine_search_directions!","page":"Bivariate Functions","title":"PlaceholderLikelihood.refine_search_directions!","text":"Use kmeans with say 9 clusters on either: the polygon boundary points or points sampled within the polygon boundary.\n\nDefine objectives for the cluster points: how close each point is to being a star point, e.g. by finding which cluster point can see the most boundary points (i.e. there isn’t a edge in the way) - this is a form of regularisation by discretisation; we’re assuming that the boundary defined by a polygon with straight lines between boundary points is relatively consistent with the true shape. Additionally, we assume that our boundary points are relatively well spaced out so that the objective isn’t biased by a ton of our known points being located in a specific portion of the boundary.\n\nIf we find a star point (or multiple) then we should use that point to push out radially (e.g. instead of the MLE point). Note: If boundary is convex, all points in our set are star points by definition. If concave if star point exists use that for continuation, else use kmeans points which are likely to be star points for their local sections\n\nSecond obj we can use to tie break is how close each cluster point is to the centre of the polygon boundary (e.g. just using a simple how many points of all points (either the boundary points OR points that are sampled in the boundary) are on either side in x and y axis of the cluster point (and how close these are to 50%).\n\nIf star point doesn't exist then... Presently will use each individual kmeans point as the point to push out from based on the cluster the boundary point belongs to. In future perhaps use point closest to being a star point for all vertices it is a star point for?? And then other points for the others???\n\nReturns whether or not a star point was found (if not, cannot guarantee that the ordering of boundary points will stay the same, and require a TSP iteration after solving for the next level set).\n\n\n\n\n\n","category":"function"},{"location":"user_interface/predictions/#Predictions","page":"Predictions","title":"Predictions","text":"","category":"section"},{"location":"user_interface/predictions/","page":"Predictions","title":"Predictions","text":"Pages = [\"predictions.md\"]","category":"page"},{"location":"user_interface/predictions/","page":"Predictions","title":"Predictions","text":"In the event that a prediction function has not been added to the LikelihoodModel struct yet, we can add one using add_prediction_function!","category":"page"},{"location":"user_interface/predictions/","page":"Predictions","title":"Predictions","text":"add_prediction_function!\ncheck_prediction_function_exists","category":"page"},{"location":"user_interface/predictions/#PlaceholderLikelihood.add_prediction_function!","page":"Predictions","title":"PlaceholderLikelihood.add_prediction_function!","text":"add_prediction_function!(model::LikelihoodModel, predictfunction::Function)\n\nAdds a prediction function, predictfunction, to model.\n\nRequirements for predictfunction: a function to generate model predictions from that is paired with the loglikefunction. Takes three arguments, θ, data and t, in that order, where θ and data are the same as for loglikefunction and t needs to be an optional third argument. When t is not specified, the prediction function should be evaluated for the same time points/independent variable as the data. When t is specified, the prediction function should be evaluated for those specified time points/independent variable.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/predictions/#PlaceholderLikelihood.check_prediction_function_exists","page":"Predictions","title":"PlaceholderLikelihood.check_prediction_function_exists","text":"check_prediction_function_exists(model::LikelihoodModel)\n\nChecks if a prediction function is stored in model.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/predictions/","page":"Predictions","title":"Predictions","text":"Then to generate predictions we can use one of three functions, depending on whether we want to generate predictions from univariate or bivariate profiles, or dimensional samples.","category":"page"},{"location":"user_interface/predictions/","page":"Predictions","title":"Predictions","text":"generate_predictions_univariate!\ngenerate_predictions_bivariate! \ngenerate_predictions_dim_samples!","category":"page"},{"location":"user_interface/predictions/#PlaceholderLikelihood.generate_predictions_univariate!","page":"Predictions","title":"PlaceholderLikelihood.generate_predictions_univariate!","text":"\n\n\n\n","category":"function"},{"location":"user_interface/predictions/#Structs","page":"Predictions","title":"Structs","text":"","category":"section"},{"location":"user_interface/predictions/","page":"Predictions","title":"Predictions","text":"AbstractPredictionStruct\nPredictionStruct","category":"page"},{"location":"user_interface/predictions/#PlaceholderLikelihood.AbstractPredictionStruct","page":"Predictions","title":"PlaceholderLikelihood.AbstractPredictionStruct","text":"AbstractPredictionStruct\n\nSupertype for the predictions storage struct.\n\nSubtypes\n\nPredictionStruct\n\n\n\n\n\n","category":"type"},{"location":"user_interface/predictions/#PlaceholderLikelihood.PredictionStruct","page":"Predictions","title":"PlaceholderLikelihood.PredictionStruct","text":"PredictionStruct(predictions::Array{Real}, extrema::Array{Real})\n\nStruct for containing evaluated predictions corresponding to confidence profiles.\n\nFields\n\npredictions: array of model predictions evaluated at the parameters given by a particular confidence profile parameter set. If a model has multiple predictive variables, it assumes that model.predictfunction stores the prediction for each variable in its columns. We are going to store values for each variable in the 3rd dimension (row=dim1, col=dim2, page/sheet=dim3). Each column corresponds to a column of the confidence profile parameter set. \nextrema: extrema of the predictions array.\n\nSupertype Hiearachy\n\nPredictionStruct <: AbstractPredictionStruct <: Any\n\n\n\n\n\n","category":"type"},{"location":"internal_library/univariate/#Univariate-Functions","page":"Univariate Functions","title":"Univariate Functions","text":"","category":"section"},{"location":"internal_library/univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"Pages = [\"univariate.md\"]","category":"page"},{"location":"internal_library/univariate/#Initialisation-and-Array-Mapping","page":"Univariate Functions","title":"Initialisation and Array Mapping","text":"","category":"section"},{"location":"internal_library/univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"PlaceholderLikelihood.variablemapping1dranges\nPlaceholderLikelihood.variablemapping1d!\nPlaceholderLikelihood.boundsmapping1d!\nPlaceholderLikelihood.init_univariate_parameters","category":"page"},{"location":"internal_library/univariate/#Likelihood-Optimisation","page":"Univariate Functions","title":"Likelihood Optimisation","text":"","category":"section"},{"location":"internal_library/univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"PlaceholderLikelihood.univariateΨ_ellipse_unbounded\nPlaceholderLikelihood.univariateΨ","category":"page"},{"location":"internal_library/univariate/#Get-Points-in-Confidence-Interval","page":"Univariate Functions","title":"Get Points in Confidence Interval","text":"","category":"section"},{"location":"internal_library/univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"PlaceholderLikelihood.update_uni_dict_internal!\nPlaceholderLikelihood.get_points_in_interval_single_row","category":"page"},{"location":"internal_library/univariate/#PlaceholderLikelihood.update_uni_dict_internal!","page":"Univariate Functions","title":"PlaceholderLikelihood.update_uni_dict_internal!","text":"update_uni_dict_internal!(model::LikelihoodModel,\n    uni_row_number::Int,\n    points::PointsAndLogLikelihood)\n\nUpdates the interval_points field of a UnivariateConfidenceStruct, for the profile related to uni_row_number stored at model.uni_profiles_dict[uni_row_number], with the interval points stored in points.\n\n\n\n\n\n","category":"function"},{"location":"internal_library/univariate/#PlaceholderLikelihood.get_points_in_interval_single_row","page":"Univariate Functions","title":"PlaceholderLikelihood.get_points_in_interval_single_row","text":"get_points_in_interval_single_row(univariate_optimiser::Function, \n    model::LikelihoodModel,\n    num_points_in_interval::Int,\n    θi::Int,\n    profile_type::AbstractProfileType,\n    current_interval_points::PointsAndLogLikelihood,\n    additional_width::Real=0.0)\n\nMethod for getting num_points_in_interval points inside a confidence interval for parameter θi, directly called by PlaceholderLikelihood.univariate_confidenceinterval and called via it's other method for get_points_in_interval. Optionally adds additional_width outside of the confidence interval, so long as a parameter bound is not reached. If a bound is reached, up until the bound will be considered instead.\n\n\n\n\n\nget_points_in_interval_single_row(model::LikelihoodModel,\n    uni_row_number::Int,\n    num_points_in_interval::Int,\n    additional_width::Real)\n\nAlternate method called by get_points_in_interval.\n\n\n\n\n\n","category":"function"},{"location":"internal_library/univariate/#Main-Confidence-Interval-Logic","page":"Univariate Functions","title":"Main Confidence Interval Logic","text":"","category":"section"},{"location":"internal_library/univariate/","page":"Univariate Functions","title":"Univariate Functions","text":"PlaceholderLikelihood.get_interval_brackets\nPlaceholderLikelihood.add_uni_profiles_rows!\nPlaceholderLikelihood.set_uni_profiles_row!\nPlaceholderLikelihood.get_univariate_opt_func\nPlaceholderLikelihood.univariate_confidenceinterval\nPlaceholderLikelihood.univariate_confidenceinterval_master","category":"page"},{"location":"internal_library/univariate/#PlaceholderLikelihood.get_interval_brackets","page":"Univariate Functions","title":"PlaceholderLikelihood.get_interval_brackets","text":"get_interval_brackets(model::LikelihoodModel, \n    θi::Int, \n    confidence_level::Float64, \n    profile_type::AbstractProfileType)\n\nReturns updated interval brackets (Float64 vectors of length two) if smaller or larger confidence level profiles exist for θi, such that the region to bracket over for the left and right sides of the confidence internval is smallest. Otherwise, returns empty brackets (Float64[]).\n\n\n\n\n\n","category":"function"},{"location":"internal_library/univariate/#PlaceholderLikelihood.add_uni_profiles_rows!","page":"Univariate Functions","title":"PlaceholderLikelihood.add_uni_profiles_rows!","text":"add_uni_profiles_rows!(model::LikelihoodModel, num_rows_to_add::Int)\n\nAdds num_rows_to_add free rows to model.uni_profiles_df by vertically concatenating the existing DataFrame and free rows using PlaceholderLikelihood.init_uni_profiles_df.\n\n\n\n\n\n","category":"function"},{"location":"internal_library/univariate/#PlaceholderLikelihood.set_uni_profiles_row!","page":"Univariate Functions","title":"PlaceholderLikelihood.set_uni_profiles_row!","text":"set_uni_profiles_row!(model::LikelihoodModel, \n    row_ind::Int, \n    θi::Int,\n    not_evaluated_internal_points::Bool, \n    not_evaluated_predictions::Bool,\n    confidence_level::Float64, \n    profile_type::AbstractProfileType, \n    num_points::Int, \n    additional_width::Real)\n\nSets the relevant fields of row row_ind in model.uni_profiles_df after a profile has been evaluated.\n\n\n\n\n\n","category":"function"},{"location":"internal_library/univariate/#PlaceholderLikelihood.get_univariate_opt_func","page":"Univariate Functions","title":"PlaceholderLikelihood.get_univariate_opt_func","text":"get_univariate_opt_func(profile_type::AbstractProfileType=LogLikelihood())\n\nReturns the correct univariate optimisation function used to for find the optimal values of nuisance parameters for a given interest parameter value for the profile_type log-likelihood function. The optimisation function returns the value of the profile_type log-likelihood function as well as finding the optimal nuisance parameters and saving these in one of it's inputs.\n\nWill be PlaceholderLikelihood.univariateΨ for the LogLikelihood() and EllipseApprox() profiles types and PlaceholderLikelihood.univariateΨ_ellipse_unbounded for the EllipseApproxAnalytical profile type.\n\n\n\n\n\n","category":"function"},{"location":"internal_library/univariate/#PlaceholderLikelihood.univariate_confidenceinterval","page":"Univariate Functions","title":"PlaceholderLikelihood.univariate_confidenceinterval","text":"univariate_confidenceinterval!(p::Progress,\n    univariate_optimiser::Function, \n    model::LikelihoodModel, \n    consistent::NamedTuple, \n    θi::Int, \n    confidence_level::Float64,\n    profile_type::AbstractProfileType,\n    mle_targetll::Float64,\n    use_existing_profiles::Bool,\n    num_points_in_interval::Int,\n    additional_width::Real)\n\nReturns a UnivariateConfidenceStruct containing the likelihood-based confidence interval for interest parameter θi at confidence_level, and any additional points within the interval if num_points_in_interval > 0 as well as outside the interval if num_points_in_interval > 0 and additional_width > 0. Log-likelihood values, standardised to 0.0 at the MLE point, for all points found in the interval are also stored in the UnivariateConfidenceStruct.\n\nIf use_existing_profiles=true then the brackets used to find each side of the confidence interval (between each side of the bounds for θi and the MLE point), will be updated and made smaller if confidence profiles for θi already exist at lower and higher confidence levels. \n\nCalled by univariate_confidenceintervals!.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/profiles_and_samples/bivariate/#Bivariate-Profiles","page":"Bivariate Profiles","title":"Bivariate Profiles","text":"","category":"section"},{"location":"user_interface/profiles_and_samples/bivariate/","page":"Bivariate Profiles","title":"Bivariate Profiles","text":"Pages = [\"bivariate.md\"]","category":"page"},{"location":"user_interface/profiles_and_samples/bivariate/","page":"Bivariate Profiles","title":"Bivariate Profiles","text":"bivariate_confidenceprofiles!","category":"page"},{"location":"user_interface/profiles_and_samples/bivariate/#PlaceholderLikelihood.bivariate_confidenceprofiles!","page":"Bivariate Profiles","title":"PlaceholderLikelihood.bivariate_confidenceprofiles!","text":"bivariate_confidenceprofiles!(model::LikelihoodModel, \n    θcombinations::Vector{Vector{Int}}, \n    num_points::Int; \n    <keyword arguments>)\n\nFinds num_points profile_type boundary points at a specified confidence_level for each combination of two interest parameters using a specified method, optionally saving any found internal points. Saves these profiles by modifying model in place.\n\nArguments\n\nmodel: a LikelihoodModel containing model information, saved profiles and predictions.\nθcombinations: vector of pairs of parameters to profile, as a vector of vectors of model parameter indexes.\nnum_points: number of points to find on the boundary at the specified confidence level. Depending on the method, if a region of the user-provided bounds is inside the boundary some of these points will be on the bounds and inside the boundary. \n\nKeyword Arguments\n\nconfidence_level: a number ∈ (0.0, 1.0) for the confidence level on which to find the profile_type boundary. Default is 0.95 (95%).\nprofile_type: whether to use the true log-likelihood function or an ellipse approximation of the log-likelihood function centred at the MLE (with optional use of parameter bounds). Available profile types are LogLikelihood, EllipseApprox and EllipseApproxAnalytical. Default is LogLikelihood() (LogLikelihood).\nmethod: a method of type AbstractBivariateMethod. For a list of available methods use bivariate_methods() (bivariate_methods). Default is RadialRandomMethod(3) (RadialRandomMethod).\nθcombinations_is_unique: boolean variable specifying whether all parameter combinations in θcombinations are ordered by parameter index (ascending) and are unique. Default is false.\nsave_internal_points: boolean variable specifying whether to save points found inside the boundary during boundary computation. Internal points can be plotted in bivariate profile plots and will be used to generate predictions from a given bivariate profile. Default is true.\nexisting_profiles: Symbol ∈ [:ignore, :merge, :overwrite] specifying what to do if profiles already exist for a given θcombination, confidence_level, profile_type and method. See below for each symbol's meanings. Default is :merge.\nshow_progress: boolean variable specifying whether to display progress bars on the percentage of θcombinations completed and estimated time of completion. Default is model.show_progress.\n\nnote: existing_profiles meanings\n:ignore means profiles that already exist will not be recomputed even if they contain fewer num_points boundary points. \n:merge means profiles that already exist will be merged with profiles from the current algorithm run to reach num_points. If the existing profile already has at least num_points boundary points then that profile will not be recomputed. Otherwise, the specified method will be run starting from the difference between num_points and the number of points in the existing profile. The result of that method run will be merged with the existing profile.  \n:overwrite means profiles that already exist will be overwritten, regardless of how many points they contain.\n\nDetails\n\nUsing bivariate_confidenceprofile this function calls the algorithm/method specified by method for each parameter combination in θcombinations (depending on the setting for existing_profiles and num_points if these profiles already exist). Updates model.biv_profiles_df for each successful profile and saves their results as a BivariateConfidenceStruct in model.biv_profiles_dict, where the keys for the dictionary is the row number in model.biv_profiles_df of the corresponding profile.\n\n\n\n\n\nbivariate_confidenceprofiles!(model::LikelihoodModel, \n    θcombinations_symbols::Union{Vector{Vector{Symbol}}, Vector{Tuple{Symbol, Symbol}}}, \n    num_points::Int; \n    <keyword arguments>)\n\nProfiles just the provided θcombinations_symbols parameter pairs, provided as either a vector of vectors or a vector of tuples.\n\n\n\n\n\nbivariate_confidenceprofiles!(model::LikelihoodModel, \n    profile_m_random_combinations::Int, \n    num_points::Int; \n    <keyword arguments>)\n\nProfiles m random two-way combinations of model parameters (sampling without replacement), where 0 < m ≤ binomial(model.core.num_pars,2).\n\nwarning: θcombinations_is_unique keyword argument\nθcombinations_is_unique is not a valid keyword argument for this function method as it internally produces the parameter combinations which are guaranteed to be unique.\n\n\n\n\n\nbivariate_confidenceprofiles!(model::LikelihoodModel, \n    num_points::Int; \n    <keyword arguments>)\n\nProfiles all two-way combinations of model parameters.\n\nwarning: θcombinations_is_unique keyword argument\nθcombinations_is_unique is not a valid keyword argument for this function method as it internally produces the parameter combinations which are guaranteed to be unique.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/profiles_and_samples/bivariate/#Methods","page":"Bivariate Profiles","title":"Methods","text":"","category":"section"},{"location":"user_interface/profiles_and_samples/bivariate/","page":"Bivariate Profiles","title":"Bivariate Profiles","text":"AbstractBivariateMethod\nAbstractBivariateVectorMethod\nbivariate_methods\nIterativeBoundaryMethod\nRadialMLEMethod\nRadialRandomMethod\nSimultaneousMethod\nFix1AxisMethod\nAnalyticalEllipseMethod\nContinuationMethod","category":"page"},{"location":"user_interface/profiles_and_samples/bivariate/#PlaceholderLikelihood.AbstractBivariateMethod","page":"Bivariate Profiles","title":"PlaceholderLikelihood.AbstractBivariateMethod","text":"AbstractBivariateMethod\n\nSupertype for bivariate boundary finding methods. Use bivariate_methods() for a list of available methods (see bivariate_methods).\n\nSubtypes\n\nAbstractBivariateVectorMethod\n\nFix1AxisMethod\n\nContinuationMethod\n\nAnalyticalEllipseMethod\n\n\n\n\n\n","category":"type"},{"location":"user_interface/profiles_and_samples/bivariate/#PlaceholderLikelihood.AbstractBivariateVectorMethod","page":"Bivariate Profiles","title":"PlaceholderLikelihood.AbstractBivariateVectorMethod","text":"AbstractBivariateVectorMethod <: AbstractBivariateMethod\n\nSupertype for bivariate boundary finding methods that search between two distinct points. \n\nSubtypes\n\nIterativeBoundaryMethod\n\nRadialMLEMethod\n\nRadialRandomMethod\n\nSimultaneousMethod\n\nSupertype Hiearachy\n\nAbstractBivariateVectorMethod <: AbstractBivariateMethod <: Any\n\n\n\n\n\n","category":"type"},{"location":"user_interface/profiles_and_samples/bivariate/#PlaceholderLikelihood.bivariate_methods","page":"Bivariate Profiles","title":"PlaceholderLikelihood.bivariate_methods","text":"bivariate_methods()\n\nPrints a list of available bivariate methods. Available bivariate methods include IterativeBoundaryMethod, RadialRandomMethod, RadialMLEMethod, SimultaneousMethod, Fix1AxisMethod, ContinuationMethod and AnalyticalEllipseMethod.\n\n\n\n\n\n","category":"function"},{"location":"user_interface/profiles_and_samples/bivariate/#PlaceholderLikelihood.IterativeBoundaryMethod","page":"Bivariate Profiles","title":"PlaceholderLikelihood.IterativeBoundaryMethod","text":"IterativeBoundaryMethod(initial_num_points::Int, \n    angle_points_per_iter::Int, \n    edge_points_per_iter::Int, \n    radial_start_point_shift::Float64=rand(), \n    ellipse_sqrt_distortion::Float64=1.0, \n    use_ellipse::Bool=false)\n\nMethod for iteratively improving an initial boundary of initial_num_points, found by pushing out from the MLE point in directions defined by either RadialMLEMethod, use_ellipse=true, or [RadialRandomMethod], use_ellipse=false (see PlaceholderLikelihood.findNpointpairs_radialMLE!, PlaceholderLikelihood.iterativeboundary_init and PlaceholderLikelihood.bivariate_confidenceprofile_iterativeboundary).\n\nArguments\n\ninitial_num_points: a positive integer number of initial boundary points to find. \nangle_points_per_iter: a integer ≥ 0 for the number of edges to explore and improve based on the angle objective before switching to the edge objective. If angle_points_per_iter > 0 and edge_points_per_iter > 0 the angle objective is considered first.\nedge_points_per_iter:  a integer ≥ 0 for the number of edges to explore and improve based on the edge objective before switching back to the angle objective. If angle_points_per_iter > 0 and edge_points_per_iter > 0 the angle objective is considered first.\nradial_start_point_shift: a number ∈ [0.0,1.0]. Default is rand() (defined on [0.0,1.0]), meaning that by default a different set of initial points will be found each time.\nellipse_sqrt_distortion: a number ∈ [0.0,1.0]. Default is 0.01. \n\nKeyword Arguments\n\nuse_ellipse: Whether to find initial_num_points by searching in directions defined by an ellipse approximation, as in RadialMLEMethod, or , as in RadialRandomMethod. Default is false.\n\nDetails\n\nFor additional information on the radial_start_point_shift and ellipse_sqrt_distortion arguments see the keyword arguments for generate_N_clustered_points in EllipseSampling.jl.\n\nRecommended for use with the LogLikelihood profile type. Radial directions, edge length and internal angle calculations are rescaled by the relative magnitude/scale of the two interest parameters. This is so directions and regions explored and consequently the boundary found are not dominated by the parameter with the larger magnitude.\n\nOnce an initial boundary is found by pushing out from the MLE point in directions defined by either RadialMLEMethod or [RadialRandomMethod], the method seeks to improve this boundary by minimising an internal angle and an edge length objective, each considered sequentially, until the desired number of boundary points are found. As such, the method can be thought of as a mesh smoothing or improvement algorithm; we can consider the boundary found at a given moment in time to be a N-sided polygon with edges between adjacent boundary points (vertices). \n\nRegions we define as needing improvement are those with:\n\nInternal angles between adjacent edges that are far from being straight (180 degrees or π radians). The region defined by these edges is not well explored as the real boundary edge in this region likely has some degree of smooth curvature. It may also indicate that one of these edges cuts our boundary into a enclosed region and an unexplored region on the other side of the edge. In the event that a vertex is on a user-provided bound for a parameter, this objective is set to zero, as this angle region is a byproduct of user input and not the actual log-likelihood region. This objective is defined in PlaceholderLikelihood.internal_angle_from_pi!.\nEdges between adjacent vertices that have a large euclidean distance. The regions between these vertices is not well explored as it is unknown whether the boundary actually is straight between these vertices. On average the closer two vertices are, the more likely the edge between the two points is well approximated by a straight line, and thus our mesh is a good representation of the true log-likelihood boundary. This objective is defined in PlaceholderLikelihood.edge_length.\n\nThe method is implemented as follows:\n\nCreate edges between adjacent vertices on the intial boundary. Calculate angle and edge length objectives for these edges and vertices and place them into tracked heaps.\nUntil found the desired number of boundary points repeat steps 3 and 4.\nFor angle_points_per_iter points:\nPeek at the top vertex of the angle heap.\nPlace a candidate point in the middle of the edge connected to this vertex that has the larger angle at the vertex the edge connects to. This is so we explore the worse defined region of the boundary.\nUse this candidate to find a new boundary point (see below).\nIf found a new boundary point, break edge we placed candidate on and replace with edges to the new boundary point, updating angle and edge length objectives in the tracked heap (see PlaceholderLikelihood.heapupdates_success!). Else break our polygon into multiple polygons (see PlaceholderLikelihood.heapupdates_failure).\nFor edge_points_per_iter points:\nPeek at the top edge of the edge heap.\nPlace a candidate point in the middle of this edge.\nSame as for step 3.3.\nSame as for step 3.4.\n\nnote: angle_points_per_iter and edge_points_per_iter\nAt least one of angle_points_per_iter and edge_points_per_iter must be non-zero.\n\nnote: Using a candidate point to find a new boundary point\nUses PlaceholderLikelihood.newboundarypoint!.If a candidate point is on the log-likelihood threshold boundary, we accept the point.If a candidate point is inside the boundary, then we search in the normal direction to the edge until we find a boundary point or hit the parameter bound, accepting either.If a candidate point is outside the boundary we find the edge, e_intersect of our boundary polygon that is intersected by the line in the normal direction of the candidate edge, which passes through the candidate point. Once this edge is found, we find the vertex on e_intersect that is closest to our candidate point. We setup a 1D line search/bracketing method between these two points. In the event that no boundary points are found between these two points it is likely that multiple boundaries exist. If so, we break the candidate point's edge and e_intersect and reconnect the vertexes such that we now have multiple boundary polygons.\n\nwarning: Largest boundary polygon at any iteration must have at least three points\nIf the largest polygon has less than two points the method will display a warning message and terminate, returning the boundary found up until then. \n\nBoundary finding method\n\nFor the initial boundary, it uses a 1D bracketing algorithm between the MLE point and the point on the user-provided bounds in the search directions to find the boundary at the desired confidence level. For boundary improvement, if the candidate point is inside the boundary, it uses a 1D bracketing algorithm between an internal point and the point on the user-provided bounds in the search direction. If the candidate point is outside the boundary, it uses a derivative-free 1D line search algorithm in the search direction. If the derivative-free approach fails, it switches to a bracketing heuristic between the candidate point and closest vertex on e_intersect.\n\nThis method is unlikely to find boundaries that do not contain the MLE point (if they exist), but it can find them. If a boundary that does not contain the MLE point is found, it is not guaranteed to be explored. In this case the the method will inform the user that multiple boundaries likely exist for this combination of model parameters.\n\nImpact of parameter bounds\n\nIf a parameter bound is in the way of reaching the boundary in a given search direction, the point on that bound will be returned as the boundary point. For the bracketing method to work, parameter values on the bounds need to be legal and return a non Inf value from the log-likelihood function. Interest parameter bounds that have ranges magnitudes larger than the range of the boundary may prevent the true boundary from being found. Additionally, the bracketing method will be less efficient if the interest parameter bounds are far from the true boundary. \n\nInternal Points\n\nFinds between 0 and num_points - initial_num_points internal points - internal points are found when the edge being considered's midpoint is inside the boundary. \n\nSupertype Hiearachy\n\nIterativeBoundaryMethod <: AbstractBivariateVectorMethod <: AbstractBivariateMethod <: Any\n\n\n\n\n\n","category":"type"},{"location":"user_interface/profiles_and_samples/bivariate/#PlaceholderLikelihood.RadialMLEMethod","page":"Bivariate Profiles","title":"PlaceholderLikelihood.RadialMLEMethod","text":"RadialMLEMethod(ellipse_start_point_shift::Float64=rand(), \n    ellipse_sqrt_distortion::Float64=0.01)\n\nMethod for finding the bivariate boundary of a confidence profile by bracketing between the MLE point and points on the provided bounds in directions given by points found on the boundary of a ellipse approximation of the log-likelihood function around the MLE, e, using EllipseSampling.jl (see PlaceholderLikelihood.findNpointpairs_radialMLE! and PlaceholderLikelihood.bivariate_confidenceprofile_vectorsearch)..\n\nArguments\n\nellipse_start_point_shift: a number ∈ [0.0,1.0]. Default is rand() (defined on [0.0,1.0]), meaning that by default a different set of points will be found each time.\nellipse_sqrt_distortion: a number ∈ [0.0,1.0]. Default is 0.01. \n\nDetails\n\nFor additional information on arguments see the keyword arguments for generate_N_clustered_points in EllipseSampling.jl.\n\nRecommended for use with the EllipseApprox profile type. Will produce reasonable results for the LogLikelihood profile type when bivariate profile boundaries are convex. Otherwise, IterativeBoundaryMethod, which has an option to use a starting solution from RadialMLEMethod, is preferred as it iteratively improves the quality of the boundary and can discover regions not explored by this method. \n\nBoundary finding method\n\nUses a 1D bracketing algorithm between the MLE point and the point on the user-provided bounds in the search directions to find the boundary at the desired confidence level.  \n\nThis method is unlikely to find boundaries that do not contain the MLE point (if they exist).\n\nImpact of parameter bounds\n\nIf a parameter bound is in the way of reaching the boundary in a given search direction, the point on that bound will be returned as the boundary point. For the bracketing method to work, parameter values on the bounds need to be legal and return a non Inf value from the log-likelihood function. Interest parameter bounds that have ranges magnitudes larger than the range of the boundary may prevent the true boundary from being found. Additionally, the bracketing method will be less efficient if the interest parameter bounds are far from the true boundary. \n\nInternal Points\n\nFinds no internal points.\n\nSupertype Hiearachy\n\nRadialMLEMethod <: AbstractBivariateVectorMethod <: AbstractBivariateMethod <: Any\n\n\n\n\n\n","category":"type"},{"location":"user_interface/profiles_and_samples/bivariate/#PlaceholderLikelihood.RadialRandomMethod","page":"Bivariate Profiles","title":"PlaceholderLikelihood.RadialRandomMethod","text":"RadialRandomMethod(num_radial_directions::Int)\n\nMethod for finding the bivariate boundary of a confidence profile by finding internal boundary points using a uniform random distribution on provided bounds and choosing num_radial_directions to explore from these points (see PlaceholderLikelihood.findNpointpairs_radialRandom! and PlaceholderLikelihood.bivariate_confidenceprofile_vectorsearch).\n\nArguments\n\nnum_radial_directions: an integer greater than zero. \n\nDetails\n\nRecommended for use with the LogLikelihood profile type. Radial directions are rescaled by the relative magnitude/scale of the two interest parameters. This is so directions explored and consequently the boundary found are not dominated by the parameter with the larger magnitude.\n\nThe method first uniformly samples the region specified by the bounds for the two interest parameters until a point within the boundary is found. Then it chooses num_radial_directions, spaced uniformly around a circle, and rotates these directions by a random phase shift ∈ [0.0, 2π/num_directions] radians. These directions are then distorted by the relative magnitude/scale of the two interest parameters. Then for each of these directions, until it runs out of directions or finds the desired number of points, it finds the closest point on the bounds from the internal point in this direction. If the point on the bounds is outside the boundary, it accepts the point pair. A bracketing method is then used to find a boundary point between the point pair (the bound point and the internal point). The method continues searching for internal points and generating directions until the desired number of boundary points is found.\n\nGiven a fixed number of desired boundary points, we can decrease the cost of finding internal points by increasing the number of radial directions to explore, num_radial_directions, at each internal point. However, it is important to balance num_radial_directions with the desired number of boundary points. If num_radial_directions is large relative to the number of boundary points, then the boundary the method finds may constitute a local search around the found internal points. Resultantly, there may be regions were the boundary is not well explored. This will be less of an issue for more 'circular' boundary regions.   \n\nIterativeBoundaryMethod may be preferred over this method if evaluating the log-likelihood function is expensive or the bounds provided for the interest parameters are much larger than the boundary, as the uniform random sampling for internal points will become very expensive. \n\nBoundary finding method\n\nUses a 1D bracketing algorithm between an internal point and the point on the user-provided bounds in the search direction to find the boundary at the desired confidence level.  \n\nThis method can find multiple boundaries (if they exist).\n\nImpact of parameter bounds\n\nIf a parameter bound is in the way of reaching the boundary in a given search direction, in contrast to RadialMLEMethod, the point on that bound will not be returned as the boundary point. For the bracketing method to work, parameter values on the bounds need to be legal and return a non Inf value from the log-likelihood function. Interest parameter bounds that have ranges magnitudes larger than the range of the boundary may prevent the true boundary from being found. Additionally, the bracketing method will be less efficient if the interest parameter bounds are far from the true boundary. The method will fail if the interest parameter bounds are fully contained by the boundary.\n\nInternal Points\n\nFinds a minimum of div(num_points, num_radial_directions, RoundUp) internal points.\n\nSupertype Hiearachy\n\nRadialRandomMethod <: AbstractBivariateVectorMethod <: AbstractBivariateMethod <: Any\n\n\n\n\n\n","category":"type"},{"location":"user_interface/profiles_and_samples/bivariate/#PlaceholderLikelihood.SimultaneousMethod","page":"Bivariate Profiles","title":"PlaceholderLikelihood.SimultaneousMethod","text":"SimultaneousMethod()\n\nMethod for finding the bivariate boundary of a confidence profile by finding internal and external boundary points using a uniform random distribution on provided bounds, pairing these points in the order they're found and bracketing between each pair (see PlaceholderLikelihood.findNpointpairs_simultaneous! and PlaceholderLikelihood.bivariate_confidenceprofile_vectorsearch).\n\nDetails\n\nRecommended for use with the LogLikelihood profile type. \n\nThe method uniformly samples the region specified by the bounds for the two interest parameters until as many internal and external boundary points as the desired number of boundary points are found. These points are paired in the order they are found. A bracketing method is then used to find a boundary point between the point pair (the external point and the internal point).\n\nRadialRandomMethod and IterativeBoundaryMethod are preferred over this method from a computational performance standpoint as they require fewer log-likelihood evalutions (when RadialRandomMethod has parameter num_radial_directions > 1). \n\nBoundary finding method\n\nUses a 1D bracketing algorithm between a valid point pair to find the boundary at the desired confidence level.  \n\nThis method can find multiple boundaries (if they exist).\n\nImpact of parameter bounds\n\nIf a parameter bound is in the way of reaching the boundary, points will not be put on that bound. Additionally, if the true boundary is very close to a parameter bound, the method will struggle to find this region of the boundary. This is because finding the boundary in this location requires generating a random point between the boundary and the parameter bound, which becomes more difficult the closer they are. Interest parameter bounds that have ranges magnitudes larger than the range of the boundary will make finding internal points very difficult, requiring a lot of computational effort. Similarly, the inverse will be true if external points are hard to find. The method will fail if the interest parameter bounds are fully contained by the boundary.\n\nInternal Points\n\nFinds num_points internal points.\n\nSupertype Hiearachy\n\nSimultaneousMethod <: AbstractBivariateVectorMethod <: AbstractBivariateMethod <: Any\n\n\n\n\n\n","category":"type"},{"location":"user_interface/profiles_and_samples/bivariate/#PlaceholderLikelihood.Fix1AxisMethod","page":"Bivariate Profiles","title":"PlaceholderLikelihood.Fix1AxisMethod","text":"Fix1AxisMethod()\n\nMethod for finding the bivariate boundary of a confidence profile by using uniform random distributions on provided bounds to draw a value for one interest parameter, fix it, and draw two values for the other interest parameter, using the pair to find a boundary point using a bracketing method if the pair are a valid bracket (see PlaceholderLikelihood.findNpointpairs_fix1axis! and PlaceholderLikelihood.bivariate_confidenceprofile_fix1axis).\n\nDetails\n\nRecommended for use with the LogLikelihood profile type. \n\nThe method finds the desired number of boundary points by fixing the first and second interest parameters for half of these points each. It first draws a value for the fixed parameter using a uniform random distribution on provided bounds (e.g. Ψx). Then it draws two values for the unfixed parameter in the same fashion (e.g. Ψy1 and Ψy2]). If one of these points ([Ψx, Ψy1] and [Ψx, Ψ_y2]) is an internal point and the other an external point, the point pair is accepted as they are a valid bracket. A bracketing method is then used to find a boundary point between the point pair (the internal and external point). The method continues searching for valid point pairs until the desired number of boundary points is found.\n\nRadialRandomMethod and IterativeBoundaryMethod are preferred over this method from a computational performance standpoint as they require fewer log-likelihood evalutions (when RadialRandomMethod has parameter num_radial_directions > 1). SimultaneousMethod will also likely be more efficient, even though it uses four random numbers vs three, as it doesn't unneccesarily throw away points.  \n\nBoundary finding method\n\nUses a 1D bracketing algorithm between a valid point pair, which are parallel to the x or y axis, to find the boundary at the desired confidence level.  \n\nThis method can find multiple boundaries (if they exist).\n\nImpact of parameter bounds\n\nIf a parameter bound is in the way of reaching the boundary, points will not be put on that bound. Additionally, if the true boundary is very close to a parameter bound, the method will struggle to find this region of the boundary. This is because finding the boundary in this location requires generating a random point between the boundary and the parameter bound, which becomes more difficult the closer they are. Interest parameter bounds that have ranges magnitudes larger than the range of the boundary will make finding internal points very difficult, requiring a lot of computational effort. Similarly, the inverse will be true if external points are hard to find. The method will fail if the interest parameter bounds are fully contained by the boundary.\n\nInternal Points\n\nFinds num_points internal points.\n\nSupertype Hiearachy\n\nFix1AxisMethod <: AbstractBivariateMethod <: Any\n\n\n\n\n\n","category":"type"},{"location":"user_interface/profiles_and_samples/bivariate/#PlaceholderLikelihood.AnalyticalEllipseMethod","page":"Bivariate Profiles","title":"PlaceholderLikelihood.AnalyticalEllipseMethod","text":"AnalyticalEllipseMethod(ellipse_start_point_shift::Float64, \n    ellipse_sqrt_distortion::Float64)\n\nMethod for sampling the desired number of boundary points on a ellipse approximation of the log-likelihood function centred at the maximum likelihood estimate point using EllipseSampling.jl.\n\nArguments\n\nellipse_start_point_shift: a number ∈ [0.0,1.0]. Default is rand() (defined on [0.0,1.0]), meaning that by default a different set of points will be found each time.\nellipse_sqrt_distortion: a number ∈ [0.0,1.0]. Default is 1.0, meaning that by default points on the ellipse approximation are equally spaced with respect to arc length. \n\nDetails\n\nUsed for the EllipseApproxAnalytical profile type only: if this method is specified, then any user provided profile type will be overriden and replaced with EllipseApproxAnalytical. This ellipse approximation ignores user provided bounds.\n\nFor additional information on arguments see the keyword arguments for generate_N_clustered_points in EllipseSampling.jl.\n\nBoundary finding method\n\nExplicitly finds the boundary using EllipseSampling.jl.\n\nInternal Points\n\nFinds no internal points.\n\nSupertype Hiearachy\n\nAnalyticalEllipseMethod <: AbstractBivariateMethod <: Any\n\n\n\n\n\n","category":"type"},{"location":"user_interface/profiles_and_samples/bivariate/#PlaceholderLikelihood.ContinuationMethod","page":"Bivariate Profiles","title":"PlaceholderLikelihood.ContinuationMethod","text":"ContinuationMethod(num_level_sets::Int, \n    ellipse_confidence_level::Float64, \n    ellipse_start_point_shift::Float64=rand(), \n    level_set_spacing::Symbol=:loglikelihood)\n\nKept available for completeness but not recommended for use. A previous implementation of search directions from the MLE point was moved to [RadialMLEMethod].\n\nArguments\n\nnum_level_sets: the number of level sets used to get to the desired confidence level set.\nellipse_confidence_level: a number ∈ (0.0, 1.0). the confidence level at which to construct the initial ellipse and find the initial level set boundary. Recommended to be around 0.1.\nellipse_start_point_shift: a number ∈ [0.0,1.0]. Default is rand() (defined on [0.0,1.0]), meaning that by default a different set of points will be found each time.\nellipse_sqrt_distortion: a number ∈ [0.0,1.0]. Default is 1.0, meaning that by default points on the ellipse approximation are equally spaced with respect to arc length. \nlevel_set_spacing: a Symbol ∈ [:loglikelihood, :confidence]. Whether to space level sets uniformly in confidence level space or log-likelihood space, between the first level set found and the level set of desired confidence level. Default is :loglikelihood.\n\nDetails\n\nThe method finds an initial boundary at a low confidence level close to the ellipse_confidence_level (see initial_continuation_solution!). Then it 'continues' this initial boundary sequentially to num_level_sets higher confidence level boundaries until the desired confidence level is reached. \n\nPresently this continuation is done by finding a point inside the boundary that is as close as possible to being a point that makes the boundary a star domain and is close to the centre of the area of the boundary in the x and y axes. We refer to this point as a 'star point', or a point that can see all the points on the boundary, without being blocked by an edge. We use a heuristic to estimate this, sampling points within the boundary and using these to produce kmeans, of which one is hopefully a star point and at the centre of the boundary. \n\nIf we find a star point we then, for every point on the current boundary, push out in the direction defined by the line segment connecting the star point and the boundary to find the next confidence level boundary. If we do not find a star point, we assign each of the boundary points to the Kmeans point they are closest to (using a Euclidean distance metric), and use the direction defined by the line segments between a boundary point and it's associated Kmeans point to find the next confidence level boundary. This direction heuristic is carried out by refine_search_directions!. \n\nA traveling salesman heuristic is used to reorder the boundary points into a new minimum perimeter polygon, PlaceholderLikelihood.minimum_perimeter_polygon!, if the continuation of one boundary to the next causes the mapping of adjacent vertices to change (expected if a star point is not found). \n\nFor additional information on the ellipse_start_point_shift and ellipse_sqrt_distortion arguments see the keyword arguments for generate_N_clustered_points in EllipseSampling.jl.\n\nBoundary finding method\n\nUses a derivative-free 1D line search algorithm to find the boundary at subsequent confidence levels. If the derivative-free approach fails, it switches to a bracketing algorithm between a given boundary point and the point on the user-provided bounds in the search direction.\n\nThis method is unlikely to find boundaries that do not contain the MLE point (if they exist).\n\nInternal Points\n\nFinds num_points * num_level_sets internal points at distinct level sets.\n\nSupertype Hiearachy\n\nContinuationMethod <: AbstractBivariateMethod <: Any\n\n\n\n\n\n","category":"type"},{"location":"internal_library/ellipse_likelihood/#Ellipse-Functions","page":"Ellipse Functions","title":"Ellipse Functions","text":"","category":"section"},{"location":"internal_library/ellipse_likelihood/","page":"Ellipse Functions","title":"Ellipse Functions","text":"Pages = [\"ellipse_likelihood.md\"]","category":"page"},{"location":"internal_library/ellipse_likelihood/","page":"Ellipse Functions","title":"Ellipse Functions","text":"PlaceholderLikelihood.getMLE_hessian_and_covariance","category":"page"},{"location":"internal_library/ellipse_likelihood/#Likelihood","page":"Ellipse Functions","title":"Likelihood","text":"","category":"section"},{"location":"internal_library/ellipse_likelihood/","page":"Ellipse Functions","title":"Ellipse Functions","text":"PlaceholderLikelihood.analytic_ellipse_loglike\nPlaceholderLikelihood.analytic_ellipse_loglike_1D_soln\nPlaceholderLikelihood.ellipse_loglike\nPlaceholderLikelihood.ellipse_like","category":"page"},{"location":"internal_library/ellipse_likelihood/#PlaceholderLikelihood.analytic_ellipse_loglike","page":"Ellipse Functions","title":"PlaceholderLikelihood.analytic_ellipse_loglike","text":"Analytic ellipse log-likelihood has no knowledge of lower and upper bounds on parameters. Hence profiles generated by optimising out the nuisance parameters for a given interest parameter may look different if the analytical profile enters space where a bound would be active. Pushing forward from these confidence bounds may be infeasible - if analytical profile has entered a space where a parameter bound is active.\n\n\n\n\n\n","category":"function"},{"location":"internal_library/ellipse_likelihood/#PlaceholderLikelihood.analytic_ellipse_loglike_1D_soln","page":"Ellipse Functions","title":"PlaceholderLikelihood.analytic_ellipse_loglike_1D_soln","text":"L^* = -frac12(w_i - w_i^*)^2 * Γ_i(θ^*)^-1\nw_1 =  w_1^* + sqrtfrac-2 L^*Γ_i(θ^*)^-1\n\n\n\n\n\n","category":"function"},{"location":"user_interface/profiles_and_samples/dimensional/#Dimensional-Samples","page":"Dimensional Samples","title":"Dimensional Samples","text":"","category":"section"},{"location":"user_interface/profiles_and_samples/dimensional/","page":"Dimensional Samples","title":"Dimensional Samples","text":"Pages = [\"dimensional.md\"]","category":"page"},{"location":"user_interface/profiles_and_samples/dimensional/","page":"Dimensional Samples","title":"Dimensional Samples","text":"We can generate samples within the loglikelihood boundary at any dimension of model interest parameters.","category":"page"},{"location":"user_interface/profiles_and_samples/dimensional/#Sample-Types","page":"Dimensional Samples","title":"Sample Types","text":"","category":"section"},{"location":"user_interface/profiles_and_samples/dimensional/","page":"Dimensional Samples","title":"Dimensional Samples","text":"AbstractSampleType\nUniformGridSamples\nUniformRandomSamples\nLatinHypercubeSamples","category":"page"},{"location":"user_interface/profiles_and_samples/dimensional/#PlaceholderLikelihood.AbstractSampleType","page":"Dimensional Samples","title":"PlaceholderLikelihood.AbstractSampleType","text":"AbstractSampleType\n\nSupertype for sample types.\n\nSubtypes\n\nUniformGridSamples\n\nUniformRandomSamples\n\nLatinHypercubeSamples\n\n\n\n\n\n","category":"type"},{"location":"user_interface/profiles_and_samples/dimensional/#PlaceholderLikelihood.UniformGridSamples","page":"Dimensional Samples","title":"PlaceholderLikelihood.UniformGridSamples","text":"UniformGridSamples()\n\nEvaluate the parameter bounds space on a uniform grid and keep samples that are inside the particular profile_type's boundary. \n\nSupertype Hiearachy\n\nUniformGridSamples <: AbstractSampleType <: Any\n\n\n\n\n\n","category":"type"},{"location":"user_interface/profiles_and_samples/dimensional/#PlaceholderLikelihood.UniformRandomSamples","page":"Dimensional Samples","title":"PlaceholderLikelihood.UniformRandomSamples","text":"UniformRandomSamples()\n\nTake uniform random samples of parameter bounds space and keep samples that are inside the particular profile_type's boundary. \n\nSupertype Hiearachy\n\nUniformRandomSamples <: AbstractSampleType <: Any\n\n\n\n\n\n","category":"type"},{"location":"user_interface/profiles_and_samples/dimensional/#PlaceholderLikelihood.LatinHypercubeSamples","page":"Dimensional Samples","title":"PlaceholderLikelihood.LatinHypercubeSamples","text":"LatinHypercubeSamples()\n\nCreate a Latin Hypercube sampling plan in parameter bounds space and keep samples that are inside the particular profile_type's boundary. Uses LatinHypercubeSampling.jl.\n\nSupertype Hiearachy\n\nLatinHypercubeSamples <: AbstractSampleType <: Any\n\n\n\n\n\n","category":"type"},{"location":"user_interface/profiles_and_samples/dimensional/#Full-Likelihood-Sampling","page":"Dimensional Samples","title":"Full Likelihood Sampling","text":"","category":"section"},{"location":"user_interface/profiles_and_samples/dimensional/","page":"Dimensional Samples","title":"Dimensional Samples","text":"full_likelihood_sample!","category":"page"},{"location":"user_interface/profiles_and_samples/dimensional/#PlaceholderLikelihood.full_likelihood_sample!","page":"Dimensional Samples","title":"PlaceholderLikelihood.full_likelihood_sample!","text":"full_likelihood_sample!(model::LikelihoodModel,\n    num_points_to_sample::Union{Int, Vector{Int}};\n    confidence_level::Float64=0.95,\n    sample_type::AbstractSampleType=LatinHypercubeSamples(),\n    lb::AbstractVector{<:Real}=Float64[],\n    ub::AbstractVector{<:Real}=Float64[],\n    use_threads::Bool=true,\n    existing_profiles::Symbol=:overwrite)\n\n\n\n\n\n","category":"function"},{"location":"user_interface/profiles_and_samples/dimensional/#Dimensional-Likelihood-Sampling","page":"Dimensional Samples","title":"Dimensional Likelihood Sampling","text":"","category":"section"},{"location":"user_interface/profiles_and_samples/dimensional/","page":"Dimensional Samples","title":"Dimensional Samples","text":"Note: dimensional likelihood samples can be 'full' likelihood samples as well.","category":"page"},{"location":"user_interface/profiles_and_samples/dimensional/","page":"Dimensional Samples","title":"Dimensional Samples","text":"dimensional_likelihood_sample!\nbivariate_concave_hull","category":"page"},{"location":"user_interface/profiles_and_samples/dimensional/#PlaceholderLikelihood.dimensional_likelihood_sample!","page":"Dimensional Samples","title":"PlaceholderLikelihood.dimensional_likelihood_sample!","text":"dimensional_likelihood_sample!(model::LikelihoodModel,\n    θindices::Vector{Vector{Int}},\n    num_points_to_sample::Union{Int, Vector{Int}};\n    confidence_level::Float64=0.95,\n    sample_type::AbstractSampleType=LatinHypercubeSamples(),\n    lb::AbstractVector{<:Real}=Float64[],\n    ub::AbstractVector{<:Real}=Float64[],\n    θs_is_unique::Bool=false,\n    use_threads::Bool=true,\n    existing_profiles::Symbol=:overwrite,\n    show_progress::Bool=model.show_progress)\n\n\n\n\n\n","category":"function"},{"location":"internal_library/dimensional/#Dimensional-Functions","page":"Dimensional Functions","title":"Dimensional Functions","text":"","category":"section"},{"location":"internal_library/dimensional/","page":"Dimensional Functions","title":"Dimensional Functions","text":"Pages = [\"dimensional.md\"]","category":"page"},{"location":"internal_library/dimensional/#Common-Full-and-Dimensional-Likelihood","page":"Dimensional Functions","title":"Common Full and Dimensional Likelihood","text":"","category":"section"},{"location":"internal_library/dimensional/","page":"Dimensional Functions","title":"Dimensional Functions","text":"PlaceholderLikelihood.add_dim_samples_rows!\nPlaceholderLikelihood.set_dim_samples_row!\nPlaceholderLikelihood.valid_points\nPlaceholderLikelihood.check_if_bounds_supplied\nPlaceholderLikelihood.uniform_grid\nPlaceholderLikelihood.uniform_random\nPlaceholderLikelihood.LHS","category":"page"},{"location":"internal_library/dimensional/#Full-Likelihood-Only","page":"Dimensional Functions","title":"Full Likelihood Only","text":"","category":"section"},{"location":"internal_library/dimensional/","page":"Dimensional Functions","title":"Dimensional Functions","text":"PlaceholderLikelihood.full_likelihood_sample","category":"page"},{"location":"internal_library/dimensional/#Dimensional-Likelihood-Only","page":"Dimensional Functions","title":"Dimensional Likelihood Only","text":"","category":"section"},{"location":"internal_library/dimensional/","page":"Dimensional Functions","title":"Dimensional Functions","text":"PlaceholderLikelihood.dimensional_optimiser!\nPlaceholderLikelihood.init_dimensional_parameters\nPlaceholderLikelihood.dimensional_likelihood_sample","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = PlaceholderLikelihood","category":"page"},{"location":"#PlaceholderLikelihood","page":"Home","title":"PlaceholderLikelihood","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for PlaceholderLikelihood.","category":"page"}]
}
