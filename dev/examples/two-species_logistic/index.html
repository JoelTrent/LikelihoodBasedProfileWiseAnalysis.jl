<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Two-Species Logistic Model · LikelihoodBasedProfileWiseAnalysis.jl</title><meta name="title" content="Two-Species Logistic Model · LikelihoodBasedProfileWiseAnalysis.jl"/><meta property="og:title" content="Two-Species Logistic Model · LikelihoodBasedProfileWiseAnalysis.jl"/><meta property="twitter:title" content="Two-Species Logistic Model · LikelihoodBasedProfileWiseAnalysis.jl"/><meta name="description" content="Documentation for LikelihoodBasedProfileWiseAnalysis.jl."/><meta property="og:description" content="Documentation for LikelihoodBasedProfileWiseAnalysis.jl."/><meta property="twitter:description" content="Documentation for LikelihoodBasedProfileWiseAnalysis.jl."/><meta property="og:url" content="https://JoelTrent.github.io/LikelihoodBasedProfileWiseAnalysis.jl/examples/two-species_logistic/"/><meta property="twitter:url" content="https://JoelTrent.github.io/LikelihoodBasedProfileWiseAnalysis.jl/examples/two-species_logistic/"/><link rel="canonical" href="https://JoelTrent.github.io/LikelihoodBasedProfileWiseAnalysis.jl/examples/two-species_logistic/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">LikelihoodBasedProfileWiseAnalysis.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../quick_start/">Quick Start</a></li><li><span class="tocitem">User Interface</span><ul><li><a class="tocitem" href="../../user_interface/initialisation/">Initialisation</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Parameter Profiles and Samples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../user_interface/profiles_and_samples/profile_structs/">Structs and Profile Types</a></li><li><a class="tocitem" href="../../user_interface/profiles_and_samples/univariate/">Univariate Profiles</a></li><li><a class="tocitem" href="../../user_interface/profiles_and_samples/bivariate/">Bivariate Profiles</a></li><li><a class="tocitem" href="../../user_interface/profiles_and_samples/dimensional/">Dimensional Samples</a></li></ul></li><li><a class="tocitem" href="../../user_interface/predictions/">Predictions</a></li><li><a class="tocitem" href="../../user_interface/plots/">Plots</a></li><li><a class="tocitem" href="../../user_interface/saving_and_loading/">Saving and Loading LikelihoodModels</a></li><li><a class="tocitem" href="../../user_interface/timing_and_profiling/">Timing and Profiling</a></li><li><input class="collapse-toggle" id="menuitem-3-7" type="checkbox"/><label class="tocitem" for="menuitem-3-7"><span class="docs-label">Simulated Coverage Checks</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../user_interface/coverage/univariate_intervals/">Parameter Confidence Intervals</a></li><li><a class="tocitem" href="../../user_interface/coverage/bivariate_boundaries/">Bivariate Parameter Confidence Boundaries</a></li><li><a class="tocitem" href="../../user_interface/coverage/predictions_and_realisations/">Predictions and Realisations</a></li></ul></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../">Initial Setup</a></li><li><a class="tocitem" href="../logistic/">Logistic Model</a></li><li><a class="tocitem" href="../lotka-volterra/">Lotka-Volterra Model</a></li><li class="is-active"><a class="tocitem" href>Two-Species Logistic Model</a><ul class="internal"><li><a class="tocitem" href="#With-Logit-Normal-Data-Distribution"><span>With Logit-Normal Data Distribution</span></a></li><li><a class="tocitem" href="#Initial-Setup"><span>Initial Setup</span></a></li><li><a class="tocitem" href="#Model-and-Likelihood-Function-Definition"><span>Model and Likelihood Function Definition</span></a></li><li><a class="tocitem" href="#Initial-Data-and-Parameter-Definition"><span>Initial Data and Parameter Definition</span></a></li><li><a class="tocitem" href="#LikelihoodModel-Initialisation"><span>LikelihoodModel Initialisation</span></a></li><li><a class="tocitem" href="#Full-Parameter-Vector-Confidence-Set-Evaluation"><span>Full Parameter Vector Confidence Set Evaluation</span></a></li><li><a class="tocitem" href="#Profiling"><span>Profiling</span></a></li><li><a class="tocitem" href="#Predictions"><span>Predictions</span></a></li><li><a class="tocitem" href="#Coverage-Testing"><span>Coverage Testing</span></a></li></ul></li><li><a class="tocitem" href="../binomial_normal_approximation/">Gaussian Approximation of a Binomial Distribution</a></li><li><a class="tocitem" href="../logistic_timing_estimates/">Function Evaluation Timing - Logistic Model</a></li></ul></li><li><span class="tocitem">Internal Library</span><ul><li><a class="tocitem" href="../../internal_library/common/">Common Functions</a></li><li><a class="tocitem" href="../../internal_library/initialisation/">Initialisation</a></li><li><a class="tocitem" href="../../internal_library/ellipse_likelihood/">Ellipse Functions</a></li><li><a class="tocitem" href="../../internal_library/univariate/">Univariate Functions</a></li><li><a class="tocitem" href="../../internal_library/bivariate/">Bivariate Functions</a></li><li><a class="tocitem" href="../../internal_library/dimensional/">Dimensional Functions</a></li><li><a class="tocitem" href="../../internal_library/predictions/">Prediction Functions</a></li><li><a class="tocitem" href="../../internal_library/plots/">Plotting Functions</a></li><li><a class="tocitem" href="../../internal_library/coverage/">Coverage Functions</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Two-Species Logistic Model</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Two-Species Logistic Model</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JoelTrent/LikelihoodBasedProfileWiseAnalysis.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JoelTrent/LikelihoodBasedProfileWiseAnalysis.jl/blob/main/docs/src/examples/two-species_logistic.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Two-Species-Logistic-Model"><a class="docs-heading-anchor" href="#Two-Species-Logistic-Model">Two-Species Logistic Model</a><a id="Two-Species-Logistic-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Two-Species-Logistic-Model" title="Permalink"></a></h1><p>The code included in this example is compiled into a single file <a href="https://github.com/JoelTrent/LikelihoodBasedProfileWiseAnalysis.jl/-/tree/main/examples/two-species_logistic.jl">here</a>.</p><p>The two-species logistic model with a Gaussian data distribution [<a href="../../references/#simpsonprofile2023">3</a>] has the following differential equations for the population densities of the two species <span>$C_1(t)\geq0$</span> and <span>$C_2(t)\geq0$</span> :</p><p class="math-container">\[    \frac{\mathrm{d}C(t)}{\mathrm{d}t} = \lambda_1 C_1(t) \Bigg[1-\frac{S(t)}{K}\Bigg],\]</p><p class="math-container">\[    \frac{\mathrm{d}C(t)}{\mathrm{d}t} = \lambda_2 C_2(t) \Bigg[1-\frac{S(t)}{K}\Bigg] - \delta C_2(t) \Bigg[\frac{C_1(t)}{K}\Bigg],\]</p><p>where <span>$S(t) = C_1(t)+C_2(t)$</span>, and the full parameter vector is given by <span>$\theta = (\lambda_1, \lambda_2, K, \delta, C_1(0), C_2(0), \sigma)$</span>. The corresponding additive Gaussian data distribution, with an estimated standard deviation, has a density function for the observed data given by:</p><p class="math-container">\[    y_i \sim p(y_i ; \theta) \sim \mathcal{N}(z_i(\theta^M), \theta^\textrm{o} \mathbb{I}) \sim \mathcal{N}(z_i(\theta^M), \sigma^2_N \mathbb{I}) ,\]</p><p>where <span>$\theta^M = (\lambda_1, \lambda_2, K, \delta, C_1(0), C_2(0))$</span>, <span>$\theta^\textrm{o} = \sigma$</span>, <span>$z_i(\theta^M)=z(t_i; \theta^M) = (C_1(t_i; \theta^M), C_2(t_i; \theta^M))$</span> from the previous equations, meaning at each <span>$t_i$</span> we have an observation of both <span>$C_1(t)$</span> and <span>$C_2(t)$</span>, <span>$y_i^\textrm{o}=(C_{1,\,i}^\textrm{o}, C_{2,\,i}^\textrm{o})$</span>, and <span>$\mathbb{I}$</span> is a <span>$2\times2$</span> identity matrix.</p><p>This model uses real data, so no &#39;true&#39; parameter values exist. Instead, the MLE values of parameters are used for coverage simulations <span>$\hat{\theta} =(0.00293, 0.00315, 0.00164, 78.8, 0.289, 0.0293, 1.83)$</span>. The corresponding lower and upper parameter bounds are <span>$a = (0.0001, 0.0001, 0, 60, 0.01, 0.001, 0.1)$</span> and <span>$b = (0.01, 0.01, 0.01, 90, 1, 1, 3)$</span>; the lower bounds for all the parameters apart from <span>$\delta$</span> were zero [<a href="../../references/#simpsonprofile2023">3</a>] but were increased slightly to increase stability. Observation times are <span>$t_{1:I} = (0, 769, 1140, 1488, 1876, 2233, 2602, 2889, 3213, 3621, 4028)$</span>. Smaller nuisance parameter bounds are used for univariate profiles, although they are wider than those used in [<a href="../../references/#simpsonprofile2023">3</a>]: <span>$a_{\text{nuisance},j} =\max(a_j,\, \hat{\theta}_j\div2.5 ), \, j \in 1,2,...,7$</span> and <span>$b_{\text{nuisance},j} =\min(b_j,\, \hat{\theta}_j\times2.5 ), \, j \in 1,2,...,7$</span>. The original implementation can be found at <a href="https://github.com/ProfMJSimpson/profile_predictions">https://github.com/ProfMJSimpson/profile_predictions</a>.</p><p>Real observations, the MLE model trajectory and the MLE 95% population reference set under this parameterisation can be seen in the figure below (site 2 data is used):</p><p><img src="../../assets/figures/two-species_logistic/two-species_gaussian_example.png" alt/></p><h2 id="With-Logit-Normal-Data-Distribution"><a class="docs-heading-anchor" href="#With-Logit-Normal-Data-Distribution">With Logit-Normal Data Distribution</a><a id="With-Logit-Normal-Data-Distribution-1"></a><a class="docs-heading-anchor-permalink" href="#With-Logit-Normal-Data-Distribution" title="Permalink"></a></h2><p>If we instead use a more statistically realistic logit-normal distribution, defined on (0,1), instead of an additive Gaussian data distribution, the density function for the observed data becomes:</p><p class="math-container">\[    y_i \sim \text{LogitNormal}(\text{logit}(z_i(\theta^M)), \sigma^2\mathbb{I}).\]</p><p>where <span>$\theta^M = (\lambda_1, \lambda_2, K, \delta, C_1(0), C_2(0))$</span>, <span>$\theta^\textrm{o} = \sigma$</span> and <span>$\text{logit}(p)=\log(p\div (1-p))$</span>. The model trajectory, <span>$z_i(\theta^M)$</span>, is assumed to be a proportion <span>$\in (0,1)$</span>.</p><p>The &#39;true&#39; parameter values used for coverage simulations are similar to the MLE values of the parameters when using this data distribution, albeit with a lower value of <span>$\sigma$</span>: <span>$\theta = (0.003, 0.0004, 0.0004, 80.0, 0.4, 1.2, 0.1)$</span>. Parameter bounds have been adjusted slightly to <span>$a = (0.0005, 0.00001, 0.00001, 60, 0.01, 0.1, 0.01)$</span> and <span>$b = (0.01, 0.005, 0.005, 98, 2, 3, 1)$</span> and no &#39;special&#39; nuisance parameter bounds are specified.</p><p>For coverage testing of predictive quantities using the sampled full parameter confidence set, we use much more well-informed parameter bounds that may be overly constrained: <span>$a_\text{sampling} = (0.0022, 0.00001, 0.0001, 73, 0.25, 0.7, 0.03)$</span> and <span>$b_\text{sampling} = (0.0036, 0.001, 0.0009, 85, 0.65, 2, 0.2)$</span>.</p><p>Example observations, the true model trajectory and the 95% population reference set under this parameterisation can be seen in the figure below:</p><p><img src="../../assets/figures/two-species_logistic/two-species_logit-normal_example.png" alt/></p><h2 id="Initial-Setup"><a class="docs-heading-anchor" href="#Initial-Setup">Initial Setup</a><a id="Initial-Setup-1"></a><a class="docs-heading-anchor-permalink" href="#Initial-Setup" title="Permalink"></a></h2><p>Here we add 10 worker processes, given a PC with 12 CPU threads and 32GB RAM. For coverage testing we recommend setting this number as discussed in <a href="../#Import-Package-and-Set-Up-Distributed-Environment">Import Package and Set Up Distributed Environment</a>. We also use <a href="https://juliastats.org/LogExpFunctions.jl/stable/">LogExpFunctions</a> to define the <code>logit</code> function.</p><pre><code class="language-julia hljs">using Distributed
if nprocs()==1; addprocs(10, env=[&quot;JULIA_NUM_THREADS&quot;=&gt;&quot;1&quot;]) end
@everywhere using Random, Distributions, DifferentialEquations
@everywhere using LogExpFunctions
@everywhere using LikelihoodBasedProfileWiseAnalysis
using Combinatorics</code></pre><h2 id="Model-and-Likelihood-Function-Definition"><a class="docs-heading-anchor" href="#Model-and-Likelihood-Function-Definition">Model and Likelihood Function Definition</a><a id="Model-and-Likelihood-Function-Definition-1"></a><a class="docs-heading-anchor-permalink" href="#Model-and-Likelihood-Function-Definition" title="Permalink"></a></h2><p>Here, we will use the logit-normal data distribution. The Gaussian distribution can be used by changing the distribution used in the log-likelihood function, as seen for the <a href="../logistic/#Logistic-Model">Logistic Model</a> and <a href="../lotka-volterra/#Lotka-Volterra-Model">Lotka-Volterra Model</a> examples.</p><p>The logit-normal distribution expects a proportion and our data and model produce a percentage so we are required to divide these through by 100.</p><pre><code class="language-julia hljs">@everywhere function DE!(dC, C, p, t)
    λ1, λ2, δ, KK = p
    S = C[1] + C[2]
    dC[1] = λ1 * C[1] * (1.0 - S/KK)
    dC[2] = λ2 * C[2] * (1.0 - S/KK) - δ*C[2]*C[1]/KK
end

@everywhere function odesolver(t, λ1, λ2, δ, KK, C01, C02)
    p=(λ1, λ2, δ, KK)
    C0=[C01, C02]
    tspan=(0.0, maximum(t))
    prob=ODEProblem(DE!, C0, tspan, p)
    sol=solve(prob, saveat=t)
    return sol[1,:], sol[2,:]
end

@everywhere function ODEmodel(t, θ)
    (y1, y2) = odesolver(t, θ[1], θ[2], θ[3], θ[4], θ[5], θ[6])
    return y1, y2
end

@everywhere function loglhood(θ, data)
    (y1, y2) = ODEmodel(data.t, θ)
    e=0.0
    for i in axes(data.y_obs,1)
        e += (loglikelihood(LogitNormal(logit(y1[i]/100.), θ[7]), data.y_obs[i,1]/100.) + 
                loglikelihood(LogitNormal(logit(y2[i]/100.), θ[7]), data.y_obs[i,2]/100.))
    end
    return e
end</code></pre><h2 id="Initial-Data-and-Parameter-Definition"><a class="docs-heading-anchor" href="#Initial-Data-and-Parameter-Definition">Initial Data and Parameter Definition</a><a id="Initial-Data-and-Parameter-Definition-1"></a><a class="docs-heading-anchor-permalink" href="#Initial-Data-and-Parameter-Definition" title="Permalink"></a></h2><pre><code class="language-julia hljs"># true data
t=[0, 769, 1140, 1488, 1876, 2233, 2602, 2889, 3213, 3621, 4028]
data11=[0.748717949, 0.97235023, 5.490243902, 17.89100529, 35, 56.38256703, 64.55087666, 66.61940299, 71.67362453, 80.47179487, 79.88291457]
data12=[1.927065527, 0.782795699, 1.080487805, 2.113227513, 3.6, 2.74790376, 2.38089652, 1.8, 0.604574153, 1.305128205, 1.700502513]

# true parameters used for coverage testing
θ_true = [0.003, 0.0004, 0.0004, 80.0, 0.4, 1.2, 0.1]
y_true = hcat(ODEmodel(t, θ_true)...)

# Named tuple of all data required within the log-likelihood function
data = (y_obs=hcat(data11,data12), t=t)

# Bounds on model parameters 
lb_sample = [0.0022, 0.00001, 0.0001, 73.0, 0.25, 0.7, 0.03]
ub_sample = [0.0036,  0.001, 0.0009, 85., 0.65, 2.0, 0.2]

lb = [0.0005, 0.00001, 0.00001, 60.0, 0.01, 0.1, 0.01]
ub = [0.01, 0.005, 0.005, 98.0, 2.0, 3.0, 1.0]

λ1g=0.002; λ2g=0.002; δg=0.001; KKg=80.0; C0g=[1.0, 1.0]; σg=0.5
θG = [λ1g, λ2g, δg, KKg, C0g[1], C0g[2], σg]

θnames = [:λ1, :λ2, :δ, :K, :C01, :C02, :σ]
par_magnitudes = [0.001, 0.001, 0.001, 10, 1, 1, 1]</code></pre><h2 id="LikelihoodModel-Initialisation"><a class="docs-heading-anchor" href="#LikelihoodModel-Initialisation">LikelihoodModel Initialisation</a><a id="LikelihoodModel-Initialisation-1"></a><a class="docs-heading-anchor-permalink" href="#LikelihoodModel-Initialisation" title="Permalink"></a></h2><p>Here we define a single <a href="../../user_interface/initialisation/#LikelihoodBasedProfileWiseAnalysis.LikelihoodModel"><code>LikelihoodModel</code></a> for sampling and profiling of parameter confidence sets. </p><pre><code class="language-julia hljs">opt_settings = create_OptimizationSettings(solve_kwargs=(maxtime=5,))
model = initialise_LikelihoodModel(loglhood, data, θnames, θG, lb, ub, par_magnitudes, optimizationsettings=opt_settings)</code></pre><h2 id="Full-Parameter-Vector-Confidence-Set-Evaluation"><a class="docs-heading-anchor" href="#Full-Parameter-Vector-Confidence-Set-Evaluation">Full Parameter Vector Confidence Set Evaluation</a><a id="Full-Parameter-Vector-Confidence-Set-Evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Full-Parameter-Vector-Confidence-Set-Evaluation" title="Permalink"></a></h2><p>To evaluate the full parameter vector confidence set at a 95% confidence level we use the following. Note the use of the <code>lb</code> and <code>ub</code> keyword arguments to specify the parameter ranges to sample points across.</p><pre><code class="language-julia hljs">full_likelihood_sample!(model, Int(1e7), use_distributed=true, lb=lb_sample, ub=ub_sample)</code></pre><h2 id="Profiling"><a class="docs-heading-anchor" href="#Profiling">Profiling</a><a id="Profiling-1"></a><a class="docs-heading-anchor-permalink" href="#Profiling" title="Permalink"></a></h2><h3 id="Univariate-Profiles"><a class="docs-heading-anchor" href="#Univariate-Profiles">Univariate Profiles</a><a id="Univariate-Profiles-1"></a><a class="docs-heading-anchor-permalink" href="#Univariate-Profiles" title="Permalink"></a></h3><p>To find the confidence intervals for all seven parameters at a 95% confidence level (the default), we use:</p><pre><code class="language-julia hljs">univariate_confidenceintervals!(model)</code></pre><p>Similarly, if we wish to find simultaneous 95% confidence intervals for the parameters we set the degrees of freedom parameter, <code>dof</code>, to the number of model parameters (instead of <code>1</code>).</p><pre><code class="language-julia hljs">univariate_confidenceintervals!(model, dof=model.core.num_pars) # model.core.num_pars=7</code></pre><h3 id="Bivariate-Profiles"><a class="docs-heading-anchor" href="#Bivariate-Profiles">Bivariate Profiles</a><a id="Bivariate-Profiles-1"></a><a class="docs-heading-anchor-permalink" href="#Bivariate-Profiles" title="Permalink"></a></h3><p>To evaluate the bivariate boundaries for all 21 bivariate parameter combinations, here we use the <a href="../../user_interface/profiles_and_samples/bivariate/#LikelihoodBasedProfileWiseAnalysis.RadialMLEMethod"><code>RadialMLEMethod</code></a>, which uses a 20 point ellipse approximation of the boundary as a starting guess. The boundaries in this example are reasonably convex, which makes this starting guess appropriate. To speed up computation we provide stronger optimization settings.</p><pre><code class="language-julia hljs">opt_settings = create_OptimizationSettings(solve_kwargs=(maxtime=5, xtol_rel=1e-12))
bivariate_confidenceprofiles!(model, 20, 
    method=RadialMLEMethod(0.15, 0.01),
    optimizationsettings=opt_settings)</code></pre><p>Similarly, if we wish to evaluate simultaneous 95% bivariate profiles we set the degrees of freedom parameter, <code>dof</code>, to the number of model parameters (instead of <code>2</code>).</p><pre><code class="language-julia hljs">opt_settings = create_OptimizationSettings(solve_kwargs=(maxtime=5, xtol_rel=1e-12))
bivariate_confidenceprofiles!(model, 20, 
    method=RadialMLEMethod(0.15, 0.01), 
    dof=model.core.num_pars,
    optimizationsettings=opt_settings)</code></pre><h3 id="Plots-of-Profiles"><a class="docs-heading-anchor" href="#Plots-of-Profiles">Plots of Profiles</a><a id="Plots-of-Profiles-1"></a><a class="docs-heading-anchor-permalink" href="#Plots-of-Profiles" title="Permalink"></a></h3><p>To visualise plots of these profiles we load <a href="https://docs.juliaplots.org/stable/">Plots</a> alongside a plotting backend. Here we use <a href="https://github.com/jheinen/GR.jl">GR</a>.</p><pre><code class="language-julia hljs">using Plots, Plots.PlotMeasures; gr()
Plots.reset_defaults(); Plots.scalefontsizes(0.75)</code></pre><p>Univariate and bivariate profiles can either be visualised individually or in comparison to profiles at the same confidence level and degrees of freedom. </p><p>Here we plot the first two univariate profiles formed at a 95% confidence level and 1 degree of freedom.</p><pre><code class="language-julia hljs">plts = plot_univariate_profiles(model, θs_to_plot=[1,2],
    confidence_levels=[0.95], dofs=[1])

plt = plot(plts..., layout=(1,2),
    legend=:outertop, title=&quot;&quot;, dpi=150, size=(550,300), margin=1mm)
display(plt)</code></pre><p><img src="../../assets/figures/two-species_logistic/two-species_logistic_univariate_plots.png" alt/></p><p>Similarly, here we plot the first two simultaneous bivariate profiles formed at a 95% confidence level and 7 degrees of freedom.</p><pre><code class="language-julia hljs">plts = plot_bivariate_profiles(model, θcombinations_to_plot=[[1,2], [1,3]],
    confidence_levels=[0.95], dofs=[model.core.num_pars])

plt = plot(plts..., layout=(1,2),
    legend=:outertop, title=&quot;&quot;, dpi=150, size=(550,300), margin=1mm)
display(plt)</code></pre><p><img src="../../assets/figures/two-species_logistic/two-species_logistic_bivariate_plots.png" alt/></p><h2 id="Predictions"><a class="docs-heading-anchor" href="#Predictions">Predictions</a><a id="Predictions-1"></a><a class="docs-heading-anchor-permalink" href="#Predictions" title="Permalink"></a></h2><p>To make predictions for the model trajectory and the <span>$1-\delta$</span> population reference set we define the following functions, which then need to be added to our <a href="../../user_interface/initialisation/#LikelihoodBasedProfileWiseAnalysis.LikelihoodModel"><code>LikelihoodModel</code></a>. The <code>region</code> variable in <code>errorfunction</code> should be set equal to <span>$1-\delta$</span> when generating predictions. These could also be added in <a href="../../user_interface/initialisation/#LikelihoodBasedProfileWiseAnalysis.initialise_LikelihoodModel"><code>initialise_LikelihoodModel</code></a>.</p><pre><code class="language-julia hljs">@everywhere function predictfunction(θ, data, t=data.t)
    y1, y2 = ODEmodel(t, θ) 
    y = hcat(y1,y2)
    return y
end

@everywhere function errorfunction(predictions, θ, region)
    lq, uq = logitnormal_error_σ_estimated(predictions ./ 100, θ, region, 7)
    lq .= lq .* 100
    uq .= uq .* 100
    return lq, uq
end

add_prediction_function!(model, predictfunction)
add_error_function!(model, errorfunction)</code></pre><p>To generate profile-wise predictions for each of the evaluated profiles we first define the desired time points for prediction and then evaluate the approximate model trajectory confidence sets and <span>$(1-\delta, 1-\alpha)$</span> population reference tolerance sets. By default, the population reference tolerance set evaluates reference interval regions at the same level as the default confidence level (<span>$1-\delta = 1-\alpha = 0.95$</span>); however, this is not required. </p><pre><code class="language-julia hljs">t_pred=LinRange(t[1], t[end], 201)

generate_predictions_univariate!(model, t_pred)
generate_predictions_bivariate!(model, t_pred)
generate_predictions_dim_samples!(model, t_pred) # for the full likelihood sample</code></pre><h3 id="Plotting-Predictions"><a class="docs-heading-anchor" href="#Plotting-Predictions">Plotting Predictions</a><a id="Plotting-Predictions-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting-Predictions" title="Permalink"></a></h3><p>We can plot the predictions of individual profiles or the union of all profiles at a given number of interest parameters, confidence level, degrees of freedom and reference interval region (if relevant). When plotting the union of these predictions we can compare it to the result of the full likelihood sample, which here used <a href="../../user_interface/profiles_and_samples/dimensional/#LikelihoodBasedProfileWiseAnalysis.LatinHypercubeSamples"><code>LatinHypercubeSamples</code></a>, the default. Here we plot the results from simultaneous profiles.</p><h4 id="Model-Trajectory"><a class="docs-heading-anchor" href="#Model-Trajectory">Model Trajectory</a><a id="Model-Trajectory-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Trajectory" title="Permalink"></a></h4><pre><code class="language-julia hljs">using Plots; gr()
model_trajectory = ODEmodel(t_pred, θ_true)</code></pre><pre><code class="language-julia hljs">plt = plot_predictions_union(model, t_pred, 1, dof=model.core.num_pars,
    compare_to_full_sample_type=LatinHypercubeSamples(), plot_title=&quot;&quot;) # univariate profiles

plot!(plt; dpi=150, size=(450, 300), xlims=(t_pred[1], t_pred[end]))
plot!(plt[1], t_pred, model_trajectory[1],
    lw=3, color=:turquoise4, linestyle=:dash)
plot!(plt[2], t_pred, model_trajectory[2],
    label=&quot;True model trajectory&quot;, lw=3, color=:turquoise4, linestyle=:dash)</code></pre><p><img src="../../assets/figures/two-species_logistic/two-species_logistic_univariate_trajectory.png" alt/></p><pre><code class="language-julia hljs">plt = plot_predictions_union(model, t_pred, 2, dof=model.core.num_pars,
    compare_to_full_sample_type=LatinHypercubeSamples(), plot_title=&quot;&quot;) # bivariate profiles

plot!(plt; dpi=150, size=(450, 300), xlims=(t_pred[1], t_pred[end]))
plot!(plt[1], t_pred, model_trajectory[1],
    lw=3, color=:turquoise4, linestyle=:dash)
plot!(plt[2], t_pred, model_trajectory[2],
    label=&quot;True model trajectory&quot;, lw=3, color=:turquoise4, linestyle=:dash)</code></pre><p><img src="../../assets/figures/two-species_logistic/two-species_logistic_bivariate_trajectory.png" alt/></p><h4 id="1-\\delta-Population-Reference-Set"><a class="docs-heading-anchor" href="#1-\\delta-Population-Reference-Set"><span>$1-\delta$</span> Population Reference Set</a><a id="1-\\delta-Population-Reference-Set-1"></a><a class="docs-heading-anchor-permalink" href="#1-\\delta-Population-Reference-Set" title="Permalink"></a></h4><pre><code class="language-julia hljs">using Plots; gr()
lq, uq = errorfunction(hcat(ODEmodel(t_pred, θ_true)...), θ_true, 0.95)</code></pre><pre><code class="language-julia hljs">plt = plot_realisations_union(model, t_pred, 1, dof=model.core.num_pars,
    compare_to_full_sample_type=LatinHypercubeSamples(), plot_title=&quot;&quot;) # univariate profiles

plot!(plt, t_pred, lq, fillrange=uq, fillalpha=0.3, linealpha=0,
    label=&quot;95% population reference set&quot;, color=palette(:Paired)[1])
scatter!(plt, data.t, data.y_obs, label=&quot;Observations&quot;, msw=0, ms=7, color=palette(:Paired)[3],
    xlims=(t_pred[1], t_pred[end]), dpi=150, size=(450, 300))</code></pre><p><img src="../../assets/figures/two-species_logistic/two-species_logistic_univariate_reference_tolerance.png" alt/></p><pre><code class="language-julia hljs">plt = plot_realisations_union(model, t_pred, 2, dof=model.core.num_pars, 
    compare_to_full_sample_type=LatinHypercubeSamples(), plot_title=&quot;&quot;) # bivariate profiles

plot!(plt, t_pred, lq, fillrange=uq, fillalpha=0.3, linealpha=0,
    label=&quot;95% population reference set&quot;, color=palette(:Paired)[1])
scatter!(plt, data.t, data.y_obs, label=&quot;Observations&quot;, msw=0, ms=7, color=palette(:Paired)[3],
    xlims=(t_pred[1], t_pred[end]), dpi=150, size=(450, 300))</code></pre><p><img src="../../assets/figures/two-species_logistic/two-species_logistic_bivariate_reference_tolerance.png" alt/></p><h2 id="Coverage-Testing"><a class="docs-heading-anchor" href="#Coverage-Testing">Coverage Testing</a><a id="Coverage-Testing-1"></a><a class="docs-heading-anchor-permalink" href="#Coverage-Testing" title="Permalink"></a></h2><p>To conduct an investigation into the coverage properties of the profiles and profile-wise predictions sets we can perform a simulation study using the provided coverage functions. The procedures are effectively identical to those used for the <a href="../logistic/#Logistic-Model">Logistic Model</a>; the commentary for that example remains similar for this example, however coverage may be lower than expected due to too few observations. </p><div class="admonition is-danger"><header class="admonition-header">Computational time of these tests</header><div class="admonition-body"><p>The computational time of several of the below tests is up to 4 hrs with 10 worker processes on the author&#39;s pc.</p></div></div><h3 id="Data-Generation"><a class="docs-heading-anchor" href="#Data-Generation">Data Generation</a><a id="Data-Generation-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Generation" title="Permalink"></a></h3><p>First we define functions and arguments which we use to simulate new training and testing data, and evaluate the true <span>$1-\delta$</span> population reference set, given the true parameter values. </p><pre><code class="language-julia hljs"># DATA GENERATION FUNCTION AND ARGUMENTS
@everywhere function data_generator(θtrue, generator_args::NamedTuple)
    y_obs = zeros(size(generator_args.y_true))
    for i in eachindex(generator_args.y_true)
        y_obs[i] = rand(LogitNormal(logit(generator_args.y_true[i]/100.), θtrue[7]))
    end
    y_obs .= y_obs .* 100
    if generator_args.is_test_set; return y_obs end
    data = (y_obs=y_obs, generator_args...)
    return data
end

@everywhere function reference_set_generator(θtrue, generator_args::NamedTuple, region::Float64)
    lq, uq = errorfunction(generator_args.y_true, θtrue, region)
    return (lq, uq)
end

training_gen_args = (y_true=y_true, t=t, is_test_set=false)
testing_gen_args = (y_true=predictfunction(θ_true, data, t_pred), t=t_pred, is_test_set=true)</code></pre><h4 id="Parameter-Confidence-Intervals"><a class="docs-heading-anchor" href="#Parameter-Confidence-Intervals">Parameter Confidence Intervals</a><a id="Parameter-Confidence-Intervals-1"></a><a class="docs-heading-anchor-permalink" href="#Parameter-Confidence-Intervals" title="Permalink"></a></h4><p>Coverage of parameter confidence intervals:</p><pre><code class="language-julia hljs">opt_settings = create_OptimizationSettings(solve_kwargs=(maxtime=5, xtol_rel=1e-12))

uni_coverage_df = check_univariate_parameter_coverage(data_generator,
    training_gen_args, model, 1000, θ_true, collect(1:model.core.num_pars),
    optimizationsettings=opt_settings)</code></pre><h4 id="Bivariate-Profiles-2"><a class="docs-heading-anchor" href="#Bivariate-Profiles-2">Bivariate Profiles</a><a class="docs-heading-anchor-permalink" href="#Bivariate-Profiles-2" title="Permalink"></a></h4><p>Coverage of the true value of each set of bivariate interest parameters:</p><pre><code class="language-julia hljs">opt_settings = create_OptimizationSettings(solve_kwargs=(maxtime=5, xtol_rel=1e-12))

biv_coverage_df = check_bivariate_parameter_coverage(data_generator,
    training_gen_args, model, 1000, 30, θ_true, 
    collect(combinations(1:model.core.num_pars, 2)),
    method = RadialMLEMethod(0.15, 0.1), 
    optimizationsettings=opt_settings)</code></pre><p>Coverage of the true bivariate boundary. 2000 samples corresponds to around 100-200 retained points:</p><pre><code class="language-julia hljs">opt_settings = create_OptimizationSettings(solve_kwargs=(maxtime=5, xtol_rel=1e-12))

biv_boundary_coverage_df = check_bivariate_boundary_coverage(data_generator,
    training_gen_args, model, 100, 30, 2000, θ_true,
    collect(combinations(1:model.core.num_pars, 2)); 
    method = RadialMLEMethod(0.15, 0.1), 
    coverage_estimate_quantile_level=0.9,
    optimizationsettings=opt_settings)</code></pre><h3 id="Prediction-Coverage"><a class="docs-heading-anchor" href="#Prediction-Coverage">Prediction Coverage</a><a id="Prediction-Coverage-1"></a><a class="docs-heading-anchor-permalink" href="#Prediction-Coverage" title="Permalink"></a></h3><h4 id="Model-Trajectory-2"><a class="docs-heading-anchor" href="#Model-Trajectory-2">Model Trajectory</a><a class="docs-heading-anchor-permalink" href="#Model-Trajectory-2" title="Permalink"></a></h4><p>To test the coverage of the true model trajectory we can use <a href="../../user_interface/coverage/predictions_and_realisations/#LikelihoodBasedProfileWiseAnalysis.check_dimensional_prediction_coverage"><code>check_dimensional_prediction_coverage</code></a>, <a href="../../user_interface/coverage/predictions_and_realisations/#LikelihoodBasedProfileWiseAnalysis.check_univariate_prediction_coverage"><code>check_univariate_prediction_coverage</code></a> and <a href="../../user_interface/coverage/predictions_and_realisations/#LikelihoodBasedProfileWiseAnalysis.check_bivariate_prediction_coverage"><code>check_bivariate_prediction_coverage</code></a>. Again we use the default 95% confidence level here. Given a sufficient number of sampled points we expect the model trajectory coverage from the trajectory confidence set from propagating forward the full parameter vector 95% confidence set to have 95% simultaneous coverage. </p><div class="admonition is-danger"><header class="admonition-header">Using manual GC calls</header><div class="admonition-body"><p>On versions of Julia earlier than 1.10, we recommend setting the kwarg, <code>manual_GC_calls</code>, to true in each of the coverage functions. Otherwise the garbage collector may not successfully free memory every iteration leading to out of memory errors.</p></div></div><pre><code class="language-julia hljs">opt_settings = create_OptimizationSettings(solve_kwargs=(maxtime=5, xtol_rel=1e-12))

full_trajectory_coverage_df = check_dimensional_prediction_coverage(data_generator, 
    training_gen_args, t_pred, model, 200, Int(1e7), 
    θ_true, [collect(1:model.core.num_pars)], lb=lb_sample, ub=ub_sample)

uni_trajectory_coverage_df = check_univariate_prediction_coverage(data_generator, 
    training_gen_args, t_pred, model, 1000, 
    θ_true, collect(1:model.core.num_pars),
    optimizationsettings=opt_settings)

biv_trajectory_coverage_df = check_bivariate_prediction_coverage(data_generator, 
    training_gen_args, t_pred, model, 1000, 30, θ_true, 
    collect(combinations(1:model.core.num_pars, 2)),
    method=RadialMLEMethod(0.15, 0.1),
    optimizationsettings=opt_settings)</code></pre><p>Repeating the coverage of univariate and bivariate profiles using the profile path approach:</p><pre><code class="language-julia hljs">uni_trajectory_coverage_df = check_univariate_prediction_coverage(data_generator, 
    training_gen_args, t_pred, model, 1000, 
    θ_true, collect(1:model.core.num_pars), 
    dof=model.core.num_pars,
    optimizationsettings=opt_settings)

biv_trajectory_coverage_df = check_bivariate_prediction_coverage(data_generator, 
    training_gen_args, t_pred, model, 1000, 30, θ_true, 
    collect(combinations(1:model.core.num_pars, 2)),
    dof=model.core.num_pars,
    method=RadialMLEMethod(0.15, 0.1),
    optimizationsettings=opt_settings)</code></pre><h4 id="1-\\delta-Population-Reference-Set-and-Observations"><a class="docs-heading-anchor" href="#1-\\delta-Population-Reference-Set-and-Observations"><span>$1-\delta$</span> Population Reference Set and Observations</a><a id="1-\\delta-Population-Reference-Set-and-Observations-1"></a><a class="docs-heading-anchor-permalink" href="#1-\\delta-Population-Reference-Set-and-Observations" title="Permalink"></a></h4><p>To test the coverage of the <span>$1-\delta$</span> population reference set as well as observations we can use <a href="../../user_interface/coverage/predictions_and_realisations/#LikelihoodBasedProfileWiseAnalysis.check_dimensional_prediction_realisations_coverage"><code>check_dimensional_prediction_realisations_coverage</code></a>, <a href="../../user_interface/coverage/predictions_and_realisations/#LikelihoodBasedProfileWiseAnalysis.check_univariate_prediction_realisations_coverage"><code>check_univariate_prediction_realisations_coverage</code></a> and <a href="../../user_interface/coverage/predictions_and_realisations/#LikelihoodBasedProfileWiseAnalysis.check_bivariate_prediction_realisations_coverage"><code>check_bivariate_prediction_realisations_coverage</code></a>. Here we will only look at the coverage for simultaneous profiles.</p><div class="admonition is-danger"><header class="admonition-header">Using manual GC calls</header><div class="admonition-body"><p>On versions of Julia earlier than 1.10, we recommend setting the kwarg, <code>manual_GC_calls</code>, to true in each of the coverage functions. Otherwise the garbage collector may not successfully free memory every iteration leading to out of memory errors.</p></div></div><pre><code class="language-julia hljs">full_reference_coverage_df = check_dimensional_prediction_realisations_coverage(data_generator,
    reference_set_generator, training_gen_args, testing_gen_args, t_pred, model, 200, Int(1e7), 
    θ_true, [collect(1:model.core.num_pars)], lb=lb_sample, ub=ub_sample)

uni_reference_coverage_df = check_univariate_prediction_realisations_coverage(data_generator,
    reference_set_generator, training_gen_args, testing_gen_args, t_pred, model, 1000, 
    θ_true, collect(1:model.core.num_pars), 
    dof=model.core.num_pars, 
    optimizationsettings=opt_settings)

biv_reference_coverage_df = check_bivariate_prediction_realisations_coverage(data_generator,
    reference_set_generator, training_gen_args, testing_gen_args, t_pred, model, 1000, 30, θ_true, 
    collect(combinations(1:model.core.num_pars, 2)),
    dof=model.core.num_pars,
    method=RadialMLEMethod(0.15, 0.1),
    optimizationsettings=opt_settings)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../lotka-volterra/">« Lotka-Volterra Model</a><a class="docs-footer-nextpage" href="../binomial_normal_approximation/">Gaussian Approximation of a Binomial Distribution »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Thursday 8 February 2024 04:36">Thursday 8 February 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
