<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Logistic Model · LikelihoodBasedProfileWiseAnalysis.jl</title><meta name="title" content="Logistic Model · LikelihoodBasedProfileWiseAnalysis.jl"/><meta property="og:title" content="Logistic Model · LikelihoodBasedProfileWiseAnalysis.jl"/><meta property="twitter:title" content="Logistic Model · LikelihoodBasedProfileWiseAnalysis.jl"/><meta name="description" content="Documentation for LikelihoodBasedProfileWiseAnalysis.jl."/><meta property="og:description" content="Documentation for LikelihoodBasedProfileWiseAnalysis.jl."/><meta property="twitter:description" content="Documentation for LikelihoodBasedProfileWiseAnalysis.jl."/><meta property="og:url" content="https://JoelTrent.github.io/LikelihoodBasedProfileWiseAnalysis.jl/examples/logistic/"/><meta property="twitter:url" content="https://JoelTrent.github.io/LikelihoodBasedProfileWiseAnalysis.jl/examples/logistic/"/><link rel="canonical" href="https://JoelTrent.github.io/LikelihoodBasedProfileWiseAnalysis.jl/examples/logistic/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">LikelihoodBasedProfileWiseAnalysis.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../workflow_background/">Workflow Background</a></li><li><span class="tocitem">User Interface</span><ul><li><a class="tocitem" href="../../user_interface/initialisation/">Initialisation</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Parameter Profiles and Samples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../user_interface/profiles_and_samples/profile_structs/">Structs and Profile Types</a></li><li><a class="tocitem" href="../../user_interface/profiles_and_samples/univariate/">Univariate Profiles</a></li><li><a class="tocitem" href="../../user_interface/profiles_and_samples/bivariate/">Bivariate Profiles</a></li><li><a class="tocitem" href="../../user_interface/profiles_and_samples/dimensional/">Dimensional Samples</a></li></ul></li><li><a class="tocitem" href="../../user_interface/predictions/">Predictions</a></li><li><a class="tocitem" href="../../user_interface/plots/">Plots</a></li><li><a class="tocitem" href="../../user_interface/saving_and_loading/">Saving and Loading LikelihoodModels</a></li><li><a class="tocitem" href="../../user_interface/timing_and_profiling/">Timing and Profiling</a></li><li><input class="collapse-toggle" id="menuitem-3-7" type="checkbox"/><label class="tocitem" for="menuitem-3-7"><span class="docs-label">Simulated Coverage Checks</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../user_interface/coverage/univariate_intervals/">Parameter Confidence Intervals</a></li><li><a class="tocitem" href="../../user_interface/coverage/bivariate_boundaries/">Bivariate Parameter Confidence Boundaries</a></li><li><a class="tocitem" href="../../user_interface/coverage/predictions_and_realisations/">Predictions and Realisations</a></li></ul></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../">Initial Setup</a></li><li class="is-active"><a class="tocitem" href>Logistic Model</a><ul class="internal"><li><a class="tocitem" href="#Initial-Setup"><span>Initial Setup</span></a></li><li><a class="tocitem" href="#Model-and-Likelihood-Function-Definition"><span>Model and Likelihood Function Definition</span></a></li><li><a class="tocitem" href="#Initial-Data-and-Parameter-Definition"><span>Initial Data and Parameter Definition</span></a></li><li><a class="tocitem" href="#LikelihoodModel-Initialisation"><span>LikelihoodModel Initialisation</span></a></li><li><a class="tocitem" href="#Full-Parameter-Vector-Confidence-Set-Evaluation"><span>Full Parameter Vector Confidence Set Evaluation</span></a></li><li><a class="tocitem" href="#Profiling"><span>Profiling</span></a></li><li><a class="tocitem" href="#Predictions"><span>Predictions</span></a></li><li><a class="tocitem" href="#Coverage-Testing"><span>Coverage Testing</span></a></li></ul></li><li><a class="tocitem" href="../lotka-volterra/">Lotka-Volterra Model</a></li><li><a class="tocitem" href="../two-species_logistic/">Two-Species Logistic Model</a></li><li><a class="tocitem" href="../binomial_normal_approximation/">Gaussian Approximation of a Binomial Distribution</a></li><li><a class="tocitem" href="../logistic_timing_estimates/">Function Evaluation Timing - Logistic Model</a></li></ul></li><li><span class="tocitem">Internal Library</span><ul><li><a class="tocitem" href="../../internal_library/common/">Common Functions</a></li><li><a class="tocitem" href="../../internal_library/initialisation/">Initialisation</a></li><li><a class="tocitem" href="../../internal_library/ellipse_likelihood/">Ellipse Functions</a></li><li><a class="tocitem" href="../../internal_library/univariate/">Univariate Functions</a></li><li><a class="tocitem" href="../../internal_library/bivariate/">Bivariate Functions</a></li><li><a class="tocitem" href="../../internal_library/dimensional/">Dimensional Functions</a></li><li><a class="tocitem" href="../../internal_library/predictions/">Prediction Functions</a></li><li><a class="tocitem" href="../../internal_library/plots/">Plotting Functions</a></li><li><a class="tocitem" href="../../internal_library/coverage/">Coverage Functions</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Logistic Model</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Logistic Model</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JoelTrent/LikelihoodBasedProfileWiseAnalysis.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JoelTrent/LikelihoodBasedProfileWiseAnalysis.jl/blob/main/docs/src/examples/logistic.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Logistic-Model"><a class="docs-heading-anchor" href="#Logistic-Model">Logistic Model</a><a id="Logistic-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Logistic-Model" title="Permalink"></a></h1><p>The code included in this example is compiled into a single file <a href="https://github.com/JoelTrent/LikelihoodBasedProfileWiseAnalysis.jl/blob/main/examples/logistic.jl">here</a>.</p><p>The logistic model with a normal data distribution [<a href="../../references/#simpsonprofilewise2023">1</a>] has the following differential equation for the population density <span>$C(t)\geq0$</span>:</p><p class="math-container">\[\frac{\mathrm{d}C(t)}{\mathrm{d}t} = \lambda C(t) \Bigg[1-\frac{C(t)}{K}\Bigg],\]</p><p>where the model parameter vector is given by <span>$\theta^M = (\lambda, K, C(0))$</span>. The corresponding additive Gaussian data distribution, with a fixed standard deviation, has a density function for the observed data given by:</p><p class="math-container">\[y_i \sim p(y_i ; \theta) \sim \mathcal{N}(z_i(\theta^M), \sigma^2),\]</p><p>where <span>$z_i(\theta^M)=z(t_i; \theta^M)$</span> is the model solution of the first Equation at <span>$t_i$</span> and <span>$\sigma=10$</span>.</p><p>The true parameter values are <span>$\theta^M =(0.01, 100, 10)$</span>. The corresponding lower and upper parameter bounds are <span>$a = (0, 50, 0)$</span> and <span>$b = (0.05,150,50)$</span>. Observation times are <span>$t_{1:I} = 0,100,200,...,1000$</span>. The original implementation can be found at <a href="https://github.com/ProfMJSimpson/Workflow">https://github.com/ProfMJSimpson/Workflow</a>. Example realisations, the true model trajectory and 95% population reference set under this parameterisation can be seen in the figure below:</p><p><img src="../../assets/figures/logistic/logistic_example.png" alt/></p><h2 id="Initial-Setup"><a class="docs-heading-anchor" href="#Initial-Setup">Initial Setup</a><a id="Initial-Setup-1"></a><a class="docs-heading-anchor-permalink" href="#Initial-Setup" title="Permalink"></a></h2><p>Here we add three worker processes, which matches the number of univariate and bivariate profiles. For coverage testing we recommend setting this number as discussed in <a href="../#Import-Package-and-Set-Up-Distributed-Environment">Import Package and Set Up Distributed Environment</a>. </p><pre><code class="language-julia hljs">using Distributed
if nprocs()==1; addprocs(3, env=[&quot;JULIA_NUM_THREADS&quot;=&gt;&quot;1&quot;]) end
@everywhere using Random, Distributions
@everywhere using LikelihoodBasedProfileWiseAnalysis
using Combinatorics</code></pre><h2 id="Model-and-Likelihood-Function-Definition"><a class="docs-heading-anchor" href="#Model-and-Likelihood-Function-Definition">Model and Likelihood Function Definition</a><a id="Model-and-Likelihood-Function-Definition-1"></a><a class="docs-heading-anchor-permalink" href="#Model-and-Likelihood-Function-Definition" title="Permalink"></a></h2><pre><code class="language-julia hljs">@everywhere function solvedmodel(t, θ)
    return (θ[2]*θ[3]) ./ ((θ[2]-θ[3]) .* (exp.(-θ[1] .* t)) .+ θ[3])
end

@everywhere function loglhood(θ, data)
    y=solvedmodel(data.t, θ)
    e=sum(loglikelihood(data.dist, data.y_obs .- y))
    return e
end</code></pre><h2 id="Initial-Data-and-Parameter-Definition"><a class="docs-heading-anchor" href="#Initial-Data-and-Parameter-Definition">Initial Data and Parameter Definition</a><a id="Initial-Data-and-Parameter-Definition-1"></a><a class="docs-heading-anchor-permalink" href="#Initial-Data-and-Parameter-Definition" title="Permalink"></a></h2><pre><code class="language-julia hljs"># true parameters
λ_true=0.01; K_true=100.0; C0_true=10.0; t=0:100:1000; 
@everywhere global σ=10.0;
θ_true=[λ_true, K_true, C0_true]
y_true = solvedmodel(t, θ_true)
y_obs = [19.27, 20.14, 37.23, 74.87, 88.51, 82.91, 123.88, 103.25, 78.89, 87.87, 113.0]

# Named tuple of all data required within the log-likelihood function
data = (y_obs=y_obs, t=t, dist=Normal(0, σ))

# Bounds on model parameters 
λ_min, λ_max = (0.00, 0.05)
K_min, K_max = (50., 150.)
C0_min, C0_max = (0.0, 50.)
lb = [λ_min, K_min, C0_min]
ub = [λ_max, K_max, C0_max]

θnames = [:λ, :K, :C0]
θG = θ_true
par_magnitudes = [0.005, 10, 10]</code></pre><h2 id="LikelihoodModel-Initialisation"><a class="docs-heading-anchor" href="#LikelihoodModel-Initialisation">LikelihoodModel Initialisation</a><a id="LikelihoodModel-Initialisation-1"></a><a class="docs-heading-anchor-permalink" href="#LikelihoodModel-Initialisation" title="Permalink"></a></h2><p>Here we choose to set some optimization settings, <code>opt_settings</code>, which are used when determining the maximum likelihood estimate <span>$\hat{\theta}$</span>. If different settings are not provided to functions for profiling, then these settings (which are now contained in the <a href="../../user_interface/initialisation/#LikelihoodBasedProfileWiseAnalysis.LikelihoodModel"><code>LikelihoodModel</code></a>), will be used.</p><pre><code class="language-julia hljs">opt_settings = create_OptimizationSettings(solve_kwargs=(maxtime=5,))
model = initialise_LikelihoodModel(loglhood, data, θnames, θG, lb, ub, par_magnitudes, optimizationsettings=opt_settings)</code></pre><h2 id="Full-Parameter-Vector-Confidence-Set-Evaluation"><a class="docs-heading-anchor" href="#Full-Parameter-Vector-Confidence-Set-Evaluation">Full Parameter Vector Confidence Set Evaluation</a><a id="Full-Parameter-Vector-Confidence-Set-Evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Full-Parameter-Vector-Confidence-Set-Evaluation" title="Permalink"></a></h2><p>To evaluate the full parameter vector confidence set at a 95% confidence level we use:</p><pre><code class="language-julia hljs">full_likelihood_sample!(model, 30000, use_distributed=true)</code></pre><h2 id="Profiling"><a class="docs-heading-anchor" href="#Profiling">Profiling</a><a id="Profiling-1"></a><a class="docs-heading-anchor-permalink" href="#Profiling" title="Permalink"></a></h2><h3 id="Univariate-Profiles"><a class="docs-heading-anchor" href="#Univariate-Profiles">Univariate Profiles</a><a id="Univariate-Profiles-1"></a><a class="docs-heading-anchor-permalink" href="#Univariate-Profiles" title="Permalink"></a></h3><p>To find the confidence intervals for all three parameters at a 95% confidence level (the default), we use:</p><pre><code class="language-julia hljs">univariate_confidenceintervals!(model)</code></pre><p>If we instead wish to find these intervals at a 99% confidence interval we use:</p><pre><code class="language-julia hljs">univariate_confidenceintervals!(model, confidence_level=0.99)</code></pre><p>Similarly, if we wish to find simultaneous 95% confidence intervals for the parameters we set the degrees of freedom to the number of model parameters (instead of <code>1</code>).</p><pre><code class="language-julia hljs">univariate_confidenceintervals!(model, dof=model.core.num_pars) # model.core.num_pars=3</code></pre><p>To find asymptotic confidence intervals using the ellipse approximation, we change the specified profile type to <a href="../../user_interface/profiles_and_samples/profile_structs/#LikelihoodBasedProfileWiseAnalysis.EllipseApproxAnalytical"><code>EllipseApproxAnalytical</code></a> or <a href="../../user_interface/profiles_and_samples/profile_structs/#LikelihoodBasedProfileWiseAnalysis.EllipseApprox"><code>EllipseApprox</code></a>. When parameter constraints are not in the way these will produce the same result for well-identified models:</p><pre><code class="language-julia hljs">univariate_confidenceintervals!(model, profile_type=EllipseApproxAnalytical())
univariate_confidenceintervals!(model, profile_type=EllipseApprox())</code></pre><p>If we want to visualise the univariate profiles across the range defined by each confidence interval then we need to evaluate points inside each interval. We can also evaluate some points to the left and right of each interval to observe the behaviour of the profile log-likelihood function outside of this range:</p><pre><code class="language-julia hljs">get_points_in_intervals!(model, 20, additional_width=0.2)</code></pre><p>This can also be done within <a href="../../user_interface/profiles_and_samples/univariate/#LikelihoodBasedProfileWiseAnalysis.univariate_confidenceintervals!"><code>univariate_confidenceintervals!</code></a> using the <code>num_points_in_interval</code> and <code>additional_width</code> keyword arguments.</p><h4 id="Initial-Guesses"><a class="docs-heading-anchor" href="#Initial-Guesses">Initial Guesses</a><a id="Initial-Guesses-1"></a><a class="docs-heading-anchor-permalink" href="#Initial-Guesses" title="Permalink"></a></h4><p>We can use existing confidence intervals to reduce the search bracket for other confidence intervals of interest. </p><p>For example, we can use the confidence intervals found at a 99% confidence level with one degree of freedom to more quickly find the corresponding intervals at a 95% confidence level. We set <code>existing_profiles=:overwrite</code> so that we recalculate these profiles - otherwise they won&#39;t be calculated as they already exist!</p><pre><code class="language-julia hljs">univariate_confidenceintervals!(model, confidence_level=0.99)
univariate_confidenceintervals!(model, confidence_level=0.95, use_existing_profiles=true, 
    existing_profiles=:overwrite, num_points_in_interval=20, additional_width=0.2)</code></pre><p>Similarly, we can use profiles of type <a href="../../user_interface/profiles_and_samples/profile_structs/#LikelihoodBasedProfileWiseAnalysis.EllipseApproxAnalytical"><code>EllipseApproxAnalytical</code></a> to decrease the bracket. This is recommended for identifiable parameters.</p><pre><code class="language-julia hljs">univariate_confidenceintervals!(model, profile_type=EllipseApproxAnalytical())
univariate_confidenceintervals!(model, use_ellipse_approx_analytical_start=true, 
    existing_profiles=:overwrite, num_points_in_interval=20, additional_width=0.2)</code></pre><h3 id="Bivariate-Profiles"><a class="docs-heading-anchor" href="#Bivariate-Profiles">Bivariate Profiles</a><a id="Bivariate-Profiles-1"></a><a class="docs-heading-anchor-permalink" href="#Bivariate-Profiles" title="Permalink"></a></h3><p>To evaluate the bivariate boundaries for all three bivariate parameter combinations, here we use the <a href="../../user_interface/profiles_and_samples/bivariate/#LikelihoodBasedProfileWiseAnalysis.IterativeBoundaryMethod"><code>IterativeBoundaryMethod</code></a>, which uses a 20 point ellipse approximation of the boundary as a starting guess using <a href="../../user_interface/profiles_and_samples/bivariate/#LikelihoodBasedProfileWiseAnalysis.RadialMLEMethod"><code>RadialMLEMethod</code></a>. The boundaries in this example are reasonably convex, which makes this starting guess appropriate. To speed up computation we provide stronger optimization settings.</p><pre><code class="language-julia hljs">opt_settings = create_OptimizationSettings(solve_kwargs=(maxtime=5, xtol_rel=1e-12))
bivariate_confidenceprofiles!(model, 50, 
    method=IterativeBoundaryMethod(20, 5, 5, 0.15, 1.0, use_ellipse=true), 
    optimizationsettings=opt_settings)</code></pre><p>Similarly, if we wish to evaluate simultaneous 95% bivariate profiles we set the degrees of freedom parameter, <code>dof</code>, to the number of model parameters (instead of <code>2</code>).</p><pre><code class="language-julia hljs">opt_settings = create_OptimizationSettings(solve_kwargs=(maxtime=5, xtol_rel=1e-12))
bivariate_confidenceprofiles!(model, 50, 
    method=IterativeBoundaryMethod(20, 5, 5, 0.15, 1.0, use_ellipse=true), 
    dof=model.core.num_pars,
    optimizationsettings=opt_settings)</code></pre><p>To evaluate the analytical ellipse boundaries using <a href="https://joeltrent.github.io/EllipseSampling.jl/stable">EllipseSampling</a> we use:</p><pre><code class="language-julia hljs">bivariate_confidenceprofiles!(model, 50, 
    profile_type=EllipseApproxAnalytical(), method=AnalyticalEllipseMethod(0.15, 1.0))</code></pre><p>To efficiently sample 100 points within the bivariate boundaries using a rejection sampling approach we use:</p><pre><code class="language-julia hljs">sample_bivariate_internal_points!(model, 100)</code></pre><h3 id="Plots-of-Profiles"><a class="docs-heading-anchor" href="#Plots-of-Profiles">Plots of Profiles</a><a id="Plots-of-Profiles-1"></a><a class="docs-heading-anchor-permalink" href="#Plots-of-Profiles" title="Permalink"></a></h3><p>To visualise plots of these profiles we load <a href="https://docs.juliaplots.org/stable/">Plots</a> alongside a plotting backend. Here we use <a href="https://github.com/jheinen/GR.jl">GR</a>.</p><pre><code class="language-julia hljs">using Plots, Plots.PlotMeasures; gr()
Plots.reset_defaults(); Plots.scalefontsizes(0.75)</code></pre><p>Univariate and bivariate profiles can either be visualised individually or in comparison to profiles at the same confidence level and degrees of freedom. </p><p>Here we compare the univariate profiles formed at a 95% confidence level and 1 degree of freedom. The first two arguments scale the limits of the x and y axis, respectively, away from the found confidence interval at the specified threshold.</p><pre><code class="language-julia hljs">plts = plot_univariate_profiles_comparison(model, 0.1, 0.1,
    confidence_levels=[0.95], dofs=[1])

plt = plot(plts..., layout=(1,3),
    legend=:outertop, title=&quot;&quot;, dpi=150, size=(550,300), margin=1mm)
display(plt)</code></pre><p><img src="../../assets/figures/logistic/logistic_univariate_plots.png" alt/></p><p>Similarly, here we compare the bivariate profiles formed at a 95% confidence level and 2 degrees of freedom.</p><pre><code class="language-julia hljs">plts = plot_bivariate_profiles_comparison(model, 0.1, 0.1, confidence_levels=[0.95], dofs=[2])

plt = plot(plts..., layout=(1,3),
    legend=:outertop, title=&quot;&quot;, dpi=150, size=(550,300), margin=1mm)
display(plt)</code></pre><p><img src="../../assets/figures/logistic/logistic_bivariate_plots.png" alt/></p><h2 id="Predictions"><a class="docs-heading-anchor" href="#Predictions">Predictions</a><a id="Predictions-1"></a><a class="docs-heading-anchor-permalink" href="#Predictions" title="Permalink"></a></h2><p>To make predictions for the model trajectory and the <span>$1-\delta$</span> population reference set we define the following functions, which then need to be added to our <a href="../../user_interface/initialisation/#LikelihoodBasedProfileWiseAnalysis.LikelihoodModel"><code>LikelihoodModel</code></a>. The <code>region</code> variable in <code>errorfunction</code> should be set equal to <span>$1-\delta$</span> when generating predictions. These could also be added in <a href="../../user_interface/initialisation/#LikelihoodBasedProfileWiseAnalysis.initialise_LikelihoodModel"><code>initialise_LikelihoodModel</code></a>.</p><pre><code class="language-julia hljs">@everywhere function predictfunction(θ, data, t=data.t); solvedmodel(t, θ) end
@everywhere function errorfunction(predictions, θ, region); normal_error_σ_known(predictions, θ, region, σ) end

add_prediction_function!(model, predictfunction)
add_error_function!(model, errorfunction)</code></pre><p>To generate profile-wise predictions for each of the evaluated profiles we first define the desired time points for prediction and then evaluate the approximate model trajectory confidence sets and <span>$(1-\delta, 1-\alpha)$</span> population reference tolerance sets. By default, the population reference tolerance set evaluates reference interval regions at the same level as the default confidence level (<span>$1-\delta = 1-\alpha = 0.95$</span>); however, this is not required.</p><pre><code class="language-julia hljs">t_pred=0:5:1000

generate_predictions_univariate!(model, t_pred)
generate_predictions_bivariate!(model, t_pred)
generate_predictions_dim_samples!(model, t_pred) # for the full likelihood sample</code></pre><h3 id="Plotting-Predictions"><a class="docs-heading-anchor" href="#Plotting-Predictions">Plotting Predictions</a><a id="Plotting-Predictions-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting-Predictions" title="Permalink"></a></h3><p>We can plot the predictions of individual profiles or the union of all profiles at a given number of interest parameters, confidence level, degrees of freedom and reference interval region (if relevant). When plotting the union of these predictions we can compare it to the result of the full likelihood sample, which here used <a href="../../user_interface/profiles_and_samples/dimensional/#LikelihoodBasedProfileWiseAnalysis.LatinHypercubeSamples"><code>LatinHypercubeSamples</code></a>, the default. Here we plot the results from simultaneous profiles at a 95% confidence level.</p><h4 id="Model-Trajectory"><a class="docs-heading-anchor" href="#Model-Trajectory">Model Trajectory</a><a id="Model-Trajectory-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Trajectory" title="Permalink"></a></h4><p>SCBs <span>$(\approx)$</span> here refer to approximate simultaneous confidence bands for the true model trajectory.</p><pre><code class="language-julia hljs">using Plots, Plots.PlotMeasures; gr()
plt = plot_predictions_union(model, t_pred, 1, dof=model.core.num_pars,
    compare_to_full_sample_type=LatinHypercubeSamples(), title=&quot;&quot;) # univariate profiles

plot!(plt, t_pred, solvedmodel(t_pred, θ_true), 
    label=&quot;True model trajectory&quot;, lw=3, color=:turquoise4, linestyle=:dash,
    dpi=150, size=(450,300), rightmargin=3mm)</code></pre><p><img src="../../assets/figures/logistic/logistic_univariate_trajectory.png" alt/></p><pre><code class="language-julia hljs">plt = plot_predictions_union(model, t_pred, 2, dof=model.core.num_pars,
    compare_to_full_sample_type=LatinHypercubeSamples(), title=&quot;&quot;) # bivariate profiles

plot!(plt, t_pred, solvedmodel(t_pred, θ_true), 
    label=&quot;True model trajectory&quot;, lw=3, color=:turquoise4, linestyle=:dash,
    dpi=150, size=(450,300), rightmargin=3mm)</code></pre><p><img src="../../assets/figures/logistic/logistic_bivariate_trajectory.png" alt/></p><h4 id="1-\\delta-Population-Reference-Set"><a class="docs-heading-anchor" href="#1-\\delta-Population-Reference-Set"><span>$1-\delta$</span> Population Reference Set</a><a id="1-\\delta-Population-Reference-Set-1"></a><a class="docs-heading-anchor-permalink" href="#1-\\delta-Population-Reference-Set" title="Permalink"></a></h4><p>SRTBs <span>$(\approx)$</span> here refer to approximate simultaneous reference tolerance bands for the <span>$1-\delta$</span> population reference tolerance set.</p><pre><code class="language-julia hljs">lq, uq = errorfunction(solvedmodel(t_pred, θ_true), θ_true, 0.95)</code></pre><pre><code class="language-julia hljs">using Plots; gr()
plt = plot_realisations_union(model, t_pred, 1, dof=model.core.num_pars,
    compare_to_full_sample_type=LatinHypercubeSamples(), title=&quot;&quot;) # univariate profiles

plot!(plt, t_pred, lq, fillrange=uq, fillalpha=0.3, linealpha=0,
    label=&quot;95% population reference set&quot;, color=palette(:Paired)[1])
scatter!(plt, data.t, data.y_obs, label=&quot;Observations&quot;, msw=0, ms=7, color=palette(:Paired)[3])</code></pre><p><img src="../../assets/figures/logistic/logistic_univariate_reference_tolerance.png" alt/></p><pre><code class="language-julia hljs">plt = plot_realisations_union(model, t_pred, 2, dof=model.core.num_pars, 
    compare_to_full_sample_type=LatinHypercubeSamples(), title=&quot;&quot;) # bivariate profiles

plot!(plt, t_pred, lq, fillrange=uq, fillalpha=0.3, linealpha=0,
    label=&quot;95% population reference set&quot;, color=palette(:Paired)[1])
scatter!(plt, data.t, data.y_obs, label=&quot;Observations&quot;, msw=0, ms=7, color=palette(:Paired)[3])</code></pre><p><img src="../../assets/figures/logistic/logistic_bivariate_reference_tolerance.png" alt/></p><h2 id="Coverage-Testing"><a class="docs-heading-anchor" href="#Coverage-Testing">Coverage Testing</a><a id="Coverage-Testing-1"></a><a class="docs-heading-anchor-permalink" href="#Coverage-Testing" title="Permalink"></a></h2><p>To conduct an investigation into the coverage properties of the profiles and profile-wise predictions sets we can perform a simulation study using the provided coverage functions.</p><h3 id="Data-Generation"><a class="docs-heading-anchor" href="#Data-Generation">Data Generation</a><a id="Data-Generation-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Generation" title="Permalink"></a></h3><p>First we define functions and arguments which we use to simulate new training and testing data, and evaluate the true <span>$1-\delta$</span> population reference set, given the true parameter values. </p><pre><code class="language-julia hljs"># DATA GENERATION FUNCTION AND ARGUMENTS
@everywhere function data_generator(θ_true, generator_args::NamedTuple)
    y_obs = generator_args.y_true .+ rand(generator_args.dist, length(generator_args.t))
    if generator_args.is_test_set; return y_obs end

    data = (y_obs=y_obs, generator_args...)
    return data
end

@everywhere function reference_set_generator(θ_true, generator_args::NamedTuple, region::Float64)
    lq, uq = errorfunction(generator_args.y_true, θ_true, region)
    return (lq, uq)
end

training_gen_args = (y_true=y_true, t=t, dist=Normal(0, σ), is_test_set=false)
testing_gen_args = (y_true=solvedmodel(t_pred, θ_true), t=t_pred, dist=Normal(0, σ), is_test_set=true)</code></pre><h3 id="Parameter-Coverage"><a class="docs-heading-anchor" href="#Parameter-Coverage">Parameter Coverage</a><a id="Parameter-Coverage-1"></a><a class="docs-heading-anchor-permalink" href="#Parameter-Coverage" title="Permalink"></a></h3><h4 id="Parameter-Confidence-Intervals"><a class="docs-heading-anchor" href="#Parameter-Confidence-Intervals">Parameter Confidence Intervals</a><a id="Parameter-Confidence-Intervals-1"></a><a class="docs-heading-anchor-permalink" href="#Parameter-Confidence-Intervals" title="Permalink"></a></h4><p>Here we check the coverage of the 95% confidence interval for each of the three parameters in this model across 1000 simulated iterations using <a href="../../user_interface/coverage/univariate_intervals/#LikelihoodBasedProfileWiseAnalysis.check_univariate_parameter_coverage"><code>check_univariate_parameter_coverage</code></a>. For a sufficiently regular likelihood, we would expect coverage to be approximately 0.95; a (default 95%) confidence interval using <a href="https://juliastats.org/HypothesisTests.jl/stable/">HypothesisTests.jl</a> is provided to quantify the uncertainty in the simulated estimate. This is a scenario where using a larger number of worker processes than the three we started in <a href="@ref">Initial Setup</a> would be useful, as we can distribute each simulation iteration across these workers. </p><pre><code class="language-julia hljs">opt_settings = create_OptimizationSettings(solve_kwargs=(maxtime=5, xtol_rel=1e-12))

uni_coverage_df = check_univariate_parameter_coverage(data_generator,
    training_gen_args, model, 1000, θ_true, collect(1:model.core.num_pars),
    optimizationsettings=opt_settings)</code></pre><h4 id="Bivariate-Profiles-2"><a class="docs-heading-anchor" href="#Bivariate-Profiles-2">Bivariate Profiles</a><a class="docs-heading-anchor-permalink" href="#Bivariate-Profiles-2" title="Permalink"></a></h4><p>Similarly, we can check the coverage of a 95% bivariate profile boundary for each combination of two parameters in this model across 1000 simulated iterations using <a href="../../user_interface/coverage/bivariate_boundaries/#LikelihoodBasedProfileWiseAnalysis.check_bivariate_parameter_coverage"><code>check_bivariate_parameter_coverage</code></a>. Here we evaluate the performance of a 50 point boundary generated using the <a href="../../user_interface/profiles_and_samples/bivariate/#LikelihoodBasedProfileWiseAnalysis.IterativeBoundaryMethod"><code>IterativeBoundaryMethod</code></a>. Again, we expect each bivariate profile boundary to have coverage of approximately 0.95. This means that under repeated sampling, the true value of the two interest parameters considered in a given bivariate profile is contained within the profiles boundary 95% of the time.  </p><pre><code class="language-julia hljs">opt_settings = create_OptimizationSettings(solve_kwargs=(maxtime=5, xtol_rel=1e-12))

biv_coverage_df = check_bivariate_parameter_coverage(data_generator,
    training_gen_args, model, 1000, 50, θ_true, 
    collect(combinations(1:model.core.num_pars, 2)),
    method = IterativeBoundaryMethod(10, 5, 5, 0.15, 0.1, use_ellipse=true), 
    optimizationsettings=opt_settings)</code></pre><p>We can also evaluate how well a given bivariate boundary is being represented for a given boundary method and number of boundary points. To do this we use <a href="../../user_interface/coverage/bivariate_boundaries/#LikelihoodBasedProfileWiseAnalysis.check_bivariate_boundary_coverage"><code>check_bivariate_boundary_coverage</code></a> which not only calculates each bivariate profiles boundary using <code>method</code>, but also uses a rejection sampling approach to find points inside each profiles boundary. Here we sample 4000 points using <a href="../../user_interface/profiles_and_samples/dimensional/#LikelihoodBasedProfileWiseAnalysis.dimensional_likelihood_samples!"><code>dimensional_likelihood_samples!</code></a> inside the specified parameters bounds and retain those that are within each profiles boundary. In this case this corresponds to around 250-400 retained points. We then check the proportion of these sampled points that are inside our bivariate profile using a point in polygon algorithm. If our <code>method</code> is performing well, we would expect this proportion to be close to 1.0. </p><p>Here we set <code>coverage_estimate_quantile_level</code> to <code>0.9</code>; we are interested in the lower 0.05 quantile result of the 200 simulations as this indicates that the area coverage observed should be at least this value approximately 95% of the time. If the proportion is not close to 1.0, then we would expect the result from <a href="../../user_interface/coverage/bivariate_boundaries/#LikelihoodBasedProfileWiseAnalysis.check_bivariate_parameter_coverage"><code>check_bivariate_parameter_coverage</code></a> to be generally lower than the expected confidence level.</p><pre><code class="language-julia hljs">opt_settings = create_OptimizationSettings(solve_kwargs=(maxtime=5, xtol_rel=1e-12))

biv_boundary_coverage_df = check_bivariate_boundary_coverage(data_generator,
    training_gen_args, model, 200, 50, 4000, θ_true,
    collect(combinations(1:model.core.num_pars, 2)); 
    method=IterativeBoundaryMethod(10, 5, 5, 0.15, 0.1, use_ellipse=true), 
    coverage_estimate_quantile_level=0.9,
    optimizationsettings=opt_settings)</code></pre><h3 id="Prediction-Coverage"><a class="docs-heading-anchor" href="#Prediction-Coverage">Prediction Coverage</a><a id="Prediction-Coverage-1"></a><a class="docs-heading-anchor-permalink" href="#Prediction-Coverage" title="Permalink"></a></h3><h4 id="Model-Trajectory-2"><a class="docs-heading-anchor" href="#Model-Trajectory-2">Model Trajectory</a><a class="docs-heading-anchor-permalink" href="#Model-Trajectory-2" title="Permalink"></a></h4><p>To test the coverage of the true model trajectory we can use <a href="../../user_interface/coverage/predictions_and_realisations/#LikelihoodBasedProfileWiseAnalysis.check_dimensional_prediction_coverage"><code>check_dimensional_prediction_coverage</code></a>, <a href="../../user_interface/coverage/predictions_and_realisations/#LikelihoodBasedProfileWiseAnalysis.check_univariate_prediction_coverage"><code>check_univariate_prediction_coverage</code></a> and <a href="../../user_interface/coverage/predictions_and_realisations/#LikelihoodBasedProfileWiseAnalysis.check_bivariate_prediction_coverage"><code>check_bivariate_prediction_coverage</code></a>. Again we use the default 95% confidence level here. Given a sufficient number of sampled points we expect the model trajectory coverage from the trajectory confidence set from propagating forward the full parameter vector 95% confidence set to have 95% simultaneous coverage. </p><p>The profile-wise predictions are approximate trajectory confidence sets and are not expected to reach 95% simultaneous coverage. However, they will converge to approximately the correct coverage as higher numbers of interest parameters are considered. Additionally, the asymptotic threshold being used to define the extremities of the profiles is lower than the threshold for the full parameter confidence set; there is evidence to suggest this is also responsible for constraining their coverage performance on this model. We do generally recommend sampling some points within univariate confidence intervals for propagation forward into the prediction sets, here we use 20.</p><div class="admonition is-danger"><header class="admonition-header">Using manual GC calls</header><div class="admonition-body"><p>On versions of Julia earlier than 1.10, we recommend setting the kwarg, <code>manual_GC_calls</code>, to true in each of the coverage functions. Otherwise the garbage collector may not successfully free memory every iteration leading to out of memory errors. </p></div></div><pre><code class="language-julia hljs">opt_settings = create_OptimizationSettings(solve_kwargs=(maxtime=5, xtol_rel=1e-12))

full_trajectory_coverage_df = check_dimensional_prediction_coverage(data_generator, 
    training_gen_args, t_pred, model, 1000, 30000, 
    θ_true, [collect(1:model.core.num_pars)])

uni_trajectory_coverage_df = check_univariate_prediction_coverage(data_generator, 
    training_gen_args, t_pred, model, 1000, 
    θ_true, collect(1:model.core.num_pars), 
    num_points_in_interval=20, 
    optimizationsettings=opt_settings)

biv_trajectory_coverage_df = check_bivariate_prediction_coverage(data_generator, 
    training_gen_args, t_pred, model, 1000, 20, θ_true, 
    collect(combinations(1:model.core.num_pars, 2)),
    method=IterativeBoundaryMethod(10, 5, 5, 0.15, 0.1, use_ellipse=true),
    optimizationsettings=opt_settings)</code></pre><p>We instead suggest using the profile path approach for these lower dimensional profiles, where the degrees of freedom, <code>dof</code>, used to calibrate the asymptotic threshold is equal to the number of model parameters (as opposed to the dimensionality of the profile). This produces simultaneous profiles; the extremities of these profiles now touch the extremities of the full parameter vector confidence set. This has been shown to be reasonable for identifiable models with low numbers of parameters (&lt;10). Most significantly in this example, the coverage of the trajectory confidence set from the union of simultaneous bivariate profiles is approximately 0.95. </p><pre><code class="language-julia hljs">uni_trajectory_coverage_df = check_univariate_prediction_coverage(data_generator, 
    training_gen_args, t_pred, model, 1000, 
    θ_true, collect(1:model.core.num_pars), 
    dof=model.core.num_pars,
    num_points_in_interval=20, 
    optimizationsettings=opt_settings)

biv_trajectory_coverage_df = check_bivariate_prediction_coverage(data_generator, 
    training_gen_args, t_pred, model, 1000, 20, θ_true, 
    collect(combinations(1:model.core.num_pars, 2)),
    dof=model.core.num_pars,
    method=IterativeBoundaryMethod(10, 5, 5, 0.15, 0.1, use_ellipse=true),
    optimizationsettings=opt_settings)</code></pre><h4 id="1-\\delta-Population-Reference-Set-and-Observations"><a class="docs-heading-anchor" href="#1-\\delta-Population-Reference-Set-and-Observations"><span>$1-\delta$</span> Population Reference Set and Observations</a><a id="1-\\delta-Population-Reference-Set-and-Observations-1"></a><a class="docs-heading-anchor-permalink" href="#1-\\delta-Population-Reference-Set-and-Observations" title="Permalink"></a></h4><p>To test the coverage of the <span>$1-\delta$</span> population reference set as well as observations we can use <a href="../../user_interface/coverage/predictions_and_realisations/#LikelihoodBasedProfileWiseAnalysis.check_dimensional_prediction_realisations_coverage"><code>check_dimensional_prediction_realisations_coverage</code></a>, <a href="../../user_interface/coverage/predictions_and_realisations/#LikelihoodBasedProfileWiseAnalysis.check_univariate_prediction_realisations_coverage"><code>check_univariate_prediction_realisations_coverage</code></a> and <a href="../../user_interface/coverage/predictions_and_realisations/#LikelihoodBasedProfileWiseAnalysis.check_bivariate_prediction_realisations_coverage"><code>check_bivariate_prediction_realisations_coverage</code></a>. Here we will only look at the coverage for simultaneous profiles.</p><div class="admonition is-danger"><header class="admonition-header">Using manual GC calls</header><div class="admonition-body"><p>On versions of Julia earlier than 1.10, we recommend setting the kwarg, <code>manual_GC_calls</code>, to true in each of the coverage functions. Otherwise the garbage collector may not successfully free memory every iteration leading to out of memory errors.</p></div></div><pre><code class="language-julia hljs">full_reference_coverage_df = check_dimensional_prediction_realisations_coverage(data_generator,
    reference_set_generator, training_gen_args, testing_gen_args, t_pred, model, 1000, 30000, 
    θ_true, [collect(1:model.core.num_pars)])

uni_reference_coverage_df = check_univariate_prediction_realisations_coverage(data_generator,
    reference_set_generator, training_gen_args, testing_gen_args, t_pred, model, 1000, 
    θ_true, collect(1:model.core.num_pars), 
    dof=model.core.num_pars,
    num_points_in_interval=20, 
    optimizationsettings=opt_settings)

biv_reference_coverage_df = check_bivariate_prediction_realisations_coverage(data_generator,
    reference_set_generator, training_gen_args, testing_gen_args, t_pred, model, 1000, 20, θ_true, 
    collect(combinations(1:model.core.num_pars, 2)),
    dof=model.core.num_pars,
    method=IterativeBoundaryMethod(10, 5, 5, 0.15, 0.1, use_ellipse=true),
    optimizationsettings=opt_settings)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Initial Setup</a><a class="docs-footer-nextpage" href="../lotka-volterra/">Lotka-Volterra Model »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Monday 12 February 2024 01:46">Monday 12 February 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
